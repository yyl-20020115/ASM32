Microsoft (R) Macro Assembler Version 14.44.35221.0	    12/05/25 19:37:33
							     First Pass 1 - 1


				; Seattle Computer Products 8086 Assembler  version 2.44
				;   by Tim Paterson
				; Runs on the 8086 under MS-DOS
				
				;* * * * * * REVISION HISTORY * * * * * *
				;
				; 12/29/80  2.01  General release with 86-DOS version 0.34
				; 02/22/81  2.10  Increased buffer size from 128 bytes to 1024 bytes
				; 03/18/81  2.11  General cleanup and more documentation
				; 03/24/81  2.20  Modify ESC handling for full 8087 operation
				; 04/01/81  2.21  Fix date in HEX and PRN files; modify buffer handling
				; 04/03/81  2.22  Fix 2.21 buffer handling
				; 04/13/81  2.23  Re-open source file for listing to allow assembling CON:
				; 04/28/81  2.24  Allow nested IFs
				; 07/30/81  2.25  Add Intel string mnemonics; clean up a little
				; 08/02/81  2.30  Re-write pass 2:
				;        Always report errors to console
				;        Exact byte lengths for HEX and PRN files
				; 11/08/81  2.40  Add 8087 mnemonics; print full error messages;
				;       allow expressions with *, /, and ()
				; 07/04/82  2.41  Fix Intel's 8087 "reverse-bit" bug; don't copy date
				; 08/18/82  2.42  Increase stack from 80 to 256 (Damn! Overflowed again!)
				; 01/05/83  2.43  Correct over-zealous optimization in 2.42
				; 05/09/83  2.44  Add memory usage report
				;
				;* * * * * * * * * * * * * * * * * * * * *
				
				SYMWID   EQU   5  ;5 symbols per line in dump
				BUFSIZ   EQU   1024  ;Source code buffer
				LSTBUFSIZ   EQU   BUFSIZ   ;List file buffer
				HEXBUFSIZ   EQU   70 ;Hex file buffer (26*2 + 5*2 + 3 + EXTRA)
				EOL      EQU   13 ;\r=13 ASCII carriage return
				NEL		 EQU   10 ;\n=10 ASCII new line
				OBJECT   EQU   100H  ;DEFAULT "PUT" ADDRESS
				NAME_LENGTH EQU 260 ;Maximum length of file name
				
				;The following equates define some token values returned by GETSYM
				UNDEFID  EQU   0  ;Undefined identifier (including no nearby RET)
				CONST EQU   1  ;Constant (including $)
				REG      EQU   2  ;8-bit register
				XREG  EQU   3  ;16-bit register (except segment registers)
				SREG  EQU   4  ;Segment register
				FREG  EQU   6  ;8087 floating point register
				NODESIZE EQU 80H ;128
				;Bits to build 8087 opcode table entries
				ONEREG   EQU   40H   ;Single ST register OK as operand
				NEEDOP   EQU   80H   ;Must have an operand
				INTEGER  EQU   20H   ;For integer operations
				REAL  EQU   28H   ;For real operations
				EXTENDED EQU   10H   ;For Long integers or Temporary real
				MEMORY   EQU   18H   ;For general memory operations
				STACKOP  EQU   10H   ;Two register arithmetic with pop
				ARITH EQU   8  ;Non-pop arithmetic operations
				SEEK_SET EQU 0
				SEEK_CUR EQU 1
				SEEK_END EQU 2
				
				ASSUME CS:CODESEG,DS:DATASEG
 0000				CODESEG SEGMENT "CODE" PUBLIC
				
				PUBLIC _ASM32_ENTRY@8
				
				EXTERN _cprintf :PROC
				EXTERN _fopen :PROC
				EXTERN _fread :PROC
				EXTERN _fwrite :PROC
				EXTERN _fclose :PROC
				EXTERN _feof :PROC
				EXTERN _fseek :PROC
				EXTERN _ftell :PROC
				    ;int argc, char* argv[]
				    ;ecx, eax
				_ASM32_ENTRY@8:
				   MOV   [STACK_],ESP
				   MOV   EAX,[ESP+4]  ;Get argc
				   MOV   ECX,[ESP+8]  ;Get argv pointer
				
				   CMP   EAX,1
				   JGE   HAS_FILE_NAME
				   XOR   EAX,EAX
				   DEC   EAX
				   RET
				
				HAS_FILE_NAME:
				   ;GET NAME LENGTH
				   CLD
				   MOV EDX,ECX
				   MOV EDI,EDX
				   XOR EAX,EAX
				   REPNZ SCASB
				   DEC EDI
				   SUB EDI,EDX
				   MOV [SRCNAME_LENGTH],EDI
				
				COPY_NAME:
				
				   MOV ESI,EDX
				   MOV EDI,OFFSET SRCNAME
				   MOV ECX,[SRCNAME_LENGTH] ;LENGTH
				   REP MOVSB 
				FIND_DOT:
				   CLD
				   MOV   EDI,OFFSET SRCNAME
				   MOV   ECX,[SRCNAME_LENGTH] ;MAX LENGTH
				   ADD   EDI,ECX
				   MOV   AL,'.'
				   REPNE SCASB    ;Find extion
				   ;EDI points to '.'
				   JE    DO_OPEN
				NO_DOT:
				   MOV   EDI,OFFSET SRCNAME
				   MOV   ECX,[SRCNAME_LENGTH] ;MAX LENGTH
				   ADD   EDI,ECX
				   MOV   ESI,OFFSET EXTEND
				   MOV   ECX,4
				   REP   MOVSB
				   ADD   [SRCNAME_LENGTH],4
				DO_OPEN:
				   ;OPEN FILE
				   CLD
				   PUSH  OFFSET OPEN_FLAG
				   PUSH  OFFSET SRCNAME
				   CALL _fopen
				   ADD   ESP,8
				   OR   EAX,EAX
				   JNZ   OK_FILE
				   ;SAVE FILE HANDLE
				   DEC  EAX
				   RET
				OK_FILE:
				   MOV   [SRCFILE],EAX
				   ;GET FILE SIZE
				   PUSH SEEK_END
				   PUSH 0
				   PUSH [SRCFILE]
				   CALL _fseek
				   ADD ESP,12
				   PUSH [SRCFILE]
				   CALL _ftell
				   ADD ESP,4
				   MOV DWORD PTR[SRCLENGTH],EAX
				   PUSH SEEK_SET
				   PUSH 0
				   PUSH [SRCFILE]
				   CALL _fseek
				   ADD ESP,12
				
				   ;SET HEX FILE NAME
				   MOV   ESI,OFFSET SRCNAME
				   MOV   ECX,[SRCNAME_LENGTH] ;LENGTH
				   MOV   EDI,OFFSET HEXNAME ;DESTINATION
				   CLD
				   REP   MOVSB
				   MOV   EDI,OFFSET  HEXNAME
				   ADD   EDI,[SRCNAME_LENGTH]
				   SUB   EDI,3
				   MOV   [EDI],'H'
				   INC   EDI
				   MOV   [EDI],'E'
				   INC   EDI
				   MOV   [EDI],'X'
				   
				
				   ;SET LST FILE NAME
				   MOV   ESI,OFFSET SRCNAME
				   MOV   ECX,[SRCNAME_LENGTH];LENGTH
				   MOV   EDI,OFFSET LSTNAME ;DESTINATION
				   CLD
				   REP   MOVSB
				   MOV   EDI,OFFSET LSTNAME
				   ADD   EDI,[SRCNAME_LENGTH]
				   SUB   EDI,3
				   MOV   [EDI],'L'
				   INC   EDI
				   MOV   [EDI],'S'
				   INC   EDI
				   MOV   [EDI],'T'
				   
				   ;CREATE OUTPUT FILES
				   MOV   EDX,OFFSET HEXNAME
				   CALL  CREATE_FILE
				   MOV   [HEXFILE],EAX
				
				   MOV   EDX,OFFSET LSTNAME
				   CALL  CREATE_FILE
				   MOV   [LSTFILE],EAX
				;------------------------------------------------------------------------------
				;Initialize for first pass
				   XOR   EAX,EAX
				
				   MOV   DWORD PTR[BUFPT],OFFSET SRCBUF ;Initialize buffer pointer
				   MOV   DWORD PTR[CODE],OFFSET CODE_START+1 ;POINTER TO NEXT BYTE OF INTERMEDIATE CODE
				   MOV   DWORD PTR[IY],OFFSET CODE_START  ;POINTER TO CURRENT RELOCATION BYTE
				
				   XOR   EAX,EAX
				   MOV   [PC],EAX     ;DEFAULT PROGRAM COUNTER
				   MOV   [BASE],EAX   ;POINTER TO ROOT OF ID TREE=NIL
				   MOV   [RETPT],EAX  ;Pointer to last RET record
				   MOV   [IFFLG],AL  ;NOT WITHIN IF/ENDIF
				   MOV   [CHKLAB],AL ;LOOKUP ALL LABELS
				   DEC   EAX
				   MOV   [LSTRET],EAX ;Location of last RET
				   MOV   EAX,HEAP_START
				   MOV   [_HEAP],EAX  ;BACK END OF SYMBOL TABLE SPACE
				   MOV   DWORD PTR[BCOUNT],4  ;CODE BYTES PER RELOCATION BYTE
				   MOV   ECX,BUFSIZ
				   XOR   EAX,EAX
				   DEC   EAX
				;Assemble each line of code
				;------------------------------------------------------------------------------
				
				_LOOP:
				   CALL NEXTCHR
				   CMP AL,1AH      ;EOF
				   JZ ENDJ           ;FOUND EOF GOTO NEXT PASS
				   MOV   AL,-1    ;Flag that no tokens have been read yet
				   MOV   [SYM],AL
				   CALL  ASMLIN      ;Assemble the line
				   MOV   AL,[SYM]
				   CMP   AL,-1    ;Any tokens found on line?
				   JNZ   L0002
				   CALL  GETSYM      ;If no tokens read yet, read first one
				L0002:   
				   CMP   AL,';'
				   JZ ENDLN
				   CMP   AL,EOL      ;\r=13, \n=10
				   JZ ENDLN
				   CMP   AL,14H      ;Garbage at end of line error
				   JMP ENDLIN
				ENDJ: 
				   JMP   _END
				ENDLN:
				   XOR   AL,AL    ;Flag no errors on line
				ENDLIN:
				;AL = error code for line. Stack depth unknown
				   MOV ESP,[STACK_]
				   CALL  NEXLIN
				   JMP _LOOP
				
				NEXLIN:
				   MOV   CH,0C0H     ;Put end of line marker and error code (AL)
				   CALL  PUTCD
				   CALL  GEN1
				   MOV   AL,[CHR]
				GETEOL:
				   CMP   AL,10       ;CHR=\r
				   JZ NEXLIN_RET
				   CMP AL,1AH
				   JZ ENDJ
				   CALL  NEXTCHR     ;Scan over comments for linefeed
				   JMP GETEOL
				NEXLIN_RET:
				   RET
				
				ABORT:
				   MOV   EBX,OFFSET NOMEM
				PRERR:
				   PUSH  EBX
				   ;ERROR PRINT HERE ONLY
				   CALL  _cprintf
				   POP   EBX
				QUIT:
				   XOR   EAX,EAX
				   RET
				
				CREATE_FILE:
				   PUSH   OFFSET WRITE_FLAG
				   PUSH   EDX
				   CALL  _fopen
				   ADD   ESP,8
				
				   OR     EAX,EAX
				   JNZ   MAKFIL_RET
				   NOP
				   MOV   EBX,OFFSET NOSPAC
				   JMP   PRERR
				MAKFIL_RET:
				   RET
				
				ERROR:
				   MOV   AL,CL
				   JMP   ENDLIN
				
				
				NEXTCHR: ;DONE
				   MOV   ESI,[BUFPT]
				   CMP   ESI,OFFSET SRCBUF
				   JNZ   GETCH
				;Buffer empty so refill it
				   PUSH  EDX
				   PUSH  EAX    ;AH must be saved
				
				   PUSH  [SRCFILE]
				   PUSH  BUFSIZ
				   PUSH  1
				   PUSH  ESI
				   CALL _fread
				   ADD   ESP,16
				   OR    EAX,EAX
				   ;COUNT ALL READ BYTES
				   ;
				   MOV   DWORD PTR[LAST_READ_CHAR_COUNT],EAX
				   ADD   DWORD PTR[TOTAL_READ_CHAR_COUNT],EAX
				   ;BUF COUNT++
				   INC   DWORD PTR[SRCBUF_COUNT]
				
				   XCHG  EAX,EDX    ;Put error code in DL
				   POP   EAX    ;Restore AH
				   ;MOV   AL,DL    ;Error code back in AL
				   POP   EDX
				
				GETCH:
				;EAX=PTR 
				   LODSB
				   ;P=(SRCBUF_COUNT*BUFSIZ)+(ESI-SRCBUF)
				   PUSH ECX
				   MOV ECX,[SRCBUF_COUNT]
				   DEC ECX
				   PUSH EAX
				   MOV EAX,BUFSIZ
				   MUL ECX
				   XCHG ECX,EAX
				   POP EAX
				   ADD ECX,ESI
				   SUB ECX,OFFSET SRCBUF
				   MOV [CHAR_LOCATION],ECX
				   CMP ECX,[SRCLENGTH]
				   POP ECX
				   JNZ    SKIP_FOUND_END
				   
				   ;USE 0 to replace 1A (even it it 1A)
				   MOV [BUFPT],ESI
				   MOV AL,1AH      ;Possibly signal End of File
				   MOV   [CHR],AL
				   RET
				
				SKIP_FOUND_END:
				   CMP   AL,13
				   JNZ	 SKIP_LINE_END
				   LODSB ;10
				   INC   DWORD PTR [LINE_COUNT]
				SKIP_LINE_END:
				   CMP   ESI,OFFSET SRCBUF+BUFSIZ
				   JNZ   NOMOD
				   MOV   ESI,OFFSET SRCBUF
				NOMOD:
				   MOV   [BUFPT],ESI
				   OR AL,AL
				   JNZ SKIP_NOMOD
				   MOV ESI,OFFSET SRCBUF
				   MOV [BUFPT],ESI
				   JMP NEXTCHR
				SKIP_NOMOD:
				
				   MOV   [CHR],AL
				   RET
				
				MROPS:
				
				; Get two operands and check for certain types, according to flag byte
				; in CL. OP code in CH. Returns only if immediate operation.
				
				   PUSH  ECX    ;Save type flags
				   CALL  GETOP
				   PUSH  EDX    ;Save first operand
				   CALL  GETOP2
				   POP   EBX    ;First op in EBX, second op in EDX
				   MOV   AL,SREG     ;Check for a segment register
				   CMP   AL,BH
				   JZ SEGCHK
				   CMP   AL,DH
				   JZ SEGCHK
				   MOV   AL,CONST ;Check if the first operand is immediate
				   MOV   CL,26
				   CMP   AL,BH
				   JZ ERROR    ;Error if so
				   POP   ECX    ;Restore type flags
				   CMP   AL,DH    ;If second operand is immediate, then done
				   JZ MAKFIL_RET
				   MOV   AL,UNDEFID  ;Check for memory reference
				   CMP   AL,BH
				   JZ _STORE      ;Is destination memory?
				   CMP   AL,DH
				   JZ _LOAD    ;Is source memory?
				   TEST  CL,1     ;Check if register-to-register operation OK
				   MOV   CL,27
				   JZ ERROR
				   MOV   AL,DH
				   CMP   AL,BH    ;Registers must be of same length
				RR:
				   MOV   CL,22
				   JNZ   ERROR
				RR1:
				   AND   AL,1     ;Get register length (1=16 bits)
				   OR AL,CH    ;Or in to OP code
				   CALL  PUT      ;And write it
				   POP   ECX    ;Dump return address
				   MOV   AL,BL
				   ADD   AL,AL    ;Rotate register number into middle position
				   ADD   AL,AL
				   ADD   AL,AL
				   OR AL,0C0H     ;Set register-to-register mode
				   OR AL,DL    ;Combine with other register number
				   JMP   PUT
				
				SEGCHK:
				;Come here if at least one operand is a segment register
				   POP   ECX    ;Restore flags
				   TEST  CL,8     ;Check if segment register OK
				   MOV   CL,22
				   JZ ERR1
				   MOV   ECX,8E03H ;Segment register move OP code
				   MOV   AL,UNDEFID
				   CMP   AL,DH    ;Check if source is memory
				   JZ _LOAD
				   CMP   AL,BH    ;Check if destination is memory
				   JZ _STORE
				   MOV   AL,XREG
				   SUB   AL,DH    ;Check if source is 16-bit register
				   JZ RR    ;If so, AL must be zero
				   MOV   CH,8CH      ;Change direction
				   XCHG  EDX,EBX    ;Flip which operand is first and second
				   MOV   AL,XREG
				   SUB   AL,DH    ;Let RR perform finish the test
				   JMP RR
				
				_STORE:
				   TEST  CL,004H     ;Check if storing is OK
				   JNZ   STERR
				   XCHG  EDX,EBX    ;If so, flip operands
				   AND   CH,0FDH     ;   and zero direction bit
				_LOAD:
				   MOV   DH,25
				   CMP   AL,BH    ;Check if memory-to-memory
				   JZ MRERR
				   MOV   AL,BH
				   CMP   AL,REG      ;Check if 8-bit operation
				   JNZ   XRG
				   MOV   DH,22
				   TEST  CL,1     ;See if 8-bit operation is OK
				   JZ MRERR
				XRG:
				   MOV   AL,DL
				   SUB   AL,6     ;Check for R/M mode 6 and register 0
				   OR AL,BL    ;   meaning direct load/store of accumulator
				   JNZ   NOTAC
				   TEST  CL,8     ;See if direct load/store of accumulator
				   JZ NOTAC    ;   means anything in this case
				; Process direct load/store of accumulator
				   MOV   AL,CH
				   AND   AL,2     ;Preserve direction bit only
				   XOR   AL,2     ;   but flip it
				   OR AL,0A0H     ;Combine with OP code
				   MOV   CH,AL
				   MOV   AL,BH    ;Check byte/word operation
				   AND   AL,1
				   OR AL,CH
				   POP   ECX    ;Dump return address
				   JMP   PUTADD      ;Write the address
				
				NOTAC:
				   MOV   AL,BH
				   AND   AL,1     ;Get byte/word bit
				   AND   AL,CL    ;But don't use it in word-only operations
				   OR AL,CH    ;Combine with OP code
				   CALL  PUT
				   MOV   AL,BL
				   ADD   AL,AL    ;Rotate to middle position
				   ADD   AL,AL
				   ADD   AL,AL
				   OR AL,DL    ;Combine register field
				   POP   ECX    ;Dump return address
				   JMP   PUTADD      ;Write the address
				
				STERR:
				   MOV   DH,29
				MRERR:
				   MOV   CL,DH
				
				ERR1: JMP   ERROR
				
				
				GETOP2:
				;Get the second operand: look for a comma and drop into GETOP
				   MOV   AL,[SYM]
				   CMP   AL,','
				   MOV   CL,21
				   JNZ   ERR1
				
				
				GETOP:
				
				; Get one operand. Operand may be a memory reference in brackets, a register,
				; or a constant. If a flag (such as "B" for byte operation) is encountered,
				; it is noted and processing continues to find the operand.
				;
				; On exit, AL (=DH) has the type of operand. Other information depends
				; on the actual operand:
				;
				; AL=DH=0  Memory Reference.  DL has the address mode properly prepared in
				; the 8086 R/M format (middle bits zero). The constant part of the address
				; is in _ADDR. If an undefined label needs to be added to this, a pointer to
				; its information fields is in ALABEL, otherwise ALABEL is zero.
				;
				; AL=DH=1  Value. The constant part is in DATA. If an undefined label needs
				; to be added to this, a pointer to its information fields is in DLABEL,
				; otherwise DLABEL is zero. "$" and "RET" are in this class.
				;
				; AL=DH=2  8-bit Register. DL has the register number.
				;
				; AL=DH=3  16-bit Register. DL has the register number.
				;
				; AL=DH=4  Segment Register. DL has the register number.
				
				   CALL  GETSYM
				
				GETOP1:
				;Enter here if we don't need a GETSYM first
				   CMP   AL,'['      ;Memory reference?
				   JZ MEM
				   CMP   AL,5     ;Flag ("B", "W", etc.)?
				   JZ FLG
				   CMP   AL,REG      ;8-Bit register?
				   JZ NREG
				   CMP   AL,XREG     ;16-Bit register?
				   JZ NREG
				   CMP   AL,SREG     ;Segment register?
				   JZ NREG
				VAL:           ;Must be immediate
				   XOR   AL,AL    ;No addressing modes allowed
				VAL1:
				   CALL  GETVAL
				   MOV   EAX,[CON] ;Defined part
				   MOV   [_DATA],EAX
				   MOV   EAX,[UNDEF]  ;Undefined part
				   MOV   DWORD PTR[DLABEL],EAX
				   MOV   DL,CH
				   MOV   DH,CONST
				   MOV   AL,DH
				   RET
				NREG:
				   PUSH  EDX
				   CALL  GETSYM
				   POP   EDX
				   MOV   AL,DH
				   RET
				MEM:
				   CALL  GETSYM
				   MOV   AL,1
				   CALL  GETVAL
				   MOV   AL,[SYM]
				   CMP   AL,']'
				   MOV   CL,24
				   JNZ   ERR1
				   CALL  GETSYM
				   MOV   EBX,[CON]
				   MOV   [_ADDR],EBX
				   MOV   EBX,[UNDEF]
				   MOV   [ALABEL],EBX
				   MOV   DL,CH
				   MOV   DH,UNDEFID
				   MOV   AL,DH
				   RET
				FLG:
				   CMP   DL,[MAXFLG] ;Invalid flag for this operation?
				   MOV   CL,27H
				   JG ERR1
				   CALL  GETSYM
				   CMP   AL,','
				   JZ GETOP
				   JMP GETOP1
				
				
				GETVAL:
				
				; Expression analyzer. On entry, if AL=0 then do not allow base or index
				; registers. If AL=1, we are analyzing a memory reference, so allow base
				; and index registers, and compute addressing mode when done. The constant
				; part of the expression will be found in CON. If an undefined label is to
				; be added to this, a pointer to its information fields will be found in
				; UNDEF.
				
				   MOV   AH,AL    ;Flag is kept in AH
				   MOV   DWORD PTR[UNDEF],0
				   MOV   AL,[SYM]
				   CALL  EXPRESSION
				   MOV   [CON],EDX
				   MOV   AL,AH
				   MOV   CH,0     ;Initial mode
				   TEST  AL,10H      ;Test INDEX bit
				   RCL   AL,1     ;BASE bit (zero flag not affected)
				   JZ NOIND    ;Jump if not indexed, with BASE bit in carry
				   CMC
				   RCL   CH,1     ;Rotate in BASE bit
				   RCL   AL,1     ;EBP bit
				   RCL   CH,1
				   RCL   AL,1     ;EDI bit
				   RCL   CH,1     ;The low 3 bits now have indexing mode
				MODE:
				   OR CH,080H     ;If undefined label, force 16-bit displacement
				   TEST  DWORD PTR[UNDEF],-1
				   JNZ   MODE_RET
				   MOV   EBX,[CON]
				   MOV   AL,BL
				   CBW         ;Extend sign
				   CMP   EAX,EBX    ;Is it a signed 8-bit number?
				   JNZ   MODE_RET    ;If not, use 16-bit displacement
				   AND   CH,07FH     ;Reset 16-bit displacement
				   OR CH,040H     ;Set 8-bit displacement
				   OR EBX,EBX
				   JNZ   MODE_RET    ;Use it if not zero displacement
				   AND   CH,7     ;Specify no displacement
				   CMP   CH,6     ;Check for EBP+0 addressing mode
				   JNZ   MODE_RET
				   OR CH,040H     ;If EBP+0, use 8-bit displacement
				MODE_RET:
				   RET
				
				NOIND:
				   MOV   CH,6     ;Try direct address mode
				   JNC   MODE_RET    ;If no base register, that's right
				   RCL   AL,1     ;Check EBP bit
				   JC MODE
				   INC   CH    ;If not, must be EBX
				   JMP MODE
				
				
				EXPRESSION:
				;Analyze arbitrary expression. Flag byte in AH.
				;On exit, AL has type byte: 0=register or undefined label
				   MOV   CH,-1    ;Initial type
				   MOV   EDI,EDX
				   XOR   EDX,EDX    ;Initial value
				   CMP   AL,'+'
				   JZ PLSMNS
				   CMP   AL,'-'
				   JZ PLSMNS
				   MOV   CL,'+'
				   PUSH  EDX
				   PUSH  ECX
				   MOV   EDX,EDI
				   JMP OPERATE
				PLSMNS:
				   MOV   CL,AL
				   PUSH  EDX
				   PUSH  ECX
				   OR AH,4     ;Flag that a sign was found
				   CALL  GETSYM
				OPERATE:
				   CALL  TERM
				   POP   ECX    ;Recover operator
				   POP   EBX    ;Recover current value
				   XCHG  EDX,EBX
				   AND   CH,AL
				   OR AL,AL    ;Is it register or undefined label?
				   JZ NOCON    ;If so, then no constant part
				   CMP   CL,"-"      ;Subtract it?
				   JNZ   _ADD
				   NEG   EBX
				_ADD:
				   ADD   EDX,EBX
				NEXTERM:
				   MOV   AL,[SYM]
				   CMP   AL,'+'
				   JZ PLSMNS
				   CMP   AL,'-'
				   JZ PLSMNS
				   MOV   AL,CH
				   RET
				NOCON:
				   CMP   CL,"-"
				   JNZ   NEXTERM
				BADOP:
				   MOV   CL,5
				   JMP   ERROR
				
				TERM:
				   CALL  FACTOR
				MULOP:
				   PUSH  EDX    ;Save value
				   PUSH  EAX    ;Save type
				   CALL  GETSYM
				   POP   ECX
				   CMP   AL,"*"
				   JZ GETFACT
				   CMP   AL,"/"
				   JNZ   ENDTERM
				GETFACT:
				   OR CL,CL    ;Can we operate on this type?
				   JZ BADOP
				   PUSH  EAX    ;Save operator
				   CALL  GETSYM      ;Get past operator
				   CALL  FACTOR
				   OR AL,AL
				   JZ BADOP
				   POP   ECX    ;Recover operator
				   POP   EBP    ;And current value
				   XCHG  EAX,EBP    ;Save AH in EBP
				   CMP   CL,"/"      ;Do we divide?
				   JNZ   DOMUL
				   OR EDX,EDX    ;Dividing by zero?
				   MOV   CL,29H
				   JZ ERR2
				   MOV   EBX,EDX
				   XOR   EDX,EDX    ;Make 32-bit dividend
				   DIV   EBX
				   JMP   NEXFACT
				DOMUL:
				   MUL   EDX
				NEXFACT:
				   MOV   EDX,EAX    ;Result in EDX
				   XCHG  EAX,EBP    ;Restore flags to AH
				   MOV   AL,-1    ;Indicate a number
				   JMP   MULOP
				ENDTERM:
				   POP   EDX
				   MOV   AL,CL
				ENDTERM_RET:
				   RET
				FACTOR:
				   MOV   AL,[SYM]
				   CMP   AL,CONST
				   JZ ENDTERM_RET
				   CMP   AL,UNDEFID
				   JZ UVAL
				   CMP   AL,"("
				   JZ PAREN
				   CMP   AL,'"'
				   JZ STRING
				   CMP   AL,"'"
				   JZ STRING
				   CMP   AL,XREG     ;Only 16-bit register may index
				   MOV   CL,20
				   JNZ   ERR2
				   TEST  AH,1     ;Check to see if indexing is OK
				   MOV   CL,1
				   JZ ERR2
				   MOV   AL,DL
				   MOV   CL,3
				   SUB   AL,3     ;Check for EBX
				   JZ BXJ
				   SUB   AL,2     ;Check for EBP
				   JZ BPJ
				   DEC   AL    ;Check for ESI
				   MOV   CL,4
				   JZ SIJ
				   DEC   AL    ;Check for EDI
				   JZ DIJ
				   MOV   CL,2     ;Invalid base/index register
				ERR2: JMP   ERROR
				
				DIJ:
				   OR AH,20H      ;Flag seeing index register EDI
				SIJ:
				   TEST  AH,10H      ;Check if already seen index register
				   JNZ   ERR2
				   OR AH,10H      ;Flag seeing index register
				   RET
				
				BPJ:
				   OR AH,40H      ;Flag seeing base register EBP
				BXJ:
				   TEST  AH,80H      ;Check if already seen base register
				   JNZ   ERR2
				   OR AH,80H      ;Flag seeing base register
				   RET
				
				PAREN:
				   CALL  GETSYM      ;Eat the "("
				   CALL  EXPRESSION
				   CMP   BYTE PTR[SYM],")"  ;Better have closing paren
				   MOV   CL,20
				   JNZ   ERR30
				   RET
				UVAL:
				   MOV   CL,6
				   TEST  AH,8     ;Check if undefined label has been seen
				   JNZ   ERR30
				   OR AH,8     ;Flag seeing undefined label
				   MOV   [UNDEF],EBX
				   RET
				
				ERR30:   JMP   ERROR
				STRING:
				   MOV   CH,AL
				   MOV   AL,[CHR]
				   CMP   AL,CH
				   MOV   CL,35
				   MOV   DL,AL
				   MOV   DH,0
				   JNZ   L0003
				   CALL  ZERLEN
				L0003:
				   CALL  GETCHR
				   MOV   CL,37
				   TEST  AH,2
				   JZ ERR30
				   TEST  AH,4
				   MOV   CL,38
				   JNZ   ERR30
				STRGDAT:
				   MOV   AL,DL
				   CMP   AL,EOL
				   MOV   CL,39
				   JZ ERR30
				   CALL  PUT
				   MOV   AL,[DATSIZ]
				   OR AL,AL
				   JNZ   BYTSIZ
				   MOV   AL,DH
				   CALL  PUT
				BYTSIZ:
				   MOV   AL,[CHR]
				   MOV   DL,AL
				   CALL  GETCHR
				   JMP STRGDAT
				
				ZERLEN:
				   CALL  NEXTCHR
				   CMP   AL,CH
				   JNZ   ERR30
				   RET
				GETCHR:
				   CALL  NEXTCHR
				   CMP   AL,CH
				   JNZ   GETCHR_RET
				   CALL  NEXTCHR
				   CMP   AL,CH
				   JZ GETCHR_RET
				   POP   EBX    ;Kill return address to STRGDAT loop
				   MOV   AL,-1    ;Flag type as constant
				GETCHR_RET:
				   RET
				
				GETSYM:
				
				; The lexical scanner. Used only in the operand field. Returns with the token
				; in SYM and AL, sometimes with additional info in EBX or EDX.
				;
				; AL=SYM=0  Undefined label. EBX has pointer to information fields.
				;
				; AL=SYM=1  Constant (or defined label). EDX has value.
				;
				; AL=SYM=2,3,4  8-bit register, 16-bit register, or segment register,
				; respectively. DL has register number.
				;
				; AL=SYM=5  A mode flag (such as "B" for byte operation). Type of flag in DL
				; and also stored in FLAG: -1=no flags, 0=B, 1=W, 2=S, 3=L, 4=T.
				;
				; AL=SYM=6  8087 floating point register, ST(n) or ST. DL has register number.
				;
				; All other values are the ASCII code of the character. Note that this may
				; never be a letter or number.
				
				   PUSH  EAX    ;Save AH
				   CALL  GETSY
				   POP   EAX
				   MOV   AL,[SYM]
				GETSYM_RET:
				   RET
				
				SCANB: ;DONE
				   MOV   AL,[CHR]
				SCANT:
				   CMP   AL,' '
				   JZ NEXB
				   CMP   AL,9   ;\t
				   JNZ   SCANB_RET
				NEXB:
				   CALL  NEXTCHR
				   JMP SCANT
				SCANB_RET:
				   RET
				
				DOLLAR:
				   MOV   EDX,[OLDPC]
				   MOV   AL,CONST
				   MOV   [SYM],AL
				NEXTCHJ:
				   JMP   NEXTCHR
				
				GETSY:
				   CALL  SCANB
				   CMP   AL,'$'
				   JZ DOLLAR
				   MOV   [SYM],AL
				   OR AL,20H
				   CMP   AL,'z'+1
				   JNC   NEXTCHJ
				   CMP   AL,'a'
				   JC GETSY_SKIP
				   JMP   LETTER
				GETSY_SKIP:
				   CMP   AL,'9'+1
				   JNC   NEXTCHJ
				   CMP   AL,'0'
				   JC NEXTCHJ
				   MOV   EBX,OFFSET SYM
				   MOV   BYTE PTR[EBX],CONST
				   CALL  READID
				   DEC   EBX
				   MOV   AL,[EBX]
				   MOV   CL,7
				   MOV   EBX,0
				   CMP   AL,'h'
				   JNZ   GETSY_SKIP2
				   JMP   HEX
				GETSY_SKIP2:
				   INC   CL
				   MOV   DWORD PTR[IX],OFFSET  ID
				_DEC:
				   MOV   ESI,[IX]
				   MOV   AL,[ESI]
				   INC   DWORD PTR[IX]
				   CMP   AL,'9'+1
				   JC _DEC_SKIP
				   JMP   ERROR
				_DEC_SKIP:
				   SUB   AL,'0'
				   MOV   EDX,EBX
				   SHL   EBX,1
				   SHL   EBX,1
				   ADD   EBX,EDX
				   SHL   EBX,1
				   MOV   DL,AL
				   MOV   DH,0
				   ADD   EBX,EDX
				   DEC   CH
				   JNZ   _DEC
				   XCHG  EDX,EBX
				   RET
				
				HEX:
				   MOV   EDX,OFFSET ID
				   DEC   CH
				HEX1:
				   MOV   ESI,EDX
				   LODSB
				   INC   EDX
				   SUB   AL,'0'
				   CMP   AL,10
				   JC GOTIT
				   CMP   AL,'g'-'0'
				   JNC   ERR4
				   SUB   AL,'a'-10-'0'
				GOTIT:
				   SHL   EBX,1
				   SHL   EBX,1
				   SHL   EBX,1
				   SHL   EBX,1
				   ADD   BL,AL
				   DEC   CH
				   JNZ   HEX1
				   XCHG  EDX,EBX
				   RET
				
				ERR4: JMP   ERROR
				
				GETLET: ;SAVE LABEL AND RETURN ':'
				   CALL  SCANB
				   CMP   AL,EOL
				   STC
				   JZ GETLET_RET
				   CMP   AL,';'
				   STC
				   JZ GETLET_RET
				   MOV   CL,10
				   OR AL,20H
				   CMP   AL,'a'
				   JC ERR4
				   CMP   AL,'z'+1
				   JNC   ERR4
				READID:
				   MOV   EBX,OFFSET ID
				   MOV   CH,0
				MOREID: ;READ LABEL CHARS
				   MOV   [EBX],AL
				   INC   CH
				   INC   EBX
				   CALL  NEXTCHR
				   CMP   AL,'0'
				   JC NOMORE
				   OR AL,20H
				   CMP   AL,'z'+1
				   JNC   NOMORE
				   CMP   AL,'9'+1
				   JC MOREID
				   CMP   AL,'a'
				   JNC   MOREID
				NOMORE:
				   MOV   CL,AL
				   MOV   AL,CH
				   MOV   BYTE PTR[LENID],AL
				   OR AL,AL
				   MOV   AL,CL
				GETLET_RET:
				   RET
				
				LETTER:
				   CALL  READID
				   MOV   AL,CH
				   DEC   AL
				   JNZ   NOFLG
				   MOV   AL,[ID]
				   MOV   ECX,5
				   MOV   EDI,FLGTAB
				   CLD
				   REPNE SCASB       ;See if one of B,W,S,L,T
				   JZ SAVFLG      ;Go save flag
				   XOR   AL,AL
				   MOV   CH,BYTE PTR[LENID]
				NOFLG:
				   DEC   AL
				   PUSH  EBX
				   JNZ   L0004
				   CALL  REGCHK
				L0004:   
				   POP   EBX
				   MOV   AL,DH
				   JZ SYMSAV
				   CALL  LOOKRET
				SYMSAV:
				   MOV   [SYM],AL
				   RET
				
				SAVFLG:
				   MOV   DL,CL    ;Need flag type in DL
				   XCHG  [FLAG],CL
				   CMP   CL,-1
				   MOV   CL,32
				   MOV   AL,5
				   JZ SYMSAV
				ERRJ3:   JMP   ERROR
				
				FLGTAB:  DB "tlswb"
				
				FPREG:
				;Have detected "ST" for 8087 floating point stack register
				   MOV   DL,0     ;Default is ST(0)
				   CALL  SCANB    ;Get next character
				   CMP   AL,"("      ;Specifying register number?
				   JNZ   HAVREG
				;Get register number
				   CALL  NEXTCHR     ;Skip over the "("
				   CALL  GETOP    ;A little recursion never hurt anybody
				   CMP   AL,CONST ;Better have found a constant
				   MOV   CL,20    ;Operand error if not
				   JNZ   ERRJ3
				   CMP   DWORD PTR[DLABEL],0  ;Constant must be defined
				   MOV   CL,30
				   JNZ   ERRJ3
				   MOV   EDX,[_DATA]  ;Get constant
				   CMP   EDX,7     ;Constant must be in range 0-7
				   MOV   CL,31
				   JA ERRJ3
				   MOV   AL,[SYM]
				   CMP   AL,")"
				   MOV   CL,24
				   JNZ   ERRJ3
				HAVREG:
				   MOV   DH,FREG
				   XOR   AL,AL    ;Zero set means register found
				   RET
				
				REGCHK:
				   MOV   EBX,OFFSET ID
				   CMP   DWORD PTR[EBX],"s"+7400H   ;"st"
				   JZ FPREG
				   MOV   CL,[EBX]
				   INC   EBX
				   MOV   AL,[EBX]
				   MOV   EBX,OFFSET REGTAB
				   MOV   DH,XREG
				   MOV   DL,0
				   CMP   AL,'x'
				   JZ SCANREG
				   MOV   DH,REG
				   CMP   AL,'l'
				   JZ SCANREG
				   MOV   DL,4
				   CMP   AL,'h'
				   JZ SCANREG
				   MOV   DH,SREG
				   MOV   DL,0
				   MOV   EBX,OFFSET SEGTAB
				   CMP   AL,'s'
				   JZ SCANREG
				   MOV   DH,XREG
				   CMP   AL,'p'
				   JZ PREG
				   CMP   AL,'i'
				   JNZ   SCANREG_RET
				   MOV   DL,6
				   MOV   AL,CL
				   CMP   AL,'s'
				   JZ SCANREG_RET
				   INC   DL
				   CMP   AL,'d'
				   RET
				PREG:
				   MOV   DL,4
				   MOV   AL,CL
				   CMP   AL,'s'
				   JZ SCANREG_RET
				   INC   DL
				   CMP   AL,'b'
				   RET
				SCANREG:
				   MOV   AL,CL
				   MOV   ECX,4
				   CLD
				   MOV   EDI,EBX
				   REPNZ   SCASB
				   MOV   EBX,EDI
				   JNZ   SCANREG_RET
				   MOV   AL,CL
				   ADD   AL,DL
				   MOV   DL,AL
				   XOR   AL,AL
				SCANREG_RET:
				   RET
				;-----------------------------------------------
				LOOK:	;EBX:base of nodes
				   MOV   CH,[EBX]
				   INC   EBX
				   INC   EBX
				   INC   EBX
				   INC   EBX
				   MOV   EDX,OFFSET ID
				   CALL  CPSLP
				   JZ SCANREG_RET
				   XOR   AL,80H
				   ROL   AL,1     ;Make end-of-symbol bit least significant
				   MOV   CL,AL
				   DEC   EBX
				   MOV   AL,[EBX] ;EBX: Start of ID in nodes
				   XOR   AL,80H
				   ROL   AL,1
				   CMP   AL,CL
				
				   ADD   EBX,NODESIZE
				   JNC   SMALL
				   ADD  EBX,4 ;Skip Left Link
				SMALL:
				   MOV   EDX,[EBX]	;EBX points to LEFT_LINK or RIGHT LINK
				   INC   EBX
				   INC	 EBX
				   INC   EBX
				   INC	 EBX
				   MOV   AL,DL
				   OR    AL,DH ;OR DH,DL
				   STC
				   JZ ALLRET_RET
				   XCHG  EDX,EBX
				   JMP LOOK
				
				LOOKRET:
				   MOV   AL,CH
				   CMP   AL,3  ;RET has 3 letters
				   JNZ   LOOKUP
				   DEC   EBX    ;EBX left link, EBX-1 last char of "RET"
				   OR	 BYTE PTR[EBX],080H
				   MOV   EDX,OFFSET RETSTR+2
				CHKRET:
				   MOV   ESI,EDX
				   LODSB
				   CMP   AL,[EBX]
				   JNZ   LOOKIT
				   DEC   EBX
				   DEC   EDX
				   DEC   CH
				   JNZ   CHKRET
				   MOV   EDX,[LSTRET]
				   MOV   AL,DL
				   AND   AL,DH
				   INC   AL
				   JZ ALLRET
				   MOV   EBX,[PC]
				   SUB   EBX,EDX
				   MOV   AL,BL
				   CBW
				   CMP   EAX,EBX    ;Signed 8-bit number?
				   MOV   AL,1
				   JZ ALLRET_RET
				ALLRET:
				   MOV   EBX,[RETPT]
				   MOV   AL,BH
				   OR AL,BL
				   MOV   AL,0
				   JNZ   ALLRET_RET
				   MOV   EBX,[_HEAP]
				   DEC   EBX
				   DEC   EBX
				   DEC   EBX
				   MOV   [_HEAP],EBX
				   XOR   AL,AL
				   MOV   [EBX],AL
				   MOV   [RETPT],EBX
				ALLRET_RET:
				   RET
				
				LOOKUP: ;EBX:Left link, EBX-1:Last char of Identifier
				   DEC   EBX
				   OR BYTE PTR[EBX],080H	;SET LAST CHAR WITH 0x80
				LOOKIT:
				   MOV   EBX,[BASE]
				   MOV   AL,BH
				   OR AL,BL
				   JZ EMPTY
				   CALL  LOOK
				   JC _ENTER
				   MOV   EDX,4
				   ADD   EBX,EDX
				   MOV   AL,[EBX]
				   OR AL,AL
				   JZ LOOKIT_RET
				   INC   EBX
				   MOV   EDX,[EBX]
				   INC   EBX
				LOOKIT_RET:
				   RET
				
				_ENTER:
				   PUSH  EBX    ;Save pointer to link field
				   CALL  CREATE      ;Add the node
				   POP   ESI
				   MOV   [ESI-80],EDX   ;Link new node
				   RET         ;Zero was set by CREATE
				
				EMPTY:
				   CALL  CREATE
				   MOV   [BASE],EDX ;Save node start to BASE
				   RET
				
				
				CREATE:
				
				; Add a new node to the identifier tree. The identifier is at ID with
				; bit 7 of the last character set to one. The length of the identifier is
				; in LENID, which is ID-4
				;
				; Node format:
				;  4+84+4+4+4+4 =104 ->USE 128
				;  1. Length of identifier (4 byte) :
				;  2. Identifier (1-80 bytes) :EXTEND TO 1-84, total 84
				;  3. Left link (4-byte pointer to alphabetically smaller identifiers) :4
				;  4. Right link (4-byte pointer 0 if none larger) :4
				;  5. Data field:
				;     a. Defined flag (0=undefined, 1=defined) (1 byte) :4
				;     b. Value (4 bytes) :4
				;
				; This routine returns with AL=zero and zero flag set (which indicates
				; on return from LOOKUP that it has not yet been defined), EDX points
				; to start of new node, and EBX points to data field of new node.
				
				   ;Storage needed for the node ;8 + 6 + 2
				   MOV   EBX,[_HEAP]
				   XOR   EDX,EDX
				   SUB   EBX,NODESIZE    ;Heap grows downward -128
				   MOV   [_HEAP],EBX
				   XCHG  EDX,EBX
				   MOV   EBX,[CODE]   ;Check to make sure there's enough
				   ;db 0cch
				   CMP   EBX,EDX		;OUT OF MEMORY
				   JB SKIP_ABORT
				   JMP   ABORT
				SKIP_ABORT:
				   PUSH  EDX	;EDX: START POS OF NODE
				   MOV   EBX,LENID ;EBX: LENID + ID
				   XOR   ECX,ECX
				   ;MOV   CL,[EBX] ;EBX:ID,CL=id length
				   MOV   ECX,4+80
				   CLD 
				   MOV   ESI,EBX
				   MOV   EDI,EDX
				   REP   MOVSB       ;Move identifier and length into node
				   
				   MOV   EBX,EDI
				   MOV   EDX,ESI
				   XOR   EAX,EAX
				   STOSD ;LEFT LINK
				   STOSD ;RIGHT LINK
				   STOSD ;ZERO FLAG
				   STOSD ;VALUE
				   POP   EDX    ;Restore pointer to node start
				   RET
				
				CPSLP: ;COMPARE EDX: EBX (CH=LENGTH)
				   MOV   ESI,EDX
				   LODSB
				   CMP   AL,[EBX]
				   LAHF
				   INC   EDX
				   INC   EBX
				   SAHF
				   JNZ   CPSLP_RET
				   DEC   CH
				   JNZ   CPSLP
				CPSLP_RET:
				   RET
				
				GETLAB:
				   MOV   EBX,0
				   MOV   [LABPT],EBX
				   MOV   BYTE PTR[FLAG],-1
				   MOV   DH,0
				   MOV   AL,[CHR]
				   CMP   AL,' '+1
				   JC NOT1
				   OR DH,001H
				NOT1:
				   CALL  GETLET
				   JC CPSLP_RET
				   CMP   AL,':'
				   JNZ   LABCHK
				   CALL  NEXTCHR
				   JMP _LABEL
				LABCHK:
				   OR AL,AL
				   TEST  DH,001H
				   JZ CPSLP_RET
				_LABEL:
				   MOV   AL,[CHKLAB]
				   OR AL,AL
				   JZ _LABEL_SKIP
				   JMP   GETLET
				_LABEL_SKIP:
				   CALL  LOOKUP ;EBX:Left link,EDX:Last top
				   MOV   CL,11
				   JNZ   ERR5
				   MOV   EDX,[PC]
				   MOV   DWORD PTR [EBX],1 ;SET FLAG
				   INC   EBX
				   INC   EBX
				   INC   EBX
				   INC   EBX
				   MOV   [EBX],EDX	;Set Left lik with last top
				   MOV   [LABPT],EBX
				   JMP   GETLET
				
				ERR5: JMP   ERROR
				
				ASMLIN:
				   MOV   BYTE PTR[MAXFLG],1 ;Allow only B and W flags normally
				   MOV   EBX,[PC]
				   MOV   [OLDPC],EBX
				   CALL  GETLAB
				   JNC   ASMLIN_SKIP
				   JMP   ENDLN
				ASMLIN_SKIP:
				   MOV   EBX,OFFSET LENID
				   MOV   AL,[EBX]
				   MOV   CL,12
				   SUB   AL,2
				   MOV   CH,AL
				   JC ERR5
				   INC   EBX
				   INC   EBX
				   INC   EBX
				   INC   EBX
				   CMP   BYTE PTR[EBX],"f"   ;See if an 8087 mnemonic
				   JZ NDPOP
				   CMP   AL,5
				   JNC   ERR5
				
				LOCATE_OPTAB:
				   XOR   EAX,EAX
				   MOV   AL,[EBX] ;EBX:LABEL HEAP
				   SUB   AL,'a'
				   MOV   CL,AL ;CL=AL=ch-'a'
				   ;ADD   AL,AL ;
				   ;ADD   AL,AL ;
				   ADD   EAX,EAX
				   ADD   EAX,EAX
				
				   ADD   AL,CL
				   ADD   AL,CH
				   ;ADD   AL,AL
				
				   ;AL=(AL*5+CH)*4
				   ADD   EAX,EAX
				   ADD   EAX,EAX
				
				   MOV   EBX,OPTAB
				   XOR   EDX,EDX
				   MOV   EDX,EAX
				   ADD   EBX,EDX
				   
				   MOV   EAX,[EBX];OPTAB+AL =PTR:E3:EQU
				   INC   CH ;CH=1+1
				   MOV   CL,CH ;CL=CH
				
				   MOV   EBX,EAX
				   MOV   AH,[EBX] ;OPERANDS COUNT
				   INC   EBX ;Pointer to following string
				   OR AH,AH
				   JZ OPERR ;AH SHOULD NOT BE 0
				FINDOP:
				   MOV   CH,CL
				   MOV   EDX,OFFSET ID+1
				   XCHG  EAX,EBP    ;Save count of opcodes in EBP
				   CALL  CPSLP ;CMP EBX,EDX, CH=LENGTH; EBX++,EDX++
				   JZ HAVOP
				   XCHG  EAX,EBP
				   XOR   EDX,EDX
				   MOV   DL,CH
				   INC   EDX
				   INC   EDX
				   ;4 bytes ptr
				   INC   EDX
				   INC   EDX
				
				   ADD   EBX,EDX
				   DEC   AH
				   JNZ   FINDOP
				OPERR:
				   MOV   CL,12
				   JMP   ERROR
				
				HAVOP:
				   ;EBX:Pointer to function
				   ;EBX+4:
				   MOV   AL,[EBX+4]   ;Get opcode
				   JMP   DWORD PTR[EBX]
				
				NDPOP:   ;First letter is "F" so must be 8087 opcode ("Numeric Data Processor")
				   MOV   BYTE PTR[MAXFLG],4 ;Allow all type flags
				   INC   EBX
				   CMP   BYTE PTR[EBX],"n"   ;"No-wait" form?
				   MOV   AH,0
				   JNZ   SAVNFLG
				   MOV   AH,1
				   DEC   AL
				   INC   EBX    ;Skip over the "N"
				SAVNFLG:
				   MOV   BYTE PTR[NOWAIT],AH ;0 for wait, 1 for no wait
				   CMP   AL,1
				   JB OPERR    ;Not enough char left for valid opcode?
				   CMP   AL,5
				   JA OPERR    ;Too many?
				   CBW
				   XCHG  EAX,EDX    ;Save length in EDX
				   MOV   ESI,EDX
				   OR BYTE PTR[ESI+EBX],80H   ;Set high bit of last character
				   MOV   AL,[EBX]     ;Get first char of opcode
				   INC   EBX
				   SUB   AL,"a"
				   JB TRY2XM1     ;Go see if opcode starts with "2"
				   CMP   AL,"z"-"a"
				   JA OPERR
				   CBW
				   SHL   EAX,1     ;Double to index into address table
				   SHL   EAX,1
				   XCHG  EAX,ESI    ;Put in index register
				   MOV   EDI,OFFSET NDPTAB ;Get start of opcode table for this letter
				   ADD   EDI,ESI
				LOOKNDP:
				   MOV   AH,[EDI]     ;Number of opcodes starting with this letter
				   OR AH,AH
				   JZ OPERR    ;Any start with this letter?
				FNDNDP:
				   INC   EDI
				   MOV   ESI,EBX    ;Pointer to start of opcode
				   MOV   ECX,EDX    ;Get length of opcode
				   REPE CMPSB       ;Compare opcode to table entry
				   JZ HAVNDP
				   DEC   EDI    ;Back up in case that was last letter
				   MOV   AL,80H      ;Look for char with high bit set
				ENDOP:
				   SCASB
				   JA ENDOP
				   INC   EDI    ;Skip over info about opcode
				   DEC   AH
				   JNZ   FNDNDP
				OPERRJ:  JMP OPERR
				
				TRY2XM1:
				   CMP   AL,"2"-"a"
				   JNZ   OPERR
				   MOV   EDI,XM1
				   JMP LOOKNDP
				
				SPECIALOP:
				   AND   AL,7     ;Mask to special op number
				   JZ _FWAIT      ;If zero, go handle FWAIT
				;Handle FNOP
				   CMP   BYTE PTR[NOWAIT],0 ;Was "N" present (If not opcode was "FOP")
				   JZ OPERR
				   MOV   AL,9BH      ;Need Wait opcode after all
				   CALL  PUT
				   MOV   AL,0D9H
				   CALL  PUT
				   MOV   AL,0D0H
				   JMP   PUT
				
				_FWAIT:
				   CMP   BYTE PTR[NOWAIT],0 ;"FNWAIT" not legal
				   JNZ   OPERRJ
				   RET         ;Nothing to do - "WAIT" already sent
				
				HAVNDP:
				   MOV   ESI,EDI
				   CMP   BYTE PTR[NOWAIT],0
				   JNZ   NWAIT
				   MOV   AL,9BH      ;Wait opcode
				   CALL  PUT
				NWAIT:
				   LODSW       ;Get opcode info
				   TEST  AL,0F8H     ;Any operand bits set?
				   JZ NOOPS    ;If no operands, output code
				   TEST  AL,78H      ;Special case?
				   JZ SPECIALOP
				   PUSH  EAX
				   CALL  GETSYM      ;See if any operands
				   POP   ECX
				   CMP   AL,";"
				   JZ NOOPCHK
				   CMP   AL,EOL
				   JZ NOOPCHK
				   CMP   AL,FREG     ;Is it 8087 register?
				   JNZ   MEMOP
				   XCHG  EAX,ECX
				   TEST  AL,ONEREG   ;One register OK as operand?
				   JNZ   PUTREG      ;Yes - save it
				   TEST  AL,20H      ;Memory-only operation?
				   MOV   CL,20
				   JNZ   ERRJ4
				   TEST  AL,18H      ;Two-register operation?
				   JPE   ERRJ4    ;Must be exactly one bit set
				   PUSH  EDX    ;Save register number
				   PUSH  EAX    ;Save opcode
				   CALL  GETSYM
				   CMP   AL,","
				   MOV   CL,15H
				   JNZ   ERRJ4
				   CALL  GETSYM
				   MOV   CL,20
				   CMP   AL,FREG
				   JNZ   ERRJ4
				   POP   EAX
				   POP   EBX
				   XOR   AL,2     ;Flip "POP" bit
				   AND   AL,0FBH     ;Reset direction bit to ST(0)
				   OR BL,BL    ;Is first register ST(0)?
				   JZ ST0DEST
				   XCHG  EDX,EBX
				   OR BL,BL    ;One of these must be ST(0)
				   JNZ   ERRJ4
				   XOR   AL,4     ;Flip direction
				   JMP   PUTREG
				ST0DEST:
				   TEST  AL,2     ;Is POP bit set?
				   JNZ   ERRJ4    ;Don't allow destination ST(0) then pop
				PUTREG:
				   AND   AH,0F8H     ;Zero out register field
				   OR AH,DL
				   OR AH,0C0H
				   PUSH  EAX
				   CALL  GETSYM      ;Get to next symbol
				   POP   EAX
				   JMP   NOOPS
				
				NOOPCHK:
				   XCHG  EAX,ECX
				   TEST  AL,80H      ;Is no operands OK?
				   MOV   CL,20
				   JNZ   ERRJ4
				NOOPS:
				;First test for FDIV or FSUB and reverse "R" bit if "D" bit is set
				   PUSH  EAX
				   AND   EAX,0E005H
				   CMP   EAX,0E004H
				   POP   EAX
				   JNZ   NOREV
				   XOR   AH,8     ;Reverse "R" bit
				NOREV:
				   AND   AL,7
				   OR AL,0D8H     ;ESC hook
				   CALL  PUT
				   MOV   AL,AH
				   JMP   PUT
				
				BADFLAG:
				   MOV   CL,20H
				ERRJ4:   JMP   ERROR
				
				MEMOP:
				   PUSH  ECX    ;Save opcode
				   CALL  GETOP1      ;Get memory operand
				   CMP   AL,UNDEFID  ;Is it?
				   MOV   CL,20
				   JNZ   ERRJ4
				   POP   EAX
				   TEST  AL,20H      ;Does it have memory format field?
				   JNZ   GETFORMAT
				   TEST  AL,8     ;Check if any memory operand legal
				   JZ ERRJ4
				   TEST  AL,10H      ;Check for 2-op arithmetic
				   JNZ   PUTMEM      ;If not, just use as plain memory op
				GETFORMAT:
				   AND   AL,0F9H     ;Zero memory format bits
				   MOV   CL,[FLAG]
				   DEC   CL    ;Must now be in range 0-3
				   JL BADFLAG
				   MOV   CH,AL    ;Save opcode byte
				   SHR   AL,1     ;Put format bits in bits 2 & 3
				   AND   AL,0CH
				   OR AL,CL    ;Combine format bits with flag
				   MOV   EBX,FORMATTAB
				   XLATB
				   OR AL,AL    ;Valid combination?
				   JS BADFLAG
				   OR AH,AL    ;Possibly set new bits in second byte
				   OR AL,CH    ;Set memory format bits
				PUTMEM:
				   AND   AL,7
				   OR AL,0D8H
				   CALL  PUT
				   MOV   AL,AH
				   AND   AL,38H
				   OR AL,DL    ;Combine addressing mode
				   JMP   PUTADD
				
				FORMATTAB:
				;There are 16 entries in this table. The 4-bit index is built like this:
				;  Bit 3    0 for normal memory ops, 1 if extended is OK
				;  Bit 2    0 for integer, 1 for real
				;  Bit 0 & 1   Flag: 00=W, 01=S, 10=L, 11=T
				;
				;The entries in the table are used as two 3-bit fields. Bits 0-2 are ORed
				;into the first byte of the opcode for the Memory Format field. Bits 3-6
				;are ORed into the second byte to modify the opcode for extended operands.
				;If bit 7 is set, then that combination is illegal.
				
				   DB 6,2,80H,80H ;Normal integers
				   DB 80H,0,4,80H ;Normal reals
				   DB 6,2,2EH,80H ;Extended integers
				   DB 80H,0,4,2BH ;Extended reals
				
				GRP1:
				   MOV   ECX,8A09H
				   CALL  MROPS
				   MOV   ECX,0C6H
				   MOV   AL,BH
				   CMP   AL,UNDEFID
				   JNZ   L0006
				   CALL  STIMM
				L0006:   
				   AND   AL,1
				   JZ BYTIMM
				   MOV   AL,0B8H
				   OR AL,BL
				   CALL  PUT
				   JMP   PUTWOR
				
				BYTIMM:
				   MOV   AL,0B0H
				   OR AL,BL
				   CALL  PUT
				PUTBJ:   JMP   PUTBYT
				
				IMMED:
				   MOV   AL,BH
				   CMP   AL,UNDEFID
				   JZ STIMM
				   MOV   AL,BL
				   OR AL,AL
				   JZ IMM_RET
				   MOV   AL,BH
				   CALL  IMM
				   OR AL,0C0H
				   CALL  PUT
				FINIMM:
				   MOV   AL,CL
				   POP   ECX
				   TEST  AL,1
				   JZ PUTBJ
				   CMP   AL,83H
				   JZ PUTBJ
				   JMP   PUTWOR
				
				STIMM:
				   MOV   AL,[FLAG]
				   CALL  IMM
				   CALL  PUTADD
				   JMP FINIMM
				
				IMM:
				   AND   AL,1
				   OR AL,CL
				   MOV   CL,AL
				   CALL  PUT
				   MOV   AL,CH
				   AND   AL,38H
				   OR AL,BL
				IMM_RET:
				   RET
				
				PUT:
				;Save byte in AL as pure code, with intermediate code bits 00. AL and
				;EDI destroyed, no other registers affected.
				   PUSH  EBX
				   PUSH  ECX
				   MOV   CH,0     ;Flag as pure code
				   CALL  GEN
				   POP   ECX
				   POP   EBX
				   RET
				
				GEN:
				;Save byte of code in AL, given intermediate code bits in bits 7&8 of CH.
				   CALL  PUTINC      ;Save it and bump code pointer
				GEN1:
				   MOV   AL,BYTE PTR[RELOC]
				   RCL   CH,1
				   RCL   AL,1
				   RCL   CH,1
				   RCL   AL,1
				   MOV   BYTE PTR[RELOC],AL
				   MOV   EBX,BCOUNT
				   DEC   BYTE PTR[EBX]
				   JNZ   GEN1_RET
				   MOV   BYTE PTR[EBX],4
				   MOV   EBX,RELOC
				   MOV   AL,[EBX]
				   MOV   BYTE PTR[EBX],0
				   MOV   EDI,[IY]
				   MOV   [EDI],AL
				   MOV   EBX,[CODE]
				   MOV   [IY],EBX
				   INC   EBX
				   MOV   [CODE],EBX
				GEN1_RET:
				   RET
				
				PUTINC:
				   INC   DWORD PTR[PC]
				PUTCD:
				   MOV   EDI,[CODE]
				   STOSB
				   MOV   [CODE],EDI
				   RET
				
				PUTWOR:
				;Save the word value described by [DLABEL] and [DATA] as code. If defined,
				;two bytes of pure code will be produced. Otherwise, appropriate intermediate
				;code will be generated.
				   PUSH  ECX
				   MOV   CH,80H
				   PUSH  EDX
				   PUSH  EBX
				   JMP PUTBW
				
				PUTBYT:
				;Same as PUTWOR, above, but for byte value.
				   PUSH  ECX
				   MOV   CH,40H
				   PUSH  EDX
				   PUSH  EBX
				   MOV   EBX,[DLABEL]
				   MOV   AL,BH
				   OR AL,BL
				   JNZ   PUTBW
				   MOV   EBX,[_DATA]
				   OR AL,BH
				   JZ PUTBW
				   INC   BH
				   JZ PUTBW
				   MOV   CL,31
				   JMP   ERROR
				PUTBW:
				   MOV   EDX,[DLABEL]
				   MOV   EBX,[_DATA]
				PUTCHK:
				   OR EDX,EDX
				   JZ NOUNDEF
				   MOV   AL,DL
				   CALL  PUTCD
				   MOV   AL,DH
				   CALL  PUTCD
				   MOV   AL,BL
				   CALL  PUTINC
				   MOV   AL,BH
				   TEST  CH,080H
				   JZ SMPUT
				   CALL  GEN
				   JMP PRET
				SMPUT:
				   CALL  PUTCD
				   CALL  GEN1
				PRET:
				   POP   EBX
				   POP   EDX
				   POP   ECX
				   RET
				
				NOUNDEF:
				   MOV   AL,BL
				   MOV   CL,BH
				   PUSH  ECX
				   MOV   CH,0
				   CALL  GEN
				   POP   ECX
				   MOV   AL,CL
				   TEST  CH,080H
				   MOV   CH,0
				   JZ PRET
				   CALL  GEN
				   JMP PRET
				
				PUTADD:
				;Save complete addressing mode. Addressing mode is in AL; if this is a register
				;operation (>=C0), then the one byte will be saved as pure code. Otherwise,
				;the details of the addressing mode will be investigated and the optional one-
				;or two-byte displacement will be added, as described by [_ADDR] and [ALABEL].
				   PUSH  ECX
				   PUSH  EDX
				   PUSH  EBX
				   MOV   CH,0
				   MOV   CL,AL
				   CALL  GEN      ;Save the addressing mode as pure code
				   MOV   AL,CL
				   MOV   CH,80H
				   AND   AL,0C7H
				   CMP   AL,6
				   JZ TWOBT    ;Direct address?
				   AND   AL,0C0H
				   JZ PRET     ;Indirect through reg, no displacement?
				   CMP   AL,0C0H
				   JZ PRET     ;Register to register operation?
				   MOV   CH,AL    ;Save whether one- or two-byte displacement
				TWOBT:
				   MOV   EBX,[_ADDR]
				   MOV   EDX,[ALABEL]
				   JMP PUTCHK
				
				GRP2:
				   CALL  GETOP
				   MOV   ECX,0FF30H
				   CMP   AL,UNDEFID
				   JZ PMEM
				   MOV   CH,50H
				   CMP   AL,XREG
				   JZ PXREG
				   MOV   CH,6
				   CMP   AL,SREG
				   JNZ   GRP2_SKIP
				   JMP   PACKREG
				GRP2_SKIP:
				   MOV   CL,20
				   JMP   ERROR
				
				PMEM:
				   MOV   AL,CH
				   CALL  PUT
				   MOV   AL,CL
				   OR AL,DL
				   JMP   PUTADD
				
				PXREG:
				   MOV   AL,CH
				   OR AL,DL
				   JMP   PUT
				
				GRP3:
				   CALL  GETOP
				   PUSH  EDX
				   CALL  GETOP2
				   POP   EBX
				   MOV   ECX,8614H
				   MOV   AL,SREG
				   CMP   AL,BH
				   JZ ERR6
				   CMP   AL,DH
				   JZ ERR6
				   MOV   AL,CONST
				   CMP   AL,BH
				   JZ ERR6
				   CMP   AL,DH
				   JZ ERR6
				   MOV   AL,UNDEFID
				   CMP   AL,BH
				   JZ EXMEM
				   CMP   AL,DH
				   JZ EXMEM1
				   MOV   AL,BH
				   CMP   AL,DH
				   MOV   CL,22
				   JNZ   ERR6
				   CMP   AL,XREG
				   JZ L0008
				   CALL  RR1
				L0008:         ;RR1 never returns
				   MOV   AL,BL
				   OR AL,AL
				   JZ EXACC
				   XCHG  EDX,EBX
				   MOV   AL,BL
				   OR AL,AL
				   MOV   AL,BH
				   JZ EXACC
				   CALL  RR1
				EXACC:
				   MOV   AL,90H
				   OR AL,DL
				   JMP   PUT
				
				EXMEM:
				   XCHG  EDX,EBX
				EXMEM1:
				   CMP   AL,BH
				   JZ ERR6
				   MOV   CL,1  ;Flag word as OK
				   CALL  NOTAC ;NOTAC never returns
				ERR6: JMP   ERROR
				
				GRP4:
				   PUSH  EAX
				   CALL  GETOP
				   POP   ECX
				   XCHG  CL,CH
				   CMP   AL,CONST
				   JZ FIXED
				   SUB   AL,XREG
				   DEC   DL
				   DEC   DL
				   OR AL,DL
				   MOV   CL,20
				   JNZ   ERR6
				   MOV   AL,CH
				   OR AL,8
				   JMP   PUT
				FIXED:
				   MOV   AL,CH
				   CALL  PUT
				   JMP   PUTBYT
				
				GRP5:
				   PUSH  EAX
				   CALL  GETOP
				   MOV   CL,20
				   CMP   AL,CONST
				   JNZ   ERR6
				   MOV   EBX,[DLABEL]
				   MOV   AL,BH
				   OR AL,BL
				   MOV   CL,30
				   JNZ   ERR6
				   MOV   EBX,[_DATA]
				   POP   EAX
				   OR AL,AL
				   JZ _ORG
				   DEC   AL
				   JZ DSJ
				   DEC   AL
				   JZ _EQU
				   DEC   AL
				   JZ PUTOP
				   JMP   _IF
				PUTOP:
				   MOV   AL,-3
				   JMP NEWLOC
				_ALIGN:
				   MOV   AL,BYTE PTR[PC]
				   AND   AL,1
				   JZ _EQU_RET
				   MOV   EBX,1
				DSJ:
				   XCHG  EDX,EBX
				   MOV   EBX,[PC]
				   ADD   EBX,EDX
				   MOV   [PC],EBX
				   XCHG  EDX,EBX
				   MOV   AL,-4
				   JMP NEWLOC
				_EQU:
				   XCHG  EDX,EBX
				   MOV   EBX,[LABPT]
				   MOV   AL,BH
				   OR AL,BL
				   MOV   CL,34
				   JZ ERR7
				   MOV   [EBX],DL
				   INC   EBX
				   MOV   [EBX],DH
				_EQU_RET:
				   RET
				_ORG:
				   MOV   [PC],EBX
				   MOV   AL,-2
				NEWLOC:
				   CALL  PUTCD
				   MOV   AL,BL
				   CALL  PUTCD
				   MOV   AL,BH
				   CALL  PUTCD
				   MOV   CH,0C0H
				   JMP   GEN1
				GRP6:
				   MOV   CH,AL
				   MOV   CL,4
				   CALL  MROPS
				   MOV   CL,23
				ERR7: JMP   ERROR
				GRP7:
				   MOV   CH,AL
				   MOV   CL,1
				   CALL  MROPS
				   MOV   CL,80H
				   MOV   EDX,[DLABEL]
				   MOV   AL,DH
				   OR AL,DL
				   JNZ   ACCJ
				   XCHG  EDX,EBX
				   MOV   EBX,[_DATA]
				   MOV   AL,BL
				   CBW
				   CMP   EAX,EBX
				   XCHG  EDX,EBX
				   JNZ   ACCJ
				   OR CL,002H
				ACCJ: JMP   ACCIMM
				GRP8:
				   MOV   CL,AL
				   MOV   CH,0FEH
				   JMP ONEOP
				GRP9:
				   MOV   CL,AL
				   MOV   CH,0F6H
				ONEOP:
				   PUSH  ECX
				   CALL  GETOP
				ONE:
				   MOV   CL,26
				   CMP   AL,CONST
				   JZ ERR7
				   CMP   AL,SREG
				   MOV   CL,22
				   JZ ERR7
				   POP   ECX
				   CMP   AL,UNDEFID
				   JZ MOP
				   AND   AL,1
				   JZ ROP
				   TEST  CL,001H
				   JZ ROP
				   MOV   AL,CL
				   AND   AL,0F8H
				   OR AL,DL
				   JMP   PUT
				MOP:
				   MOV   AL,[FLAG]
				   AND   AL,1
				   OR AL,CH
				   CALL  PUT
				   MOV   AL,CL
				   AND   AL,38H
				   OR AL,DL
				   JMP   PUTADD
				ROP:
				   OR AL,CH
				   CALL  PUT
				   MOV   AL,CL
				   AND   AL,38H
				   OR AL,0C0H
				   OR AL,DL
				   JMP   PUT
				GRP10:
				   MOV   CL,AL
				   MOV   CH,0F6H
				   PUSH  ECX
				   CALL  GETOP
				   MOV   CL,20
				   MOV   AL,DL
				   OR AL,AL
				   JNZ   ERRJ1
				   MOV   AL,DH
				   CMP   AL,XREG
				   JZ G10
				   CMP   AL,REG
				ERRJ1:   JNZ   ERR8
				G10:
				   PUSH  EAX
				   CALL  GETOP
				   POP   EAX
				   AND   AL,1
				   MOV   [FLAG],AL
				   MOV   AL,DH
				ONEJ: JMP ONE
				GRP11:
				   CALL  PUT
				   MOV   AL,0AH
				   JMP   PUT
				GRP12:
				   MOV   CL,AL
				   MOV   CH,0D0H
				   PUSH  ECX
				   CALL  GETOP
				   MOV   AL,[SYM]
				   CMP   AL,','
				   MOV   AL,DH
				   JNZ   ONEJ
				   PUSH  EDX
				   CALL  GETOP
				   SUB   AL,REG
				   MOV   CL,20
				   DEC   DL
				   OR AL,DL
				   JNZ   ERR8
				   POP   EDX
				   MOV   AL,DH
				   POP   ECX
				   OR CH,002H
				   PUSH  ECX
				   JMP   ONE
				GRP13:
				   MOV   CH,AL
				   MOV   CL,1
				   CALL  MROPS
				   MOV   CL,80H
				ACCIMM:
				   CALL  IMMED
				   OR CH,004H
				   AND   CH,0FDH
				AIMM:
				   MOV   AL,BH
				   AND   AL,1
				   LAHF
				   PUSH  EAX
				   OR AL,CH
				   CALL  PUT
				   POP   EAX
				   SAHF
				   JNZ   AIMM_SKIP
				   JMP   PUTBYT
				AIMM_SKIP:
				   JMP   PUTWOR
				
				ERR8: JMP   ERROR
				
				GRP14:
				;JMP and CALL mnemonics
				   LAHF
				   XCHG  AH,AL
				   PUSH  EAX
				   XCHG  AH,AL
				   MOV   BYTE PTR[MAXFLG],3 ;Allow "L" flag
				   CALL  GETOP
				   CMP   AL,CONST
				   JZ DIRECT
				   MOV   CL,20
				   CMP   AL,REG
				   JZ ERR8
				   CMP   AL,SREG
				   JZ ERR8
				   CMP   AL,XREG
				   JNZ   NOTRG
				   OR DL,0C0H
				NOTRG:
				;Indirect jump. DL has addressing mode.
				   MOV   AL,0FFH
				   CALL  PUT
				   POP   EAX
				   XCHG  AH,AL
				   SAHF
				   AND   AL,38H
				   OR AL,DL
				   MOV   CH,[FLAG]
				   CMP   CH,3     ;Flag "L" present?
				   JZ PUTADDJ     ;If so, do inter-segment
				   MOV   CL,27H
				   CMP   CH,-1    ;Better not be a flag
				   JNZ   ERR8
				   AND   AL,0F7H     ;Convert to intra-segment
				PUTADDJ:
				   JMP   PUTADD
				DIRECT:
				   MOV   AL,[SYM]
				   CMP   AL,','
				   JZ LONGJ
				   POP   EAX
				   XCHG  AH,AL
				   SAHF
				   DEC   AL
				   CMP   AL,0E9H
				   JZ GOTOP
				   MOV   AL,0E8H
				GOTOP:
				   CALL  PUT
				   MOV   EDX,[PC]
				   INC   EDX
				   INC   EDX
				   SUB   [_DATA],EDX
				   JMP   PUTWOR
				LONGJ:
				   POP   EAX
				   XCHG  AH,AL
				   SAHF
				   CALL  PUT
				   CALL  PUTWOR
				   CALL  GETOP
				   MOV   CL,20
				   CMP   AL,CONST
				   JNZ   ERR8
				   JMP   PUTWOR
				
				GRP16:
				;RET mnemonic
				   LAHF
				   XCHG  AH,AL
				   PUSH  EAX
				   XCHG  AH,AL
				   CALL  GETSYM
				   CMP   AL,5
				   JZ LONGR
				   CMP   AL,EOL
				   JZ NODEC
				   CMP   AL,';'
				   JZ NODEC
				GETSP:
				   CALL  GETOP1
				   POP   ECX
				   CMP   AL,CONST
				   MOV   CL,20
				   JNZ   ERR9
				   MOV   AL,CH
				   AND   AL,0FEH
				   CALL  PUT
				   JMP   PUTWOR
				LONGR:
				   CMP   DL,3     ;Is flag "L"?
				   MOV   CL,27H
				   JNZ   ERR10    ;If not, bad flag
				   POP   EAX
				   XCHG  AH,AL
				   SAHF
				   OR AL,8
				   LAHF
				   XCHG  AH,AL
				   PUSH  EAX
				   XCHG  AH,AL
				NOTLON:
				   CALL  GETSYM
				   CMP   AL,EOL
				   JZ DORET
				   CMP   AL,';'
				   JZ DORET
				   CMP   AL,','
				   JNZ   L0011
				   CALL  GETSYM
				L0011:   
				   JMP GETSP
				NODEC:
				;Return is intra-segment (short) without add to ESP. 
				;Record position for RET symbol.
				   MOV   EBX,[PC]
				   MOV   [LSTRET],EBX
				   XCHG  EDX,EBX
				   MOV   EBX,[RETPT]
				   MOV   AL,BH
				   OR AL,BL
				   JZ DORET
				   MOV   BYTE PTR[EBX],1
				   INC   EBX
				   MOV   [EBX],EDX
				   MOV   EBX,0
				   MOV   [RETPT],EBX
				DORET:
				   POP   EAX
				   XCHG  AH,AL
				   SAHF
				   JMP   PUT
				
				GRP17:
				   CALL  PUT
				   CALL  GETOP
				   CMP   AL,CONST
				   MOV   CL,20
				ERR9: JNZ   ERR10
				   MOV   EBX,[_DATA]
				   MOV   EDX,[PC]
				   INC   EDX
				   SUB   EBX,EDX
				   MOV   [_DATA],EBX
				   CALL  PUTBYT
				   MOV   EBX,[DLABEL]
				   MOV   AL,BH
				   OR AL,BL
				   JNZ   ERR9_RET
				   MOV   EBX,[_DATA]
				   MOV   AL,BL
				   CBW
				   CMP   EAX,EBX    ;Signed 8-bit number?
				   JZ ERR9_RET
				   MOV   CL,31
				ERR10:   JMP   ERROR
				ERR9_RET:
				   RET
				GRP18:
				   CALL  GETOP
				   CMP   AL,CONST
				   MOV   CL,20
				   JNZ   ERR10
				   MOV   EBX,[DLABEL]
				   MOV   AL,BH
				   OR AL,BL
				   JNZ   GENINT
				   MOV   EBX,[_DATA]
				   MOV   EDX,3
				   SBB   EBX,EDX
				   JNZ   GENINT
				   MOV   AL,0CCH
				   JMP   PUT
				GENINT:
				   MOV   AL,0CDH
				   CALL  PUT
				   JMP   PUTBYT
				
				GRP19:   ;ESC opcode
				   CALL  GETOP
				   MOV   CL,20
				   CMP   AL,CONST
				   JNZ   ERRJ     ;First operand must be immediate
				   MOV   CL,1EH
				   TEST  DWORD PTR[DLABEL],-1 ;See if all labels have been defined
				   JNZ   ERRJ
				   MOV   EAX,[_DATA]
				   CMP   EAX,64    ;Must only be 6 bits
				   MOV   CL,1FH
				   JNB   ERRJ
				   MOV   BL,AL    ;Save for second byte
				   SHR   AL,1
				   SHR   AL,1
				   SHR   AL,1
				   OR AL,0D8H     ;ESC opcode
				   CALL  PUT
				   PUSH  EBX
				   CALL  GETOP2
				   POP   EBX
				   AND   BL,7     ;Low 3 bits of first operand
				   SHL   BL,1
				   SHL   BL,1
				   SHL   BL,1
				   CMP   AL,UNDEFID  ;Check for memory operand
				   JZ ESCMEM
				   CMP   AL,CONST ;Check for another immediate
				   JZ ESCIMM
				   MOV   CL,20
				ERRJ: JMP   ERROR
				
				ESCMEM:
				   OR BL,DL    ;Combine mode with first operand
				   MOV   AL,BL
				   JMP   PUTADD
				
				ESCIMM:
				   MOV   CL,1EH
				   TEST  DWORD PTR[DLABEL],-1 ;See if second operand is fully defined
				   JNZ   ERRJ
				   MOV   EAX,[_DATA]
				   MOV   CL,1FH
				   CMP   EAX,8     ;Must only be 3 bit value
				   JNB   ERRJ
				   OR AL,BL    ;Combine first and second operands
				   OR AL,0C0H     ;Force "register" mode
				   JMP   PUT
				
				GRP20:
				   MOV   CH,AL
				   MOV   CL,1
				   CALL  MROPS
				   MOV   CL,0F6H
				   CALL  IMMED
				   MOV   CH,0A8H
				   JMP   AIMM
				GRP21:
				   CALL  GETOP
				   CMP   AL,SREG
				   MOV   CL,28
				   JNZ   ERRJ
				   MOV   CH,26H
				PACKREG:
				   MOV   AL,DL
				   ADD   AL,AL
				   ADD   AL,AL
				   ADD   AL,AL
				   OR AL,CH
				   JMP   PUT
				GRP22:
				   CALL  GETOP
				   MOV   ECX,8F00H
				   CMP   AL,UNDEFID
				   JNZ   GRP22_SKIP
				   JMP   PMEM
				GRP22_SKIP:
				   MOV   CH,58H
				   CMP   AL,XREG
				   JNZ   GRP22_SKIP2
				   JMP   PXREG
				GRP22_SKIP2:
				   MOV   CH,7
				   CMP   AL,SREG
				   JZ PACKREG
				   MOV   CL,20
				ERR11:   JMP   ERROR
				GRP23:
				   MOV   [DATSIZ],AL
				GETDAT:
				   CALL  GETSYM
				   MOV   AL,2
				   CALL  VAL1
				   MOV   AL,[SYM]
				   CMP   AL,','
				   MOV   AL,[DATSIZ]
				   JNZ   ENDDAT
				   CALL  SAVDAT
				   JMP GETDAT
				ENDDAT:
				   CMP   AL,2
				   JNZ   SAVDAT
				   MOV   EBX,[_DATA]
				   LAHF
				   OR BL,080H
				   SAHF
				   MOV   [_DATA],EBX
				SAVDAT:
				   OR AL,AL
				   JZ SAVDAT_SKIP
				   JMP   PUTBYT
				SAVDAT_SKIP:
				   JMP   PUTWOR
				_IF:
				   OR EBX,EBX
				   JZ SKIPCD
				   INC   BYTE PTR[IFFLG]
				   RET
				
				SKIPCD:
				   INC   BYTE PTR[CHKLAB]
				SKIPLP:
				   XOR   AL,AL
				   CALL  NEXLIN
				   CALL  NEXTCHR
				   CMP AL,1AH
				   JZ _END
				   CALL  GETLAB
				   JC SKIPLP
				   MOV   EDI,OFFSET LENID
				   MOV   ESI,OFFSET IFEND
				   MOV   CH,0
				   MOV   CL,[EDI]
				   INC   CL
				   REPE CMPSB
				   JZ ENDCOND
				   MOV   EDI,OFFSET LENID
				   MOV   ESI,OFFSET IFNEST
				   MOV   CL,[EDI]
				   INC   CL
				   REPE CMPSB
				   JNZ   SKIPLP
				   INC   BYTE PTR[CHKLAB]
				   JMP SKIPLP
				
				ENDCOND:
				   DEC   BYTE PTR[CHKLAB]
				   JNZ   SKIPLP
				   RET
				
				_ENDIF:
				   MOV   AL,[IFFLG]
				   MOV   CL,36
				   DEC   AL
				   JS ERRJMP
				   MOV   [IFFLG],AL
				   RET
				
				ERRJMP:  JMP   ERROR
				
				;*********************************************************************
				;
				;  PASS 2
				;
				;*********************************************************************
				
				_END:
				   MOV   DL,4
				WREND:
				   MOV   CH,0FFH
				   MOV   AL,CH
				   CALL  GEN
				   DEC   DL
				   JNZ   WREND
				;----------------------------
				   MOV   DWORD PTR[BUFPT],OFFSET  SRCBUF
				   MOV   BYTE PTR[HEXCNT],-5   ;FLAG HEX BUFFER AS EMPTY
				   MOV   DWORD PTR[LSTPNT],OFFSET  LSTBUF
				   MOV   DWORD PTR[HEXPNT],OFFSET  HEXBUF
				   XOR   EAX,EAX
				   MOV   [ERRCNT],EAX
				   MOV   [PC],EAX
				   MOV   [LINE],EAX   ;Current line number
				   MOV   DWORD PTR[HEXADD],OBJECT
				   
				   PUSH SEEK_SET
				   PUSH 0
				   PUSH [SRCFILE]
				   CALL _fseek
				   ADD ESP,12
				
				   XOR   EAX,EAX
				   MOV   BYTE PTR[COUNT],AL
				   MOV   CH,1
				   MOV   ESI,CODE_START
				;------------------------
				FIXLINE:
				   MOV   EDI,CODE_START ;Store code over used up intermediate code
				   XOR   AL,AL
				   MOV   BYTE PTR[SPC],AL ;No "special" yet (ORG, PUT, DS)
				   MOV   BYTE PTR[_ERR],AL   ;No second pass errors yet
				NEXBT:
				   SHL   CL,1     ;Shift out last bit of previous code
				   DEC   CH    ;Still have codes left?
				   JNZ   TESTTYP
				   LODSB       ;Get next flag byte
				   MOV   CL,AL
				   MOV   CH,4
				TESTTYP:
				   SHL   CL,1     ;Set flags based on two bits
				   JO FIXUP
				   LODSB
				   JC EMARK
				OBJBT:
				   STOSB
				   JMP NEXBT
				
				FIXUP:
				;Either a word or byte fixup is needed from a forward reference
				   LODSB       ;Get pointer to symbol
				   XCHG  EAX,EBX
				   LODSB       ;Get constant part
				   ADD   EAX,[EBX+1]   ;Add symbol value to constant part
				   CMP   BYTE PTR[EBX],0  ;See if symbol got defined
				   JNZ   HAVDEF
				   MOV   BYTE PTR[_ERR],100 ;Undefined - flag error
				   XOR   EAX,EAX
				HAVDEF:
				   OR CL,CL    ;See if word or byte fixup
				   JS DEFBYT
				   STOSW
				   JMP NEXBT
				
				DEFBYT:
				   MOV   EDX,EAX
				   CBW         ;Extend sign
				   CMP   EAX,EDX    ;See if in range +127 to -128
				   JZ OBJBT    ;If so, it's always OK
				   NOT   AH    ;Check for range +255 to -256
				   CMP   AH,DH
				   JNZ   RNGERR      ;Must always be in this range
				;Check for short jump. If so, we're out of range; otherwise we're OK
				   CMP   EDI,CODE_START+1  ;Only one other byte on line?
				   JNZ   OBJBT    ;Can't be short jump if not
				   MOV   AL,BYTE PTR[CODE_START]  ;Get the first byte of this line
				   CMP   AL,0EBH     ;Direct short jump?
				   JZ RNGERR
				   AND   AL,0FCH
				   CMP   AL,0E0H     ;LOOP or JCXZ instruction?
				   JZ RNGERR
				   AND   AL,0F0H
				   CMP   AL,70H      ;Conditional jump?
				   MOV   AL,DL    ;Get code byte in AL
				   JNZ   OBJBT    ;If not, we're OK
				RNGERR:
				   MOV   BYTE PTR[_ERR],101 ;Value out of range
				   JMP OBJBT
				
				FINIJ:   JMP   FINI
				
				EMARK:
				   CMP   AL,-1    ;End of file?
				   JZ FINIJ
				   CMP   AL,-10      ;Special item?
				   JA SPEND
				   PUSH  ECX
				   PUSH  ESI
				   PUSH  EAX    ;Save error code
				   MOV   AH,BYTE PTR[LSTDEV]
				   AND   AH,0FEH     ;Reset error indicator
				   OR AL,BYTE PTR[_ERR]   ;See if any errors on this line
				   JZ NOERR
				   OR AH,1     ;Send line to console if error occured
				NOERR:
				   MOV   BYTE PTR[LSTDEV],AH
				   MOV   ECX,EDI
				   CALL  STRTLIN     ;Print address of line
				   MOV   ESI,CODE_START
				   SUB   ECX,ESI    ;Get count of bytes of code
				   JZ SHOLIN
				CODLP:
				   LODSB
				   CALL  SAVCD    ;Ouput code to HEX and PRN files
				   LOOP  CODLP
				SHOLIN:
				   MOV   AL,0
				   XCHG  AL,BYTE PTR[COUNT]
				   MOV   ECX,7     ;Allow 7 bytes of code per line
				   SUB   CL,AL
				   MOV   AL,' '
				   JZ NOFIL
				BLNK:          ;Put in 3 blanks for each byte not present
				   CALL  LIST
				   CALL  LIST
				   CALL  LIST
				   LOOP  BLNK
				NOFIL:
				   CALL  OUTLIN
				   POP   EAX    ;Restore error code
				   CALL  REPERR
				   MOV   AL,BYTE PTR[_ERR]
				   CALL  REPERR
				   POP   ESI
				   POP   ECX
				   MOV   AL,BYTE PTR[SPC] ;Any special funtion?
				   OR AL,AL
				   JNZ   SPCFUN
				   JMP   FIXLINE
				
				SPEND:
				   MOV   BYTE PTR[SPC],AL ;Record special function
				   LODSW       ;Get it's data
				   MOV   [_DATA],EAX
				   JMP   NEXBT
				
				SPCFUN:
				   MOV   EDX,[_DATA]
				   CMP   AL,-2
				   JZ DORG
				   CMP   AL,-3
				   JZ DPUT
				DDS:
				;Handle DS pseudo-op
				   ADD   [PC],EDX
				   ADD   [HEXADD],EDX
				   JMP   FIXLINE
				
				DORG:
				;Handle ORG pseudo-op
				   MOV   [PC],EDX
				   JMP   FIXLINE
				
				DPUT:
				;Handle PUT pseudo-op
				   MOV   [HEXADD],EDX
				   JMP   FIXLINE
				
				OUTLIN:
				;Copy the source line to the ouput device. Line will be preceded by
				;assembler-generated line number. This routine may be called several times
				;on one line (once for each line of object code bytes), so it sets a flag
				;so the line will only be output on the first call.
				   MOV   AL,-1
				   XCHG  AL,BYTE PTR[LINFLG]
				   OR AL,AL
				   JNZ   CRLF     ;Output line only if first time
				   MOV   EAX,[LINE]
				   INC   EAX
				   MOV   [LINE],EAX
				   MOV   BH,0     ;No leading zero suppression
				   CALL  OUT10
				   MOV   AL," "
				   CALL  LIST
				   PUSH  ESI    ;Save the only register destroyed by NEXTCHR
				OUTLN:
				   CALL  NEXTCHR
				   CALL  LIST
				   CMP   AL,10    ;Output until linefeed found
				   JNZ   OUTLN
				   POP   ESI
				   RET
				
				PRTCNT:
				   MOV   EAX,[ERRCNT]
				   MOV   EBX,OFFSET ERCNTM
				PRNT10:
				   PUSH  EAX
				   CALL  PRINT
				   POP   EAX
				   MOV   BH,"0"-" "  ;Enable leading zero suppression
				   CALL  OUT10
				CRLF:
				   MOV   AL,13
				   CALL  LIST
				   MOV   AL,10
				   JMP LIST
				
				OUT10:
				   XOR   EDX,EDX
				   MOV   EDI,10000
				   DIV   EDI
				   OR AL,AL    ;>10,000?
				   JNZ   LEAD
				   SUB   AL,"0"-" "  ;Convert leading zero to blank
				LEAD:
				   ADD   AL,"0"
				   CALL  LIST
				   XCHG  EAX,EDX
				   MOV   BL,100
				   DIV   BL
				   MOV   BL,AH
				   CALL  HIDIG    ;Convert to decimal and print 1000s digit
				   CALL  DIGIT    ;Print 100s digit
				   MOV   AL,BL
				   CALL  HIDIG    ;Convert to decimal and print 10s digit
				   MOV   BH,0     ;Ensure leading zero suppression is off
				   JMP DIGIT
				
				HIDIG:
				   AAM         ;Convert binary to unpacked BCD
				   OR EAX,3030H ;Add "0" bias
				DIGIT:
				   XCHG  AL,AH
				   CMP   AL,"0"
				   JZ SUPZ
				   MOV   BH,0     ;Turn off zero suppression if not zero
				SUPZ:
				   SUB   AL,BH    ;Convert leading zeros to blanks
				   JMP LIST
				
				STRTLIN:
				   MOV   BYTE PTR[LINFLG],0
				   MOV   EBX,[PC]
				   MOV   AL,BH
				   CALL  PHEX
				   MOV   AL,BL
				PHEXB:
				   CALL  PHEX
				   MOV   AL,' '
				LIST:
				   PUSH  EAX
				   PUSH  EDX
				   AND   AL,7FH
				   MOV   DL,AL
				FILCHK:
				   MOV   AL,DL
				   POP   EDX
				   CALL  WRTBUF
				   POP   EAX
				   RET
				
				WRTBUF:
				   PUSH  EDI
				   MOV   EDI,[LSTPNT]
				   STOSB
				   CMP   EDI,OFFSET LSTBUF+BUFSIZ
				   JNZ   SAVPT
				   PUSH  EAX
				   PUSH  ECX
				   PUSH  EDX
				   CALL  FLUSHBUF
				   POP   EDX
				   POP   ECX
				   POP   EAX
				SAVPT:
				   MOV   [LSTPNT],EDI
				   POP   EDI
				   RET
				
				PHEX:
				   PUSH  EAX
				   CALL  UHALF
				   CALL  LIST
				   POP   EAX
				   CALL  LHALF
				   JMP LIST
				
				FINI:
				   OR BYTE PTR[LSTDEV],1
				   CALL  PRTCNT
				   MOV   EBX,OFFSET SYMSIZE
				   MOV   EAX,OFFSET HEAP_START
				   SUB   EAX,[_HEAP]     ;Size of symbol table
				   CALL  PRNT10
				   MOV   EBX,OFFSET FRESIZE
				   MOV   EAX,[_HEAP]
				   SUB   EAX,[CODE]      ;Free space remaining
				   CALL  PRNT10
				   AND   BYTE PTR[LSTDEV],0FEH
				   MOV   AL,BYTE PTR[HEXCNT]
				   CMP   AL,-5
				   JZ L0012
				   CALL  ENHEXL
				L0012:   
				   MOV   AL,':'
				   CALL  PUTCHR
				   MOV   CH,10
				HEXEND:
				   PUSH  ECX
				   MOV   AL,'0'
				   CALL  PUTCHR
				   POP   ECX
				   DEC   CH
				   JNZ   HEXEND
				   MOV   AL,13
				   CALL  PUTCHR
				   MOV   AL,10
				   CALL  PUTCHR
				   CALL  WRTHEX      ;Flush HEX file buffer
				   PUSH  [HEXFILE]
				   CALL  _fclose
				   ADD   ESP,4
				
				DOSYMTAB:
				   MOV   EBX,OFFSET SYMMES
				   CALL  PRINT
				   MOV   EDX,[BASE]
				   MOV   AL,DH
				   OR AL,DL
				   JZ ENDSYM
				   MOV   BYTE PTR[SYMLIN],SYMWID  ;No symbols on this line yet
				   MOV   EBX,[_HEAP]
				   MOV   ESP,EBX    ;Need maximum stack for recursive tree walk
				   CALL  NODE
				ENDSYM:
				   TEST  BYTE PTR[LSTDEV],80H  ;Print listing to file?
				   JZ EXIT
				   MOV AL,1AH
				   CALL  WRTBUF      ;Write end-of-file mark
				   MOV   EDI,[LSTPNT]
				   CALL  FLUSHBUF
				   PUSH  [LSTFILE]
				   CALL  _fclose
				   ADD   ESP,4
				
				EXIT: 
				   PUSH  [SRCFILE]
				   XOR   EAX,EAX
				   CALL  _fclose
				   ADD   ESP,4
				   RET
				NODE:
				   XCHG  EDX,EBX
				   PUSH  EBX
				XOR EDX,EDX
				   MOV   DL,[EBX]
					INC   EBX
					INC   EBX
					INC   EBX
					INC   EBX
				   ADD   EBX,EDX
				   MOV   EDX,[EBX]
				   OR EDX,EDX
				   JZ L0014
				   CALL  NODE
				L0014:   
				   POP   EBX
				   MOV   AL,[EBX]
				   INC   EBX
				   MOV   CH,AL
				   ADD   AL,24
				   SHR   AL,1
				   SHR   AL,1
				   SHR   AL,1
				   MOV   CL,AL
				   INC   CL    ;Invert last bit
				   AND   CL,1     ;Number of extra tabs needed (0 or 1)
				   SHR   AL,1     ;Number of positions wide this symbol needs
				   SUB   BYTE PTR[SYMLIN],AL
				   JNC   WRTSYM      ;Will it fit?
				   SUB   AL,SYMWID
				   NEG   AL
				   MOV   BYTE PTR[SYMLIN],AL
				   CALL  CRLF     ;Start new line if not
				WRTSYM:
				   MOV   AL,[EBX]
				   INC   EBX
				   CALL  LIST
				   DEC   CH
				   JNZ   WRTSYM
				   INC   CL
				TABVAL:
				   MOV   AL,9
				   CALL  LIST
				   LOOP  TABVAL
				   INC   EBX
				   INC   EBX
				   PUSH  EBX
				   MOV   AL,[EBX+4]
				   CALL  PHEX
				   MOV   AL,[EBX+3]
				   CALL  PHEX
				   CMP   BYTE PTR[SYMLIN],0 ;Will any more fit on line?
				   JZ NEXSYMLIN
				   MOV   AL,9
				   CALL  LIST
				   JMP RIGHTSON
				NEXSYMLIN:
				   CALL  CRLF
				   MOV   BYTE PTR[SYMLIN],SYMWID
				RIGHTSON:
				   POP   EBX
				   MOV   EDX,[EBX]
				   OR EDX,EDX
				   JNZ   NODE
				   RET
				
				SAVCD:
				   MOV   BYTE PTR[PREV],AL
				   PUSH  EBX
				   PUSH  ECX
				   PUSH  EAX
				   PUSH  EDX
				   CALL  CODBYT
				   POP   EDX
				   MOV   EBX,COUNT
				   INC   BYTE PTR[EBX]
				   MOV   AL,[EBX]
				   CMP   AL,8
				   JNZ   NOEXT
				   MOV   BYTE PTR[EBX],1
				   CALL  OUTLIN
				   MOV   AL,' '
				   MOV   CH,5
				TAB:
				   CALL  LIST
				   DEC   CH
				   JNZ   TAB
				NOEXT:
				   POP   EAX
				   CALL  PHEXB
				   POP   ECX
				   INC   DWORD PTR[PC]
				   INC   DWORD PTR[HEXADD]
				   POP   EBX
				NOEXT_RET:
				   RET
				
				REPERR:
				   OR AL,AL    ;Did an error occur?
				   JZ NOEXT_RET
				   INC   DWORD PTR[ERRCNT]
				   PUSH  EAX
				   MOV   EBX,OFFSET _ERRMES   ;Print "ERROR"
				   CALL  PRINT
				   POP   EAX
				;We have error number in AL. See if there's an error message for it
				   MOV   EDI,ERRTAB
				   MOV   BL,80H
				ERRLOOK:
				   SCASB       ;Do we have the error message
				   JBE   HAVMES      ;Quit looking if we have it or passed it
				   XCHG  EAX,EBX    ;Put 80H in AL to look for end of this message
				NEXTMES:
				   SCASB       ;Look for high bit set in message
				   JA NEXTMES     ;   which means we've reached the end
				   XCHG  EAX,EBX    ;Restore error number to AL
				   JMP   ERRLOOK     ;Keep looking
				
				HAVMES:
				   MOV   EBX,EDI    ;Put address of message in EBX
				   JZ PRNERR      ;Do we have a message for this error?
				   CALL  PHEX     ;If not, just print error number
				   JMP   CRLF
				
				PRNERR:
				   CALL  PRINT
				   JMP   CRLF
				
				PRINT:
				   MOV   AL,[EBX]
				   CALL  LIST
				   OR AL,AL
				   JS SYSTEM_RET
				   INC   EBX
				   JMP PRINT
				
				OUTA:
				   MOV   DL,AL
				_OUT:
				   AND   DL,7FH
				   MOV   CL,2
				SYSTEM:
				   ;CALL  5
				SYSTEM_RET:
				   RET
				
				CODBYT:
				   PUSH  EAX
				   MOV   EDX,[LASTAD]
				   MOV   EBX,[HEXADD]
				   MOV   [LASTAD],EBX
				   INC   EDX
				   MOV   AL,BYTE PTR[HEXCNT]
				   CMP   AL,-5
				   JZ NEWLIN
				   CMP   EBX,EDX
				   JZ AFHEX
				   CALL  ENHEXL
				NEWLIN:
				   MOV   AL,':'
				   CALL  PUTCHR
				   MOV   AL,-4
				   MOV   BYTE PTR[HEXCNT],AL
				   XOR   AL,AL
				   MOV   BYTE PTR[CHKSUM],AL
				   MOV   EBX,[HEXPNT]
				   MOV   [HEXLEN],EBX
				   CALL  HEXBYT
				   MOV   AL,BYTE PTR[HEXADD+1]
				   CALL  HEXBYT
				   MOV   AL,BYTE PTR[HEXADD]
				   CALL  HEXBYT
				   XOR   AL,AL
				   CALL  HEXBYT
				AFHEX:
				   POP   EAX
				HEXBYT:
				   MOV   CH,AL
				   MOV   EBX,CHKSUM
				   ADD   AL,[EBX]
				   MOV   [EBX],AL
				   MOV   AL,CH
				   CALL  UHALF
				   CALL  PUTCHR
				   MOV   AL,CH
				   CALL  LHALF
				   CALL  PUTCHR
				   MOV   EBX,HEXCNT
				   INC   BYTE PTR[EBX]
				   MOV   AL,[EBX]
				   CMP   AL,26
				   JNZ   WRTHEX_RET
				ENHEXL:
				   MOV   EDI,[HEXLEN]
				   MOV   CH,AL
				   CALL  UHALF
				   STOSB
				   MOV   AL,CH
				   CALL  LHALF
				   STOSB
				   MOV   AL,-6
				   MOV   BYTE PTR[HEXCNT],AL
				   MOV   AL,BYTE PTR[CHKSUM]
				   ADD   AL,CH
				   NEG   AL
				   CALL  HEXBYT
				   MOV   AL,13
				   CALL  PUTCHR
				   MOV   AL,10
				   CALL  PUTCHR
				WRTHEX:
				;Write out the line
				   MOV   EDX,OFFSET HEXBUF
				   MOV   [HEXPNT],EDX
				   SUB   EDI,EDX    ;Length of buffer
				   MOV   ECX,EDI
				
				   PUSH  [HEXFILE]
				   PUSH  ECX
				   PUSH  1
				   PUSH  EDX
				   CALL  _fwrite
				   ADD   ESP,16
				
				   OR AL,AL
				   JNZ   DSKFUL
				WRTHEX_RET:
				   RET
				
				PUTCHR:
				   MOV   EDI,[HEXPNT]
				   STOSB
				   MOV   [HEXPNT],EDI
				   RET
				
				FLUSHBUF: ;EDI FLUSH SIZE
				   MOV   ECX,EDI
				   MOV   EDX,OFFSET LSTBUF
				   MOV   EDI,EDX
				   SUB   ECX,EDX
				   JZ LHALF_RET      ;Buffer empty?
				
				   PUSH [LSTFILE]
				   PUSH  ECX
				   PUSH  1
				   PUSH  EDX
				   CALL _fwrite
				   ADD   ESP,16
				   OR AL,AL
				   JNZ LHALF_RET
				DSKFUL:
				   MOV   EBX,OFFSET WRTERR
				   JMP   PRERR
				
				UHALF:
				   RCR   AL,1
				   RCR   AL,1
				   RCR   AL,1
				   RCR   AL,1
				LHALF:
				   AND   AL,0FH
				   OR AL,30H
				   CMP   AL,'9'+1
				   JC LHALF_RET
				   ADD   AL,7
				LHALF_RET:
				   RET
				
 2B62				CODESEG ENDS
				
 0000				DATASEG SEGMENT "DATA" PUBLIC
				
				NONE DB 0
				
				; 8086 MNEMONIC TABLE
				
				; This table is actually a sequence of subtables, each starting with a label.
				; The label signifies which mnemonics the subtable applies to--A3, for example,
				; means all 3-letter mnemonics beginning with A.
				
				A3:
				   DB 7     ;items count
				   DB 'dd'  ;chars following 'a''
				   DD OFFSET GRP7  ;handler
				   DB 2		;opcode or count of operand
				   DB 'nd'
				   DD OFFSET GRP13
				   DB 22H
				   DB 'dc'
				
				   DD OFFSET GRP7
				   DB 12H
				   DB 'aa'
				   DD OFFSET PUT
				   DB 37H
				   DB 'as'
				   DD OFFSET PUT
				   DB 3FH
				   DB 'am'
				   DD OFFSET GRP11
				   DB 0D4H ;opcode
				   DB 'ad'
				   DD OFFSET GRP11
				   DB 0D5H	;opcode
				A5:
				   DB 1
				   DB 'lign'
				   DD OFFSET _ALIGN
				   DB 0
				C3:
				   DB 7
				   DB 'mp'
				   DD OFFSET GRP7
				   DB 3AH
				   DB 'lc'
				   DD OFFSET PUT
				   DB 0F8H
				   DB 'ld'
				   DD OFFSET PUT
				   DB 0FCH
				   DB 'li'
				   DD OFFSET PUT
				   DB 0FAH
				   DB 'mc'
				   DD OFFSET PUT
				   DB 0F5H
				   DB 'bw'
				   DD OFFSET PUT
				   DB 98H
				   DB 'wd'
				   DD OFFSET PUT
				   DB 99H
				C4:
				   DB 3
				   DB 'all'
				   DD OFFSET GRP14
				   DB 9AH
				   DB 'mpb'
				   DD OFFSET PUT
				   DB 0A6H
				   DB 'mpw'
				   DD OFFSET PUT
				   DB 0A7H
				C5:
				   DB 2
				   DB 'mpsb'
				   DD OFFSET PUT
				   DB 0A6H
				   DB 'mpsw'
				   DD OFFSET PUT
				   DB 0A7H
				D2:
				   DB 5
				   DB 'b'
				   DD OFFSET GRP23
				   DB 1
				   DB 'w'
				   DD OFFSET GRP23
				   DB 0
				   DB 'm'
				   DD OFFSET GRP23
				   DB 2
				   DB 's'
				   DD OFFSET GRP5
				   DB 1
				   DB 'i'
				   DD OFFSET PUT
				   DB 0FAH
				D3:
				   DB 4
				   DB 'ec'
				   DD OFFSET GRP8
				   DB 49H
				   DB 'iv'
				   DD OFFSET GRP10
				   DB 30H
				   DB 'aa'
				   DD OFFSET PUT
				   DB 27H
				   DB 'as'
				   DD OFFSET PUT
				   DB 2FH
				D4:
				   DB 1
				   DB 'own'
				   DD OFFSET PUT
				   DB 0FDH
				E2:
				   DB 1
				   DB 'i'
				   DD OFFSET PUT
				   DB 0FBH
				E3:
				   DB 3 ;OPERANDS COUNT
				   DB 'qu'
				   DD OFFSET GRP5
				   DB 2
				   DB 'sc'
				   DD OFFSET GRP19
				   DB 0D8H
				   DB 'nd'
				   DD OFFSET _END
				   DB 0
				E5:
				   DB 1
				   DB 'ndif'
				   DD OFFSET _ENDIF
				   DB 0
				H3:
				   DB 1
				   DB 'lt'
				   DD OFFSET PUT
				   DB 0F4H
				H4:
				   DB 1
				   DB 'alt'
				   DD OFFSET PUT
				   DB 0F4H
				I2:
				   DB 2
				   DB 'n'
				   DD OFFSET GRP4
				   DB 0E4H
				   DB 'f'
				   DD OFFSET GRP5
				   DB 4
				I3:
				   DB 4
				   DB 'nc'
				   DD OFFSET GRP8
				   DB 41H
				   DB 'nb'
				   DD OFFSET GRP4
				   DB 0E4H
				   DB 'nw'
				   DD OFFSET GRP4
				   DB 0E5H
				   DB 'nt'
				   DD OFFSET GRP18
				   DB 0CCH
				I4:
				   DB 4
				   DB 'mul'
				   DD OFFSET GRP10
				   DB 28H
				   DB 'div'
				   DD OFFSET GRP10
				   DB 38H
				   DB 'ret'
				   DD OFFSET PUT
				   DB 0CFH
				   DB 'nto'
				   DD OFFSET PUT
				   DB 0CEH
				J2:
				   DB 10
				   DB 'p'
				   DD OFFSET GRP17
				   DB 0EBH
				   DB 'z'
				   DD OFFSET GRP17
				   DB 74H
				   DB 'e'
				   DD OFFSET GRP17
				   DB 74H
				   DB 'l'
				   DD OFFSET GRP17
				   DB 7CH
				   DB 'b'
				   DD OFFSET GRP17
				   DB 72H
				   DB 'a'
				   DD OFFSET GRP17
				   DB 77H
				   DB 'g'
				   DD OFFSET GRP17
				   DB 7FH
				   DB 'o'
				   DD OFFSET GRP17
				   DB 70H
				   DB 's'
				   DD OFFSET GRP17
				   DB 78H
				   DB 'c'
				   DD OFFSET GRP17
				   DB 72H
				J3:
				   DB 17
				   DB 'mp'
				   DD OFFSET GRP14
				   DB 0EAH
				   DB 'nz'
				   DD OFFSET GRP17
				   DB 75H
				   DB 'ne'
				   DD OFFSET GRP17
				   DB 75H
				   DB 'nl'
				   DD OFFSET GRP17
				   DB 7DH
				   DB 'ge'
				   DD OFFSET GRP17
				   DB 7DH
				   DB 'nb'
				   DD OFFSET GRP17
				   DB 73H
				   DB 'ae'
				   DD OFFSET GRP17
				   DB 73H
				   DB 'nc'
				   DD OFFSET GRP17
				   DB 73H
				   DB 'ng'
				   DD OFFSET GRP17
				   DB 7EH
				   DB 'le'
				   DD OFFSET GRP17
				   DB 7EH
				   DB 'na'
				   DD OFFSET GRP17
				   DB 76H
				   DB 'be'
				   DD OFFSET GRP17
				   DB 76H
				   DB 'pe'
				   DD OFFSET GRP17
				   DB 7AH
				   DB 'np'
				   DD OFFSET GRP17
				   DB 7BH
				   DB 'po'
				   DD OFFSET GRP17
				   DB 7BH
				   DB 'no'
				   DD OFFSET GRP17
				   DB 71H
				   DB 'ns'
				   DD OFFSET GRP17
				   DB 79H
				J4:
				   DB 6
				   DB 'mps'
				   DD OFFSET GRP17
				   DB 0EBH
				   DB 'cxz'
				   DD OFFSET GRP17
				   DB 0E3H
				   DB 'nge'
				   DD OFFSET GRP17
				   DB 7CH
				   DB 'nae'
				   DD OFFSET GRP17
				   DB 72H
				   DB 'nbe'
				   DD OFFSET GRP17
				   DB 77H
				   DB 'nle'
				   DD OFFSET GRP17
				   DB 7FH
				L3:
				   DB 3
				   DB 'ea'
				   DD OFFSET GRP6
				   DB 8DH
				   DB 'ds'
				   DD OFFSET GRP6
				   DB 0C5H
				   DB 'es'
				   DD OFFSET GRP6
				   DB 0C4H
				L4:
				   DB 5
				   DB 'oop'
				   DD OFFSET GRP17
				   DB 0E2H
				   DB 'odb'
				   DD OFFSET PUT
				   DB 0ACH
				   DB 'odw'
				   DD OFFSET PUT
				   DB 0ADH
				   DB 'ahf'
				   DD OFFSET PUT
				   DB 9FH
				   DB 'ock'
				   DD OFFSET PUT
				   DB 0F0H
				L5:
				   DB 4
				   DB 'oope'
				   DD OFFSET GRP17
				   DB 0E1H
				   DB 'oopz'
				   DD OFFSET GRP17
				   DB 0E1H
				   DB 'odsb'
				   DD OFFSET PUT
				   DB 0ACH
				   DB 'odsw'
				   DD OFFSET PUT
				   DB 0ADH
				L6:
				   DB 2
				   DB 'oopne'
				   DD OFFSET GRP17
				   DB 0E0H
				   DB 'oopnz'
				   DD OFFSET GRP17
				   DB 0E0H
				M3:
				   DB 2
				   DB 'ov'
				   DD OFFSET GRP1
				   DB 88H
				   DB 'ul'
				   DD OFFSET GRP10
				   DB 20H
				M4:
				   DB 2
				   DB 'ovb'
				   DD OFFSET PUT
				   DB 0A4H
				   DB 'ovw'
				   DD OFFSET PUT
				   DB 0A5H
				M5:
				   DB 2
				   DB 'ovsb'
				   DD OFFSET PUT
				   DB 0A4H
				   DB 'ovsw'
				   DD OFFSET PUT
				   DB 0A5H
				N3:
				   DB 3
				   DB 'ot'
				   DD OFFSET GRP9
				   DB 10H
				   DB 'eg'
				   DD OFFSET GRP9
				   DB 18H
				   DB 'op'
				   DD OFFSET PUT
				   DB 90H
				O2:
				   DB 1
				   DB 'r'
				   DD OFFSET GRP13
				   DB 0AH
				O3:
				   DB 2
				   DB 'ut'
				   DD OFFSET GRP4
				   DB 0E6H
				   DB 'rg'
				   DD OFFSET GRP5
				   DB 0
				O4:
				   DB 2
				   DB 'utb'
				   DD OFFSET GRP4
				   DB 0E6H
				   DB 'utw'
				   DD OFFSET GRP4
				   DB 0E7H
				P3:
				   DB 2
				   DB 'op'
				   DD OFFSET GRP22
				   DB 8FH
				   DB 'ut'
				   DD OFFSET GRP5
				   DB 3
				P4:
				   DB 2
				   DB 'ush'
				   DD OFFSET GRP2
				   DB 0FFH
				   DB 'opf'
				   DD OFFSET PUT
				   DB 9DH
				P5:
				   DB 1
				   DB 'ushf'
				   DD OFFSET PUT
				   DB 9CH
				R3:
				   DB 6
				   DB 'et'
				   DD OFFSET GRP16
				   DB 0C3H
				   DB 'ep'
				   DD OFFSET PUT
				   DB 0F3H
				   DB 'ol'
				   DD OFFSET GRP12
				   DB 0
				   DB 'or'
				   DD OFFSET GRP12
				   DB 8
				   DB 'cl'
				   DD OFFSET GRP12
				   DB 10H
				   DB 'cr'
				   DD OFFSET GRP12
				   DB 18H
				R4:
				   DB 2
				   DB 'epz'
				   DD OFFSET PUT
				   DB 0F3H
				   DB 'epe'
				   DD OFFSET PUT
				   DB 0F3H
				R5:
				   DB 2
				   DB 'epnz'
				   DD OFFSET PUT
				   DB 0F2H
				   DB 'epne'
				   DD OFFSET PUT
				   DB 0F2H
				S3:
				   DB 11
				   DB 'ub'
				   DD OFFSET GRP7
				   DB 2AH
				   DB 'bb'
				   DD OFFSET GRP7
				   DB 1AH
				   DB 'bc'
				   DD OFFSET GRP7
				   DB 1AH
				   DB 'tc'
				   DD OFFSET PUT
				   DB 0F9H
				   DB 'td'
				   DD OFFSET PUT
				   DB 0FDH
				   DB 'ti'
				   DD OFFSET PUT
				   DB 0FBH
				   DB 'hl'
				   DD OFFSET GRP12
				   DB 20H
				   DB 'hr'
				   DD OFFSET GRP12
				   DB 28H
				   DB 'al'
				   DD OFFSET GRP12
				   DB 20H
				   DB 'ar'
				   DD OFFSET GRP12
				   DB 38H
				   DB 'eg'
				   DD OFFSET GRP21
				   DB 26H
				S4:
				   DB 5
				   DB 'cab'
				   DD OFFSET PUT
				   DB 0AEH
				   DB 'caw'
				   DD OFFSET PUT
				   DB 0AFH
				   DB 'tob'
				   DD OFFSET PUT
				   DB 0AAH
				   DB 'tow'
				   DD OFFSET PUT
				   DB 0ABH
				   DB 'ahf'
				   DD OFFSET PUT
				   DB 9EH
				S5:
				   DB 4
				   DB 'casb'
				   DD OFFSET PUT
				   DB 0AEH
				   DB 'casw'
				   DD OFFSET PUT
				   DB 0AFH
				   DB 'tosb'
				   DD OFFSET PUT
				   DB 0AAH
				   DB 'tosw'
				   DD OFFSET PUT
				   DB 0ABH
				T4:
				   DB 1
				   DB 'est'
				   DD OFFSET GRP20
				   DB 84H
				U2:
				   DB 1
				   DB 'p'
				   DD OFFSET PUT
				   DB 0FCH
				W4:
				   DB 1
				   DB 'ait'
				   DD OFFSET PUT
				   DB 9BH
				X3:
				   DB 1
				   DB 'or'
				   DD OFFSET GRP13
				   DB 32H
				X4:
				   DB 2
				   DB 'chg'
				   DD OFFSET GRP3
				   DB 86H
				   DB 'lat'
				   DD OFFSET PUT
				   DB 0D7H
				
				
				; 8087 MNEMONIC TABLE
				; Similar to 8086 table above, except NOT distinguished by opcode length
				
				XM1:	;F2XM1
					DB	1		;One opcode
					DB	"xm", '1'+ 080H
					DB	1,0F0H
				
				NDPA:
					DB	3
					DB	"d", 'd'+ 080H
					DB	6+ARITH,0C1H
					DB	"dd", 'p'+ 080H
					DB	NEEDOP+STACKOP,0
					DB	"b", 's'+ 080H
					DB	1,0E1H
				
				NDPB:
					DB	2
					DB	"l", 'd'+ 080H
					DB	7+NEEDOP+MEMORY,20H
					DB	"st", 'p'+ 080H
					DB	7+NEEDOP+MEMORY,30H
				
				NDPC:
					DB	5
					DB	"o", 'm'+ 080H
					DB	0+ONEREG+REAL,0D1H
					DB	"om", 'p'+ 080H
					DB	0+ONEREG+REAL,0D9H
					DB	"h", 's'+ 080H
					DB	1,0E0H
					DB	"omp", 'p'+ 080H
					DB	6,0D9H
					DB	"le", 'x'+ 080H
					DB	3,0E2H
				
				NDPD:
					DB	6
					DB	"i", 'v'+ 080H
					DB	6+ARITH,0F1H
					DB	"iv", 'p'+ 080H
					DB	NEEDOP+STACKOP,30H
					DB	"iv", 'r'+ 080H
					DB	6+ARITH,0F9H
					DB	"ivr", 'p'+ 080H
					DB	NEEDOP+STACKOP,38H
					DB	"ecst", 'p'+ 080H
					DB	1,0F6H
					DB	"is", 'i'+ 080H
					DB	3,0E1H
				
				NDPE:
					DB	1
					DB	"n", 'i'+ 080H
					DB	3,0E0H
				
				NDPF:
					DB	1
					DB	"re", 'e'+ 080H
					DB	5+NEEDOP+ONEREG,0
				
				NDPI:
					DB	13
					DB	"ad", 'd'+ 080H
					DB	2+NEEDOP+INTEGER,0
					DB	"l", 'd'+ 080H
					DB	3+NEEDOP+INTEGER+EXTENDED,0
					DB	"su", 'b'+ 080H
					DB	2+NEEDOP+INTEGER,20H
					DB	"st", 'p'+ 080H
					DB	3+NEEDOP+INTEGER+EXTENDED,18H
					DB	"s", 't'+ 080H
					DB	3+NEEDOP+INTEGER,10H
					DB	"mu", 'l'+ 080H
					DB	2+NEEDOP+INTEGER,8
					DB	"di", 'v'+ 080H
					DB	2+NEEDOP+INTEGER,30H
					DB	"sub", 'r'+ 080H
					DB	2+NEEDOP+INTEGER,28H
					DB	"div", 'r'+ 080H
					DB	2+NEEDOP+INTEGER,38H
					DB	"co", 'm'+ 080H
					DB	2+NEEDOP+INTEGER,10H
					DB	"com", 'p'+ 080H
					DB	2+NEEDOP+INTEGER,18H
					DB	"ncst", 'p'+ 080H
					DB	1,0F7H
					DB	"ni", 't'+ 080H
					DB	3,0E3H
				
				NDPL:
					DB	10
					DB	'd' + 080H
					DB	1+NEEDOP+ONEREG+REAL+EXTENDED,0
					DB	"d", 'z'+ 080H
					DB	1,0EEH
					DB	"d", '1'+ 080H
					DB	1,0E8H
					DB	"dp", 'i'+ 080H
					DB	1,0EBH
					DB	"dl2", 't'+ 080H
					DB	1,0E9H
					DB	"dl2", 'e'+ 080H
					DB	1,0EAH
					DB	"dlg", '2'+ 080H
					DB	1,0ECH
					DB	"dln", '2'+ 080H
					DB	1,0EDH
					DB	"dc", 'w'+ 080H
					DB	1+NEEDOP+MEMORY,28H
					DB	"den", 'v'+ 080H
					DB	1+NEEDOP+MEMORY,20H
				
				NDPM:
					DB	2
					DB	"u", 'l'+ 080H
					DB	6+ARITH,0C9H
					DB	"ul", 'p'+ 080H
					DB	NEEDOP+STACKOP,8
				
				NDPO:
					DB	1
					DB	'p' + 080H
					DB	NEEDOP+1,0	;Flag special handling
				
				NDPN:
					DB	1
					DB	"o", 'p'+ 080H
					DB	1,0D0H
				
				NDPP:
					DB	3
					DB	"re", 'm'+ 080H
					DB	1,0F8H
					DB	"ta", 'n'+ 080H
					DB	1,0F2H
					DB	"ata", 'n'+ 080H
					DB	1,0F3H
				
				NDPR:
					DB	2
					DB	"ndin", 't'+ 080H
					DB	1,0FCH
					DB	"sto", 'r'+ 080H
					DB	5+NEEDOP+MEMORY,20H
				
				NDPS:
					DB	12
					DB	't' + 080H
					DB	5+NEEDOP+ONEREG+REAL,0D0H
					DB	"t", 'p'+ 080H
					DB	7+NEEDOP+ONEREG+REAL+EXTENDED,0D8H
					DB	"u", 'b'+ 080H
					DB	6+ARITH,0E1H
					DB	"ub", 'p'+ 080H
					DB	NEEDOP+STACKOP,0E0H
					DB	"ub", 'r'+ 080H
					DB	6+ARITH,0E9H
					DB	"ubr", 'p'+ 080H
					DB	NEEDOP+STACKOP,0E8H
					DB	"qr", 't'+ 080H
					DB	1,0FAH
					DB	"cal", 'e'+ 080H
					DB	1,0FDH
					DB	"av", 'e'+ 080H
					DB	5+NEEDOP+MEMORY,30H
					DB	"tc", 'w'+ 080H
					DB	1+NEEDOP+MEMORY,38H
					DB	"ten", 'v'+ 080H
					DB	1+NEEDOP+MEMORY,30H
					DB	"ts", 'w'+ 080H
					DB	5+NEEDOP+MEMORY,38H
				
				NDPT:
					DB	1
					DB	"s", 't'+ 080H
					DB	1,0E4H
				
				NDPW:
					DB	1
					DB	"ai", 't'+ 080H
					DB	NEEDOP,0	;Flag special handling
				
				NDPX:
					DB	3
					DB	"c", 'h'+ 080H
					DB	1+ONEREG,0C9H
					DB	"a", 'm'+ 080H
					DB	1,0E5H
					DB	"trac", 't'+ 080H
					DB	1,0F4H
				
				NDPY:
					DB	2
					DB	"l2", 'x'+ 080H
					DB	1,0F1H
					DB	"l2xp", '1'+ 080H
					DB	1,0F9H
				
				ALIGN 4
				OPTAB:
				; Table of pointers  to mnemonics. For each letter of the alphabet (the
				; starting letter of the mnemonic), there are 5 entries. Each entry
				; corresponds to a mnemonic whose length is 2, 3, 4, 5, and 6 characters
				; long, respectively. If there are no mnemonics for a given combination
				; of first letter and length (such as A-2), then the corresponding entry
				; points to NONE. Otherwise, it points to a place in the mnemonic table
				; for that type.
				
				; This table only needs to be modified if a mnemonic is added to a group
				; previously marked NONE. Change the NONE to a label made up of the first
				; letter of the mnemonic and its length, then add a new subsection to
				; the mnemonic table in alphabetical order.
				
				   DD OFFSET NONE  ;A2
				   DD OFFSET A3    ;A3
				   DD OFFSET NONE  ;A4
				   DD OFFSET A5    ;A5
				   DD OFFSET NONE  ;B1
				   DD OFFSET NONE  ;B2
				   DD OFFSET NONE  ;B3
				   DD OFFSET NONE  ;B4
				   DD OFFSET NONE  ;B5
				   DD OFFSET NONE  ;C1
				   DD OFFSET NONE  ;C2
				   DD OFFSET C3    ;C3
				   DD OFFSET C4    ;C4
				   DD OFFSET C5    ;C5
				   DD OFFSET NONE  ;D1
				   DD OFFSET D2    ;D2
				   DD OFFSET D3    ;D3
				   DD OFFSET D4    ;D4
				   DD OFFSET NONE  ;D5
				   DD OFFSET NONE  ;E1
				   DD OFFSET E2    ;E2
				   DD OFFSET E3    ;E3
				   DD OFFSET NONE  ;E4
				   DD OFFSET E5    ;E5
				   DD OFFSET NONE
				   DD OFFSET NONE  ;F
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;G
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;H
				   DD OFFSET H3
				   DD OFFSET H4
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET I2 ;I
				   DD OFFSET I3
				   DD OFFSET I4
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET J2 ;J
				   DD OFFSET J3
				   DD OFFSET J4
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;K
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;L
				   DD OFFSET L3
				   DD OFFSET L4
				   DD OFFSET L5
				   DD OFFSET L6
				   DD OFFSET NONE  ;M
				   DD OFFSET M3
				   DD OFFSET M4
				   DD OFFSET M5
				   DD OFFSET NONE
				   DD OFFSET NONE  ;N
				   DD OFFSET N3
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET O2 ;O
				   DD OFFSET O3
				   DD OFFSET O4
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;P
				   DD OFFSET P3
				   DD OFFSET P4
				   DD OFFSET P5
				   DD OFFSET NONE
				   DD OFFSET NONE  ;Q
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;R
				   DD OFFSET R3
				   DD OFFSET R4
				   DD OFFSET R5
				   DD OFFSET NONE
				   DD OFFSET NONE  ;S
				   DD OFFSET S3
				   DD OFFSET S4
				   DD OFFSET S5
				   DD OFFSET NONE
				   DD OFFSET NONE  ;T
				   DD OFFSET NONE
				   DD OFFSET T4
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET U2 ;U
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;V
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;W
				   DD OFFSET NONE
				   DD OFFSET W4
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;X
				   DD OFFSET X3
				   DD OFFSET X4
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;Y
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE  ;Z
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				   DD OFFSET NONE
				ALIGN 4
				NDPTAB:
				;Lookup table for 8087 mnemonics. There is one entry for each letter of the
				;alphabet
				   DD OFFSET NDPA
				   DD OFFSET NDPB
				   DD OFFSET NDPC
				   DD OFFSET NDPD
				   DD OFFSET NDPE
				   DD OFFSET NDPF
				   DD OFFSET NONE  ;G
				   DD OFFSET NONE  ;H
				   DD OFFSET NDPI
				   DD OFFSET NONE  ;J
				   DD OFFSET NONE  ;K
				   DD OFFSET NDPL
				   DD OFFSET NDPM
				   DD OFFSET NDPN
				   DD OFFSET NDPO
				   DD OFFSET NDPP
				   DD OFFSET NONE  ;Q
				   DD OFFSET NDPR
				   DD OFFSET NDPS
				   DD OFFSET NDPT
				   DD OFFSET NONE  ;U
				   DD OFFSET NONE  ;V
				   DD OFFSET NDPW
				   DD OFFSET NDPX
				   DD OFFSET NDPY
				   DD OFFSET NONE  ;Z
				
				;Error message table
				
				;Error message table
				
				ERRTAB:
					DB	1, "Register not allowed in immediate valu", 'e'+ 080H
					DB	2, "Index or base register must be BP, BX, SI, or D", 'I'+ 080H
					DB	3, "Only one base register (BX, BP) allowe", 'd'+ 080H
					DB	4, "Only one index register (SI or DI) allowe", 'd'+ 080H
					DB	5, "Only addition allowed on register or undefined labe", 'l'+ 080H
					DB	6, "Only one undefined label per expression allowe", 'd'+ 080H
					DB	7, "Illegal digit in hexadecimal numbe", 'r'+ 080H
					DB	8, "Illegal digit in decimal numbe", 'r'+ 080H
					DB	10, "Illegal character in label or opcod", 'e'+ 080H
					DB	11, "Label defined twic", 'e'+ 080H
					DB	12, "Opcode not recognize", 'd'+ 080H
					DB	20, "Invalid operan", 'd'+ 080H
					DB	21, '", " and second operand expected'
					DB	22, "Register mismatc", 'h'+ 080H
					DB	23, "Immediate operand not allowe", 'd'+ 080H
					DB	24, '"]" expecte', 'd'+ 080H
					DB	25, "Two memory operands not allowe", 'd'+ 080H
					DB	26, "Destination must not be immediate valu", 'e'+ 080H
					DB	27, "Both operands must not be register", 's'+ 080H
					DB	28, "Operand must be segment registe", 'r'+ 080H
					DB	29, "First operand must be registe", 'r'+ 080H
					DB	30, "Undefined label not allowe", 'd'+ 080H
					DB	31, "Value out of rang", 'e'+ 080H
					DB	32, "Missing or illegal operand size fla", 'g'+ 080H
					DB	33, "Must have label on same lin", 'e'+ 080H
					DB	35, "Zero-length string illega", 'l'+ 080H
					DB	36, "ENDIF without I", 'F'+ 080H
					DB	37, "One-character strings onl", 'y'+ 080H
					DB	38, "Illegal expressio", 'n'+ 080H
					DB	39, "End of string not foun", 'd'+ 080H
					DB	100, "Undefined labe", 'l'+ 080H
					DB	101, "Value out of range (forward", ')'+ 080H
					DB	255
				
				_ERRMES	DB	'***** ERROR: ',0A0H
				NOSPAC	DB	13,10,'File creation error',13,10,"$"
				NOMEM	DB	13,10,'Insufficient memory',13,10,'$'
				NOFILE	DB	13,10,'File not found',13,10,'$'
				WRTERR	DB	13,10,'Disk full',13,10,'$'
				BADDSK	DB	13,10,'Bad disk specifier',13,10,'$'
				ERCNTM	DB	13, 10, 13, 10, 'Error Count ', '='+ 080H
				SYMSIZE	DB	13, 10, 'Symbol Table size =', ' '+ 080H
				FRESIZE	DB	'Free space =       ', ' '+ 080H
				SYMMES	DB	13, 10, 'Symbol Tabl', 'e'+ 080H, 13, 10, 13, 10
				EXTEND	DB	'.ASM',0,0
				IFEND	DB	5,'endif'
				IFNEST	DB	2,'if'
				RETSTR	DB	're', 't'+ 080H
				;NOTICE: should use rb to make length correct
				OPEN_FLAG  DB 'rb',0
				WRITE_FLAG DB 'wb',0
				
				REGTAB  DB 'bdca'
				SEGTAB  DB 'dsce'
				
				SRCNAME  DB (NAME_LENGTH + 2) DUP(0)
				
				SRCNAME_LENGTH DD 0
				SRCLENGTH DD 0
				SRCFILE  DD 0
				HEXFILE  DD 0
				LSTFILE  DD 0
				
				HEXNAME  DB (NAME_LENGTH + 2) DUP(0)
				
				LSTNAME  DB (NAME_LENGTH + 2) DUP(0)
				ALIGN 4
				MAXFLG  DB 0
				FLAG    DB 0
				;4+80
				LENID   DD 0	;USE 4 BYTES
				ID      DB 80 DUP(0)
				ALIGN 4
				PC      DD 0
				OLDPC   DD 0
				LABPT   DD 0
				_ADDR    DD 0
				ALABEL  DD 0
				_DATA   DD 0
				DLABEL  DD 0
				CON     DD 0
				UNDEF   DD 0
				CHR     DB -1
				SYM     DB 0
				BASE    DD 0
				_HEAP   DD 0
				SYMLIN  DD 0
				CODE    DD 0
				DATSIZ  DB 0
				RELOC   DD 0
				BCOUNT  DD 0
				COUNT   DD 0
				_ERR    DD 0
				LINE    DD 0
				HEXLEN  DD 0
				HEXADD  DD 0
				LASTAD  DD 0
				HEXCNT  DD 0
				CHKSUM  DD 0
				LINFLG  DD 0
				PREV    DD 0
				IFFLG   DB 0
				CHKLAB  DB 0
				ERRCNT  DD 0
				LSTRET  DD 0
				RETPT   DD 0
				LSTDEV  DD 0
				SPC     DD 0
				NOWAIT  DD 0
				IX      DD 0
				IY      DD 0
				HEXPNT  DD 0
				LSTPNT  DD 0
				STACK_  DD 0
				LINE_COUNT DD 1
				CHAR_LOCATION DD 0
				LAST_READ_CHAR_COUNT DD 0
				TOTAL_READ_CHAR_COUNT DD 0
				SRCBUF_COUNT DD 0
				HEXBUF  DB HEXBUFSIZ DUP(0)
				LSTBUF  DB BUFSIZ DUP(0)
				ALIGN 4
				BUFPT   DD 0
				SRCBUF  DB BUFSIZ DUP(0)
						DD 0
				        DB 100H DUP(0)
				ALIGN 4
				CODE_START: 
						DB 100H DUP(0)
				;1M
				HEAP_START: 
						DB 100H DUP(0)
				
 1C92				DATASEG ENDS
						END
Microsoft (R) Macro Assembler Version 14.44.35221.0	    12/05/25 19:37:33
ASM32.ASM						     Page 1 - 1


				; Seattle Computer Products 8086 Assembler  version 2.44
				;   by Tim Paterson
				; Runs on the 8086 under MS-DOS

				;* * * * * * REVISION HISTORY * * * * * *
				;
				; 12/29/80  2.01  General release with 86-DOS version 0.34
				; 02/22/81  2.10  Increased buffer size from 128 bytes to 1024 bytes
				; 03/18/81  2.11  General cleanup and more documentation
				; 03/24/81  2.20  Modify ESC handling for full 8087 operation
				; 04/01/81  2.21  Fix date in HEX and PRN files; modify buffer handling
				; 04/03/81  2.22  Fix 2.21 buffer handling
				; 04/13/81  2.23  Re-open source file for listing to allow assembling CON:
				; 04/28/81  2.24  Allow nested IFs
				; 07/30/81  2.25  Add Intel string mnemonics; clean up a little
				; 08/02/81  2.30  Re-write pass 2:
				;        Always report errors to console
				;        Exact byte lengths for HEX and PRN files
				; 11/08/81  2.40  Add 8087 mnemonics; print full error messages;
				;       allow expressions with *, /, and ()
				; 07/04/82  2.41  Fix Intel's 8087 "reverse-bit" bug; don't copy date
				; 08/18/82  2.42  Increase stack from 80 to 256 (Damn! Overflowed again!)
				; 01/05/83  2.43  Correct over-zealous optimization in 2.42
				; 05/09/83  2.44  Add memory usage report
				;
				;* * * * * * * * * * * * * * * * * * * * *

 = 0005				SYMWID   EQU   5  ;5 symbols per line in dump
 = 0400				BUFSIZ   EQU   1024  ;Source code buffer
 = BUFSIZ			LSTBUFSIZ   EQU   BUFSIZ   ;List file buffer
 = 0046				HEXBUFSIZ   EQU   70 ;Hex file buffer (26*2 + 5*2 + 3 + EXTRA)
 = 000D				EOL      EQU   13 ;\r=13 ASCII carriage return
 = 000A				NEL		 EQU   10 ;\n=10 ASCII new line
 = 0100				OBJECT   EQU   100H  ;DEFAULT "PUT" ADDRESS
 = 0104				NAME_LENGTH EQU 260 ;Maximum length of file name

				;The following equates define some token values returned by GETSYM
 = 0000				UNDEFID  EQU   0  ;Undefined identifier (including no nearby RET)
 = 0001				CONST EQU   1  ;Constant (including $)
 = 0002				REG      EQU   2  ;8-bit register
 = 0003				XREG  EQU   3  ;16-bit register (except segment registers)
 = 0004				SREG  EQU   4  ;Segment register
 = 0006				FREG  EQU   6  ;8087 floating point register
 = 0080				NODESIZE EQU 80H ;128
				;Bits to build 8087 opcode table entries
 = 0040				ONEREG   EQU   40H   ;Single ST register OK as operand
 = 0080				NEEDOP   EQU   80H   ;Must have an operand
 = 0020				INTEGER  EQU   20H   ;For integer operations
 = 0028				REAL  EQU   28H   ;For real operations
 = 0010				EXTENDED EQU   10H   ;For Long integers or Temporary real
 = 0018				MEMORY   EQU   18H   ;For general memory operations
 = 0010				STACKOP  EQU   10H   ;Two register arithmetic with pop
 = 0008				ARITH EQU   8  ;Non-pop arithmetic operations
 = 0000				SEEK_SET EQU 0
 = 0001				SEEK_CUR EQU 1
 = 0002				SEEK_END EQU 2

				ASSUME CS:CODESEG,DS:DATASEG
 0000				CODESEG SEGMENT "CODE" PUBLIC

				PUBLIC _ASM32_ENTRY@8

				EXTERN _cprintf :PROC
				EXTERN _fopen :PROC
				EXTERN _fread :PROC
				EXTERN _fwrite :PROC
				EXTERN _fclose :PROC
				EXTERN _feof :PROC
				EXTERN _fseek :PROC
				EXTERN _ftell :PROC
				    ;int argc, char* argv[]
				    ;ecx, eax
 0000				_ASM32_ENTRY@8:
 0000  66| 89 26 111D R		   MOV   [STACK_],ESP
 0005  67& 66| 8B 44 24		   MOV   EAX,[ESP+4]  ;Get argc
       04
 000B  67& 66| 8B 4C 24		   MOV   ECX,[ESP+8]  ;Get argv pointer
       08

 0011  66| 83 F8 01		   CMP   EAX,1
 0015  7D 06			   JGE   HAS_FILE_NAME
 0017  66| 33 C0		   XOR   EAX,EAX
 001A  66| 48			   DEC   EAX
 001C  C3			   RET

 001D				HAS_FILE_NAME:
				   ;GET NAME LENGTH
 001D  FC			   CLD
 001E  66| 8B D1		   MOV EDX,ECX
 0021  66| 8B FA		   MOV EDI,EDX
 0024  66| 33 C0		   XOR EAX,EAX
 0027  F2/ AE			   REPNZ SCASB
 0029  66| 4F			   DEC EDI
 002B  66| 2B FA		   SUB EDI,EDX
 002E  66| 89 3E 0E14 R		   MOV [SRCNAME_LENGTH],EDI

 0033				COPY_NAME:

 0033  66| 8B F2		   MOV ESI,EDX
 0036  66| BF 00000D0E R	   MOV EDI,OFFSET SRCNAME
 003C  66| 8B 0E 0E14 R		   MOV ECX,[SRCNAME_LENGTH] ;LENGTH
 0041  F3/ A4			   REP MOVSB 
 0043				FIND_DOT:
 0043  FC			   CLD
 0044  66| BF 00000D0E R	   MOV   EDI,OFFSET SRCNAME
 004A  66| 8B 0E 0E14 R		   MOV   ECX,[SRCNAME_LENGTH] ;MAX LENGTH
 004F  66| 03 F9		   ADD   EDI,ECX
 0052  B0 2E			   MOV   AL,'.'
 0054  F2/ AE			   REPNE SCASB    ;Find extion
				   ;EDI points to '.'
 0056  74 22			   JE    DO_OPEN
 0058				NO_DOT:
 0058  66| BF 00000D0E R	   MOV   EDI,OFFSET SRCNAME
 005E  66| 8B 0E 0E14 R		   MOV   ECX,[SRCNAME_LENGTH] ;MAX LENGTH
 0063  66| 03 F9		   ADD   EDI,ECX
 0066  66| BE 00000CEE R	   MOV   ESI,OFFSET EXTEND
 006C  66| B9 00000004		   MOV   ECX,4
 0072  F3/ A4			   REP   MOVSB
 0074  66| 83 06 0E14 R		   ADD   [SRCNAME_LENGTH],4
       04
 007A				DO_OPEN:
				   ;OPEN FILE
 007A  FC			   CLD
 007B  68 0D00 R		   PUSH  OFFSET OPEN_FLAG
 007E  68 0D0E R		   PUSH  OFFSET SRCNAME
 0081  E8 0000 E		   CALL _fopen
 0084  66| 83 C4 08		   ADD   ESP,8
 0088  66| 0B C0		   OR   EAX,EAX
 008B  75 03			   JNZ   OK_FILE
				   ;SAVE FILE HANDLE
 008D  66| 48			   DEC  EAX
 008F  C3			   RET
 0090				OK_FILE:
 0090  66| A3 0E1C R		   MOV   [SRCFILE],EAX
				   ;GET FILE SIZE
 0094  6A 02			   PUSH SEEK_END
 0096  6A 00			   PUSH 0
 0098  66| FF 36 0E1C R		   PUSH [SRCFILE]
 009D  E8 0000 E		   CALL _fseek
 00A0  66| 83 C4 0C		   ADD ESP,12
 00A4  66| FF 36 0E1C R		   PUSH [SRCFILE]
 00A9  E8 0000 E		   CALL _ftell
 00AC  66| 83 C4 04		   ADD ESP,4
 00B0  66| A3 0E18 R		   MOV DWORD PTR[SRCLENGTH],EAX
 00B4  6A 00			   PUSH SEEK_SET
 00B6  6A 00			   PUSH 0
 00B8  66| FF 36 0E1C R   PUSH [SRCFILE]
 00BD  E8 0000 E		   CALL _fseek
 00C0  66| 83 C4 0C		   ADD ESP,12

				   ;SET HEX FILE NAME
 00C4  66| BE 00000D0E R	   MOV   ESI,OFFSET SRCNAME
 00CA  66| 8B 0E 0E14 R		   MOV   ECX,[SRCNAME_LENGTH] ;LENGTH
 00CF  66| BF 00000E28 R	   MOV   EDI,OFFSET HEXNAME ;DESTINATION
 00D5  FC			   CLD
 00D6  F3/ A4			   REP   MOVSB
 00D8  66| BF 00000E28 R	   MOV   EDI,OFFSET  HEXNAME
 00DE  66| 03 3E 0E14 R		   ADD   EDI,[SRCNAME_LENGTH]
 00E3  66| 83 EF 03		   SUB   EDI,3
 00E7  67& C7 07 0048		   MOV   [EDI],'H'
 00EC  66| 47			   INC   EDI
 00EE  67& C7 07 0045		   MOV   [EDI],'E'
 00F3  66| 47			   INC   EDI
 00F5  67& C7 07 0058		   MOV   [EDI],'X'
				   

				   ;SET LST FILE NAME
 00FA  66| BE 00000D0E R	   MOV   ESI,OFFSET SRCNAME
 0100  66| 8B 0E 0E14 R		   MOV   ECX,[SRCNAME_LENGTH];LENGTH
 0105  66| BF 00000F2E R	   MOV   EDI,OFFSET LSTNAME ;DESTINATION
 010B  FC			   CLD
 010C  F3/ A4			   REP   MOVSB
 010E  66| BF 00000F2E R	   MOV   EDI,OFFSET LSTNAME
 0114  66| 03 3E 0E14 R		   ADD   EDI,[SRCNAME_LENGTH]
 0119  66| 83 EF 03		   SUB   EDI,3
 011D  67& C7 07 004C		   MOV   [EDI],'L'
 0122  66| 47			   INC   EDI
 0124  67& C7 07 0053		   MOV   [EDI],'S'
 0129  66| 47			   INC   EDI
 012B  67& C7 07 0054		   MOV   [EDI],'T'
				   
				   ;CREATE OUTPUT FILES
 0130  66| BA 00000E28 R	   MOV   EDX,OFFSET HEXNAME
 0136  E8 00C6			   CALL  CREATE_FILE
 0139  66| A3 0E20 R		   MOV   [HEXFILE],EAX

 013D  66| BA 00000F2E R	   MOV   EDX,OFFSET LSTNAME
 0143  E8 00B9			   CALL  CREATE_FILE
 0146  66| A3 0E24 R		   MOV   [LSTFILE],EAX
				;------------------------------------------------------------------------------
				;Initialize for first pass
 014A  66| 33 C0		   XOR   EAX,EAX

 014D  66| C7 06 157C R		   MOV   DWORD PTR[BUFPT],OFFSET SRCBUF ;Initialize buffer pointer
       00001580 R
 0156  66| C7 06 10BE R		   MOV   DWORD PTR[CODE],OFFSET CODE_START+1 ;POINTER TO NEXT BYTE OF INTERMEDIATE CODE
       00001A85 R
 015F  66| C7 06 1111 R		   MOV   DWORD PTR[IY],OFFSET CODE_START  ;POINTER TO CURRENT RELOCATION BYTE
       00001A84 R

 0168  66| 33 C0		   XOR   EAX,EAX
 016B  66| A3 108C R		   MOV   [PC],EAX     ;DEFAULT PROGRAM COUNTER
 016F  66| A3 10B2 R		   MOV   [BASE],EAX   ;POINTER TO ROOT OF ID TREE=NIL
 0173  66| A3 10FD R		   MOV   [RETPT],EAX  ;Pointer to last RET record
 0177  A2 10F3 R		   MOV   [IFFLG],AL  ;NOT WITHIN IF/ENDIF
 017A  A2 10F4 R		   MOV   [CHKLAB],AL ;LOOKUP ALL LABELS
 017D  66| 48			   DEC   EAX
 017F  66| A3 10F9 R		   MOV   [LSTRET],EAX ;Location of last RET
 0183  66| B8 00001B84 R	   MOV   EAX,HEAP_START
 0189  66| A3 10B6 R		   MOV   [_HEAP],EAX  ;BACK END OF SYMBOL TABLE SPACE
 018D  66| C7 06 10C7 R		   MOV   DWORD PTR[BCOUNT],4  ;CODE BYTES PER RELOCATION BYTE
       00000004
 0196  66| B9 00000400		   MOV   ECX,BUFSIZ
 019C  66| 33 C0		   XOR   EAX,EAX
 019F  66| 48			   DEC   EAX
				;Assemble each line of code
				;------------------------------------------------------------------------------

 01A1				_LOOP:
 01A1  E8 007A			   CALL NEXTCHR
 01A4  3C 1A			   CMP AL,1AH      ;EOF
 01A6  74 1E			   JZ ENDJ           ;FOUND EOF GOTO NEXT PASS
 01A8  B0 FF			   MOV   AL,-1    ;Flag that no tokens have been read yet
 01AA  A2 10B1 R		   MOV   [SYM],AL
 01AD  E8 0869			   CALL  ASMLIN      ;Assemble the line
 01B0  A0 10B1 R		   MOV   AL,[SYM]
 01B3  3C FF			   CMP   AL,-1    ;Any tokens found on line?
 01B5  75 03			   JNZ   L0002
 01B7  E8 046C			   CALL  GETSYM      ;If no tokens read yet, read first one
 01BA				L0002:   
 01BA  3C 3B			   CMP   AL,';'
 01BC  74 0B			   JZ ENDLN
 01BE  3C 0D			   CMP   AL,EOL      ;\r=13, \n=10
 01C0  74 07			   JZ ENDLN
 01C2  3C 14			   CMP   AL,14H      ;Garbage at end of line error
 01C4  EB 05			   JMP ENDLIN
 01C6				ENDJ: 
 01C6  E9 116C			   JMP   _END
 01C9				ENDLN:
 01C9  32 C0			   XOR   AL,AL    ;Flag no errors on line
 01CB				ENDLIN:
				;AL = error code for line. Stack depth unknown
 01CB  66| 8B 26 111D R		   MOV ESP,[STACK_]
 01D0  E8 0002			   CALL  NEXLIN
 01D3  EB CC			   JMP _LOOP

 01D5				NEXLIN:
 01D5  B5 C0			   MOV   CH,0C0H     ;Put end of line marker and error code (AL)
 01D7  E8 0B52			   CALL  PUTCD
 01DA  E8 0B08			   CALL  GEN1
 01DD  A0 10B0 R		   MOV   AL,[CHR]
 01E0				GETEOL:
 01E0  3C 0A			   CMP   AL,10       ;CHR=\r
 01E2  74 09			   JZ NEXLIN_RET
 01E4  3C 1A			   CMP AL,1AH
 01E6  74 DE			   JZ ENDJ
 01E8  E8 0033			   CALL  NEXTCHR     ;Scan over comments for linefeed
 01EB  EB F3			   JMP GETEOL
 01ED				NEXLIN_RET:
 01ED  C3			   RET

 01EE				ABORT:
 01EE  66| BB 00000C51 R	   MOV   EBX,OFFSET NOMEM
 01F4				PRERR:
 01F4  66| 53			   PUSH  EBX
				   ;ERROR PRINT HERE ONLY
 01F6  E8 0000 E		   CALL  _cprintf
 01F9  66| 5B			   POP   EBX
 01FB				QUIT:
 01FB  66| 33 C0		   XOR   EAX,EAX
 01FE  C3			   RET

 01FF				CREATE_FILE:
 01FF  68 0D03 R		   PUSH   OFFSET WRITE_FLAG
 0202  66| 52			   PUSH   EDX
 0204  E8 0000 E		   CALL  _fopen
 0207  66| 83 C4 08		   ADD   ESP,8

 020B  66| 0B C0		   OR     EAX,EAX
 020E  75 09			   JNZ   MAKFIL_RET
 0210  90			   NOP
 0211  66| BB 00000C39 R	   MOV   EBX,OFFSET NOSPAC
 0217  EB DB			   JMP   PRERR
 0219				MAKFIL_RET:
 0219  C3			   RET

 021A				ERROR:
 021A  8A C1			   MOV   AL,CL
 021C  EB AD			   JMP   ENDLIN


 021E				NEXTCHR: ;DONE
 021E  66| 8B 36 157C R		   MOV   ESI,[BUFPT]
 0223  66| 81 FE 00001580 R	   CMP   ESI,OFFSET SRCBUF
 022A  75 2E			   JNZ   GETCH
				;Buffer empty so refill it
 022C  66| 52			   PUSH  EDX
 022E  66| 50			   PUSH  EAX    ;AH must be saved

 0230  66| FF 36 0E1C R		   PUSH  [SRCFILE]
 0235  68 0400			   PUSH  BUFSIZ
 0238  6A 01			   PUSH  1
 023A  66| 56			   PUSH  ESI
 023C  E8 0000 E		   CALL _fread
 023F  66| 83 C4 10		   ADD   ESP,16
 0243  66| 0B C0		   OR    EAX,EAX
				   ;COUNT ALL READ BYTES
				   ;
 0246  66| A3 1129 R		   MOV   DWORD PTR[LAST_READ_CHAR_COUNT],EAX
 024A  66| 01 06 112D R		   ADD   DWORD PTR[TOTAL_READ_CHAR_COUNT],EAX
				   ;BUF COUNT++
 024F  66| FF 06 1131 R		   INC   DWORD PTR[SRCBUF_COUNT]

 0254  66| 92			   XCHG  EAX,EDX    ;Put error code in DL
 0256  66| 58			   POP   EAX    ;Restore AH
				   ;MOV   AL,DL    ;Error code back in AL
 0258  66| 5A			   POP   EDX

 025A				GETCH:
				;EAX=PTR 
 025A  AC			   LODSB
				   ;P=(SRCBUF_COUNT*BUFSIZ)+(ESI-SRCBUF)
 025B  66| 51			   PUSH ECX
 025D  66| 8B 0E 1131 R		   MOV ECX,[SRCBUF_COUNT]
 0262  66| 49			   DEC ECX
 0264  66| 50			   PUSH EAX
 0266  66| B8 00000400		   MOV EAX,BUFSIZ
 026C  66| F7 E1		   MUL ECX
 026F  66| 91			   XCHG ECX,EAX
 0271  66| 58			   POP EAX
 0273  66| 03 CE		   ADD ECX,ESI
 0276  66| 81 E9 00001580 R	   SUB ECX,OFFSET SRCBUF
 027D  66| 89 0E 1125 R		   MOV [CHAR_LOCATION],ECX
 0282  66| 3B 0E 0E18 R		   CMP ECX,[SRCLENGTH]
 0287  66| 59			   POP ECX
 0289  75 0B			   JNZ    SKIP_FOUND_END
				   
				   ;USE 0 to replace 1A (even it it 1A)
 028B  66| 89 36 157C R		   MOV [BUFPT],ESI
 0290  B0 1A			   MOV AL,1AH      ;Possibly signal End of File
 0292  A2 10B0 R		   MOV   [CHR],AL
 0295  C3			   RET

 0296				SKIP_FOUND_END:
 0296  3C 0D			   CMP   AL,13
 0298  75 06			   JNZ	 SKIP_LINE_END
 029A  AC			   LODSB ;10
 029B  66| FF 06 1121 R		   INC   DWORD PTR [LINE_COUNT]
 02A0				SKIP_LINE_END:
 02A0  66| 81 FE 00001980 R	   CMP   ESI,OFFSET SRCBUF+BUFSIZ
 02A7  75 06			   JNZ   NOMOD
 02A9  66| BE 00001580 R	   MOV   ESI,OFFSET SRCBUF
 02AF				NOMOD:
 02AF  66| 89 36 157C R		   MOV   [BUFPT],ESI
 02B4  0A C0			   OR AL,AL
 02B6  75 0E			   JNZ SKIP_NOMOD
 02B8  66| BE 00001580 R	   MOV ESI,OFFSET SRCBUF
 02BE  66| 89 36 157C R		   MOV [BUFPT],ESI
 02C3  E9 FF58			   JMP NEXTCHR
 02C6				SKIP_NOMOD:

 02C6  A2 10B0 R		   MOV   [CHR],AL
 02C9  C3			   RET

 02CA				MROPS:

				; Get two operands and check for certain types, according to flag byte
				; in CL. OP code in CH. Returns only if immediate operation.

 02CA  66| 51			   PUSH  ECX    ;Save type flags
 02CC  E8 00EC			   CALL  GETOP
 02CF  66| 52			   PUSH  EDX    ;Save first operand
 02D1  E8 00DE			   CALL  GETOP2
 02D4  66| 5B			   POP   EBX    ;First op in EBX, second op in EDX
 02D6  B0 04			   MOV   AL,SREG     ;Check for a segment register
 02D8  3A C7			   CMP   AL,BH
 02DA  74 4B			   JZ SEGCHK
 02DC  3A C6			   CMP   AL,DH
 02DE  74 47			   JZ SEGCHK
 02E0  B0 01			   MOV   AL,CONST ;Check if the first operand is immediate
 02E2  B1 1A			   MOV   CL,26
 02E4  3A C7			   CMP   AL,BH
 02E6  0F 84 FF30		   JZ ERROR    ;Error if so
 02EA  66| 59			   POP   ECX    ;Restore type flags
 02EC  3A C6			   CMP   AL,DH    ;If second operand is immediate, then done
 02EE  0F 84 FF27		   JZ MAKFIL_RET
 02F2  B0 00			   MOV   AL,UNDEFID  ;Check for memory reference
 02F4  3A C7			   CMP   AL,BH
 02F6  74 59			   JZ _STORE      ;Is destination memory?
 02F8  3A C6			   CMP   AL,DH
 02FA  74 60			   JZ _LOAD    ;Is source memory?
 02FC  F6 C1 01			   TEST  CL,1     ;Check if register-to-register operation OK
 02FF  B1 1B			   MOV   CL,27
 0301  0F 84 FF15		   JZ ERROR
 0305  8A C6			   MOV   AL,DH
 0307  3A C7			   CMP   AL,BH    ;Registers must be of same length
 0309				RR:
 0309  B1 16			   MOV   CL,22
 030B  0F 85 FF0B		   JNZ   ERROR
 030F				RR1:
 030F  24 01			   AND   AL,1     ;Get register length (1=16 bits)
 0311  0A C5			   OR AL,CH    ;Or in to OP code
 0313  E8 09BE			   CALL  PUT      ;And write it
 0316  66| 59			   POP   ECX    ;Dump return address
 0318  8A C3			   MOV   AL,BL
 031A  02 C0			   ADD   AL,AL    ;Rotate register number into middle position
 031C  02 C0			   ADD   AL,AL
 031E  02 C0			   ADD   AL,AL
 0320  0C C0			   OR AL,0C0H     ;Set register-to-register mode
 0322  0A C2			   OR AL,DL    ;Combine with other register number
 0324  E9 09AD			   JMP   PUT

 0327				SEGCHK:
				;Come here if at least one operand is a segment register
 0327  66| 59			   POP   ECX    ;Restore flags
 0329  F6 C1 08			   TEST  CL,8     ;Check if segment register OK
 032C  B1 16			   MOV   CL,22
 032E  74 7F			   JZ ERR1
 0330  66| B9 00008E03		   MOV   ECX,8E03H ;Segment register move OP code
 0336  B0 00			   MOV   AL,UNDEFID
 0338  3A C6			   CMP   AL,DH    ;Check if source is memory
 033A  74 20			   JZ _LOAD
 033C  3A C7			   CMP   AL,BH    ;Check if destination is memory
 033E  74 11			   JZ _STORE
 0340  B0 03			   MOV   AL,XREG
 0342  2A C6			   SUB   AL,DH    ;Check if source is 16-bit register
 0344  74 C3			   JZ RR    ;If so, AL must be zero
 0346  B5 8C			   MOV   CH,8CH      ;Change direction
 0348  66| 87 D3		   XCHG  EDX,EBX    ;Flip which operand is first and second
 034B  B0 03			   MOV   AL,XREG
 034D  2A C6			   SUB   AL,DH    ;Let RR perform finish the test
 034F  EB B8			   JMP RR

 0351				_STORE:
 0351  F6 C1 04			   TEST  CL,004H     ;Check if storing is OK
 0354  75 55			   JNZ   STERR
 0356  66| 87 D3		   XCHG  EDX,EBX    ;If so, flip operands
 0359  80 E5 FD			   AND   CH,0FDH     ;   and zero direction bit
 035C				_LOAD:
 035C  B6 19			   MOV   DH,25
 035E  3A C7			   CMP   AL,BH    ;Check if memory-to-memory
 0360  74 4B			   JZ MRERR
 0362  8A C7			   MOV   AL,BH
 0364  3C 02			   CMP   AL,REG      ;Check if 8-bit operation
 0366  75 07			   JNZ   XRG
 0368  B6 16			   MOV   DH,22
 036A  F6 C1 01			   TEST  CL,1     ;See if 8-bit operation is OK
 036D  74 3E			   JZ MRERR
 036F				XRG:
 036F  8A C2			   MOV   AL,DL
 0371  2C 06			   SUB   AL,6     ;Check for R/M mode 6 and register 0
 0373  0A C3			   OR AL,BL    ;   meaning direct load/store of accumulator
 0375  75 1A			   JNZ   NOTAC
 0377  F6 C1 08			   TEST  CL,8     ;See if direct load/store of accumulator
 037A  74 15			   JZ NOTAC    ;   means anything in this case
				; Process direct load/store of accumulator
 037C  8A C5			   MOV   AL,CH
 037E  24 02			   AND   AL,2     ;Preserve direction bit only
 0380  34 02			   XOR   AL,2     ;   but flip it
 0382  0C A0			   OR AL,0A0H     ;Combine with OP code
 0384  8A E8			   MOV   CH,AL
 0386  8A C7			   MOV   AL,BH    ;Check byte/word operation
 0388  24 01			   AND   AL,1
 038A  0A C5			   OR AL,CH
 038C  66| 59			   POP   ECX    ;Dump return address
 038E  E9 0A28			   JMP   PUTADD      ;Write the address

 0391				NOTAC:
 0391  8A C7			   MOV   AL,BH
 0393  24 01			   AND   AL,1     ;Get byte/word bit
 0395  22 C1			   AND   AL,CL    ;But don't use it in word-only operations
 0397  0A C5			   OR AL,CH    ;Combine with OP code
 0399  E8 0938			   CALL  PUT
 039C  8A C3			   MOV   AL,BL
 039E  02 C0			   ADD   AL,AL    ;Rotate to middle position
 03A0  02 C0			   ADD   AL,AL
 03A2  02 C0			   ADD   AL,AL
 03A4  0A C2			   OR AL,DL    ;Combine register field
 03A6  66| 59			   POP   ECX    ;Dump return address
 03A8  E9 0A0E			   JMP   PUTADD      ;Write the address

 03AB				STERR:
 03AB  B6 1D			   MOV   DH,29
 03AD				MRERR:
 03AD  8A CE			   MOV   CL,DH

 03AF  E9 FE68			ERR1: JMP   ERROR


 03B2				GETOP2:
				;Get the second operand: look for a comma and drop into GETOP
 03B2  A0 10B1 R		   MOV   AL,[SYM]
 03B5  3C 2C			   CMP   AL,','
 03B7  B1 15			   MOV   CL,21
 03B9  75 F4			   JNZ   ERR1


 03BB				GETOP:

				; Get one operand. Operand may be a memory reference in brackets, a register,
				; or a constant. If a flag (such as "B" for byte operation) is encountered,
				; it is noted and processing continues to find the operand.
				;
				; On exit, AL (=DH) has the type of operand. Other information depends
				; on the actual operand:
				;
				; AL=DH=0  Memory Reference.  DL has the address mode properly prepared in
				; the 8086 R/M format (middle bits zero). The constant part of the address
				; is in _ADDR. If an undefined label needs to be added to this, a pointer to
				; its information fields is in ALABEL, otherwise ALABEL is zero.
				;
				; AL=DH=1  Value. The constant part is in DATA. If an undefined label needs
				; to be added to this, a pointer to its information fields is in DLABEL,
				; otherwise DLABEL is zero. "$" and "RET" are in this class.
				;
				; AL=DH=2  8-bit Register. DL has the register number.
				;
				; AL=DH=3  16-bit Register. DL has the register number.
				;
				; AL=DH=4  Segment Register. DL has the register number.

 03BB  E8 0268			   CALL  GETSYM

 03BE				GETOP1:
				;Enter here if we don't need a GETSYM first
 03BE  3C 5B			   CMP   AL,'['      ;Memory reference?
 03C0  74 36			   JZ MEM
 03C2  3C 05			   CMP   AL,5     ;Flag ("B", "W", etc.)?
 03C4  74 61			   JZ FLG
 03C6  3C 02			   CMP   AL,REG      ;8-Bit register?
 03C8  74 24			   JZ NREG
 03CA  3C 03			   CMP   AL,XREG     ;16-Bit register?
 03CC  74 20			   JZ NREG
 03CE  3C 04			   CMP   AL,SREG     ;Segment register?
 03D0  74 1C			   JZ NREG
 03D2				VAL:           ;Must be immediate
 03D2  32 C0			   XOR   AL,AL    ;No addressing modes allowed
 03D4				VAL1:
 03D4  E8 0061			   CALL  GETVAL
 03D7  66| A1 10A8 R		   MOV   EAX,[CON] ;Defined part
 03DB  66| A3 10A0 R		   MOV   [_DATA],EAX
 03DF  66| A1 10AC R		   MOV   EAX,[UNDEF]  ;Undefined part
 03E3  66| A3 10A4 R		   MOV   DWORD PTR[DLABEL],EAX
 03E7  8A D5			   MOV   DL,CH
 03E9  B6 01			   MOV   DH,CONST
 03EB  8A C6			   MOV   AL,DH
 03ED  C3			   RET
 03EE				NREG:
 03EE  66| 52			   PUSH  EDX
 03F0  E8 0233			   CALL  GETSYM
 03F3  66| 5A			   POP   EDX
 03F5  8A C6			   MOV   AL,DH
 03F7  C3			   RET
 03F8				MEM:
 03F8  E8 022B			   CALL  GETSYM
 03FB  B0 01			   MOV   AL,1
 03FD  E8 0038			   CALL  GETVAL
 0400  A0 10B1 R		   MOV   AL,[SYM]
 0403  3C 5D			   CMP   AL,']'
 0405  B1 18			   MOV   CL,24
 0407  75 A6			   JNZ   ERR1
 0409  E8 021A			   CALL  GETSYM
 040C  66| 8B 1E 10A8 R		   MOV   EBX,[CON]
 0411  66| 89 1E 1098 R		   MOV   [_ADDR],EBX
 0416  66| 8B 1E 10AC R		   MOV   EBX,[UNDEF]
 041B  66| 89 1E 109C R		   MOV   [ALABEL],EBX
 0420  8A D5			   MOV   DL,CH
 0422  B6 00			   MOV   DH,UNDEFID
 0424  8A C6			   MOV   AL,DH
 0426  C3			   RET
 0427				FLG:
 0427  3A 16 1034 R		   CMP   DL,[MAXFLG] ;Invalid flag for this operation?
 042B  B1 27			   MOV   CL,27H
 042D  7F 80			   JG ERR1
 042F  E8 01F4			   CALL  GETSYM
 0432  3C 2C			   CMP   AL,','
 0434  74 85			   JZ GETOP
 0436  EB 86			   JMP GETOP1


 0438				GETVAL:

				; Expression analyzer. On entry, if AL=0 then do not allow base or index
				; registers. If AL=1, we are analyzing a memory reference, so allow base
				; and index registers, and compute addressing mode when done. The constant
				; part of the expression will be found in CON. If an undefined label is to
				; be added to this, a pointer to its information fields will be found in
				; UNDEF.

 0438  8A E0			   MOV   AH,AL    ;Flag is kept in AH
 043A  66| C7 06 10AC R		   MOV   DWORD PTR[UNDEF],0
       00000000
 0443  A0 10B1 R		   MOV   AL,[SYM]
 0446  E8 0058			   CALL  EXPRESSION
 0449  66| 89 16 10A8 R		   MOV   [CON],EDX
 044E  8A C4			   MOV   AL,AH
 0450  B5 00			   MOV   CH,0     ;Initial mode
 0452  A8 10			   TEST  AL,10H      ;Test INDEX bit
 0454  D0 D0			   RCL   AL,1     ;BASE bit (zero flag not affected)
 0456  74 3D			   JZ NOIND    ;Jump if not indexed, with BASE bit in carry
 0458  F5			   CMC
 0459  D0 D5			   RCL   CH,1     ;Rotate in BASE bit
 045B  D0 D0			   RCL   AL,1     ;EBP bit
 045D  D0 D5			   RCL   CH,1
 045F  D0 D0			   RCL   AL,1     ;EDI bit
 0461  D0 D5			   RCL   CH,1     ;The low 3 bits now have indexing mode
 0463				MODE:
 0463  80 CD 80			   OR CH,080H     ;If undefined label, force 16-bit displacement
 0466  66| F7 06 10AC R		   TEST  DWORD PTR[UNDEF],-1
       0000FFFF
 046F  75 23			   JNZ   MODE_RET
 0471  66| 8B 1E 10A8 R		   MOV   EBX,[CON]
 0476  8A C3			   MOV   AL,BL
 0478  98			   CBW         ;Extend sign
 0479  66| 3B C3		   CMP   EAX,EBX    ;Is it a signed 8-bit number?
 047C  75 16			   JNZ   MODE_RET    ;If not, use 16-bit displacement
 047E  80 E5 7F			   AND   CH,07FH     ;Reset 16-bit displacement
 0481  80 CD 40			   OR CH,040H     ;Set 8-bit displacement
 0484  66| 0B DB		   OR EBX,EBX
 0487  75 0B			   JNZ   MODE_RET    ;Use it if not zero displacement
 0489  80 E5 07			   AND   CH,7     ;Specify no displacement
 048C  80 FD 06			   CMP   CH,6     ;Check for EBP+0 addressing mode
 048F  75 03			   JNZ   MODE_RET
 0491  80 CD 40			   OR CH,040H     ;If EBP+0, use 8-bit displacement
 0494				MODE_RET:
 0494  C3			   RET

 0495				NOIND:
 0495  B5 06			   MOV   CH,6     ;Try direct address mode
 0497  73 FB			   JNC   MODE_RET    ;If no base register, that's right
 0499  D0 D0			   RCL   AL,1     ;Check EBP bit
 049B  72 C6			   JC MODE
 049D  FE C5			   INC   CH    ;If not, must be EBX
 049F  EB C2			   JMP MODE


 04A1				EXPRESSION:
				;Analyze arbitrary expression. Flag byte in AH.
				;On exit, AL has type byte: 0=register or undefined label
 04A1  B5 FF			   MOV   CH,-1    ;Initial type
 04A3  66| 8B FA		   MOV   EDI,EDX
 04A6  66| 33 D2		   XOR   EDX,EDX    ;Initial value
 04A9  3C 2B			   CMP   AL,'+'
 04AB  74 0F			   JZ PLSMNS
 04AD  3C 2D			   CMP   AL,'-'
 04AF  74 0B			   JZ PLSMNS
 04B1  B1 2B			   MOV   CL,'+'
 04B3  66| 52			   PUSH  EDX
 04B5  66| 51			   PUSH  ECX
 04B7  66| 8B D7		   MOV   EDX,EDI
 04BA  EB 0C			   JMP OPERATE
 04BC				PLSMNS:
 04BC  8A C8			   MOV   CL,AL
 04BE  66| 52			   PUSH  EDX
 04C0  66| 51			   PUSH  ECX
 04C2  80 CC 04			   OR AH,4     ;Flag that a sign was found
 04C5  E8 015E			   CALL  GETSYM
 04C8				OPERATE:
 04C8  E8 0030			   CALL  TERM
 04CB  66| 59			   POP   ECX    ;Recover operator
 04CD  66| 5B			   POP   EBX    ;Recover current value
 04CF  66| 87 D3		   XCHG  EDX,EBX
 04D2  22 E8			   AND   CH,AL
 04D4  0A C0			   OR AL,AL    ;Is it register or undefined label?
 04D6  74 19			   JZ NOCON    ;If so, then no constant part
 04D8  80 F9 2D			   CMP   CL,"-"      ;Subtract it?
 04DB  75 03			   JNZ   _ADD
 04DD  66| F7 DB		   NEG   EBX
 04E0				_ADD:
 04E0  66| 03 D3		   ADD   EDX,EBX
 04E3				NEXTERM:
 04E3  A0 10B1 R		   MOV   AL,[SYM]
 04E6  3C 2B			   CMP   AL,'+'
 04E8  74 D2			   JZ PLSMNS
 04EA  3C 2D			   CMP   AL,'-'
 04EC  74 CE			   JZ PLSMNS
 04EE  8A C5			   MOV   AL,CH
 04F0  C3			   RET
 04F1				NOCON:
 04F1  80 F9 2D			   CMP   CL,"-"
 04F4  75 ED			   JNZ   NEXTERM
 04F6				BADOP:
 04F6  B1 05			   MOV   CL,5
 04F8  E9 FD1F			   JMP   ERROR

 04FB				TERM:
 04FB  E8 004F			   CALL  FACTOR
 04FE				MULOP:
 04FE  66| 52			   PUSH  EDX    ;Save value
 0500  66| 50			   PUSH  EAX    ;Save type
 0502  E8 0121			   CALL  GETSYM
 0505  66| 59			   POP   ECX
 0507  3C 2A			   CMP   AL,"*"
 0509  74 04			   JZ GETFACT
 050B  3C 2F			   CMP   AL,"/"
 050D  75 39			   JNZ   ENDTERM
 050F				GETFACT:
 050F  0A C9			   OR CL,CL    ;Can we operate on this type?
 0511  74 E3			   JZ BADOP
 0513  66| 50			   PUSH  EAX    ;Save operator
 0515  E8 010E			   CALL  GETSYM      ;Get past operator
 0518  E8 0032			   CALL  FACTOR
 051B  0A C0			   OR AL,AL
 051D  74 D7			   JZ BADOP
 051F  66| 59			   POP   ECX    ;Recover operator
 0521  66| 5D			   POP   EBP    ;And current value
 0523  66| 95			   XCHG  EAX,EBP    ;Save AH in EBP
 0525  80 F9 2F			   CMP   CL,"/"      ;Do we divide?
 0528  75 12			   JNZ   DOMUL
 052A  66| 0B D2		   OR EDX,EDX    ;Dividing by zero?
 052D  B1 29			   MOV   CL,29H
 052F  74 58			   JZ ERR2
 0531  66| 8B DA		   MOV   EBX,EDX
 0534  66| 33 D2		   XOR   EDX,EDX    ;Make 32-bit dividend
 0537  66| F7 F3		   DIV   EBX
 053A  EB 03			   JMP   NEXFACT
 053C				DOMUL:
 053C  66| F7 E2		   MUL   EDX
 053F				NEXFACT:
 053F  66| 8B D0		   MOV   EDX,EAX    ;Result in EDX
 0542  66| 95			   XCHG  EAX,EBP    ;Restore flags to AH
 0544  B0 FF			   MOV   AL,-1    ;Indicate a number
 0546  EB B6			   JMP   MULOP
 0548				ENDTERM:
 0548  66| 5A			   POP   EDX
 054A  8A C1			   MOV   AL,CL
 054C				ENDTERM_RET:
 054C  C3			   RET
 054D				FACTOR:
 054D  A0 10B1 R		   MOV   AL,[SYM]
 0550  3C 01			   CMP   AL,CONST
 0552  74 F8			   JZ ENDTERM_RET
 0554  3C 00			   CMP   AL,UNDEFID
 0556  74 5C			   JZ UVAL
 0558  3C 28			   CMP   AL,"("
 055A  74 48			   JZ PAREN
 055C  3C 22			   CMP   AL,'"'
 055E  74 67			   JZ STRING
 0560  3C 27			   CMP   AL,"'"
 0562  74 63			   JZ STRING
 0564  3C 03			   CMP   AL,XREG     ;Only 16-bit register may index
 0566  B1 14			   MOV   CL,20
 0568  75 1F			   JNZ   ERR2
 056A  F6 C4 01			   TEST  AH,1     ;Check to see if indexing is OK
 056D  B1 01			   MOV   CL,1
 056F  74 18			   JZ ERR2
 0571  8A C2			   MOV   AL,DL
 0573  B1 03			   MOV   CL,3
 0575  2C 03			   SUB   AL,3     ;Check for EBX
 0577  74 22			   JZ BXJ
 0579  2C 02			   SUB   AL,2     ;Check for EBP
 057B  74 1B			   JZ BPJ
 057D  FE C8			   DEC   AL    ;Check for ESI
 057F  B1 04			   MOV   CL,4
 0581  74 0C			   JZ SIJ
 0583  FE C8			   DEC   AL    ;Check for EDI
 0585  74 05			   JZ DIJ
 0587  B1 02			   MOV   CL,2     ;Invalid base/index register
 0589  E9 FC8E			ERR2: JMP   ERROR

 058C				DIJ:
 058C  80 CC 20			   OR AH,20H      ;Flag seeing index register EDI
 058F				SIJ:
 058F  F6 C4 10			   TEST  AH,10H      ;Check if already seen index register
 0592  75 F5			   JNZ   ERR2
 0594  80 CC 10			   OR AH,10H      ;Flag seeing index register
 0597  C3			   RET

 0598				BPJ:
 0598  80 CC 40			   OR AH,40H      ;Flag seeing base register EBP
 059B				BXJ:
 059B  F6 C4 80			   TEST  AH,80H      ;Check if already seen base register
 059E  75 E9			   JNZ   ERR2
 05A0  80 CC 80			   OR AH,80H      ;Flag seeing base register
 05A3  C3			   RET

 05A4				PAREN:
 05A4  E8 007F			   CALL  GETSYM      ;Eat the "("
 05A7  E8 FEF7			   CALL  EXPRESSION
 05AA  80 3E 10B1 R 29		   CMP   BYTE PTR[SYM],")"  ;Better have closing paren
 05AF  B1 14			   MOV   CL,20
 05B1  75 11			   JNZ   ERR30
 05B3  C3			   RET
 05B4				UVAL:
 05B4  B1 06			   MOV   CL,6
 05B6  F6 C4 08			   TEST  AH,8     ;Check if undefined label has been seen
 05B9  75 09			   JNZ   ERR30
 05BB  80 CC 08			   OR AH,8     ;Flag seeing undefined label
 05BE  66| 89 1E 10AC R		   MOV   [UNDEF],EBX
 05C3  C3			   RET

 05C4  E9 FC53			ERR30:   JMP   ERROR
 05C7				STRING:
 05C7  8A E8			   MOV   CH,AL
 05C9  A0 10B0 R		   MOV   AL,[CHR]
 05CC  3A C5			   CMP   AL,CH
 05CE  B1 23			   MOV   CL,35
 05D0  8A D0			   MOV   DL,AL
 05D2  B6 00			   MOV   DH,0
 05D4  75 03			   JNZ   L0003
 05D6  E8 0032			   CALL  ZERLEN
 05D9				L0003:
 05D9  E8 0037			   CALL  GETCHR
 05DC  B1 25			   MOV   CL,37
 05DE  F6 C4 02			   TEST  AH,2
 05E1  74 E1			   JZ ERR30
 05E3  F6 C4 04			   TEST  AH,4
 05E6  B1 26			   MOV   CL,38
 05E8  75 DA			   JNZ   ERR30
 05EA				STRGDAT:
 05EA  8A C2			   MOV   AL,DL
 05EC  3C 0D			   CMP   AL,EOL
 05EE  B1 27			   MOV   CL,39
 05F0  74 D2			   JZ ERR30
 05F2  E8 06DF			   CALL  PUT
 05F5  A0 10C2 R		   MOV   AL,[DATSIZ]
 05F8  0A C0			   OR AL,AL
 05FA  75 05			   JNZ   BYTSIZ
 05FC  8A C6			   MOV   AL,DH
 05FE  E8 06D3			   CALL  PUT
 0601				BYTSIZ:
 0601  A0 10B0 R		   MOV   AL,[CHR]
 0604  8A D0			   MOV   DL,AL
 0606  E8 000A			   CALL  GETCHR
 0609  EB DF			   JMP STRGDAT

 060B				ZERLEN:
 060B  E8 FC10			   CALL  NEXTCHR
 060E  3A C5			   CMP   AL,CH
 0610  75 B2			   JNZ   ERR30
 0612  C3			   RET
 0613				GETCHR:
 0613  E8 FC08			   CALL  NEXTCHR
 0616  3A C5			   CMP   AL,CH
 0618  75 0B			   JNZ   GETCHR_RET
 061A  E8 FC01			   CALL  NEXTCHR
 061D  3A C5			   CMP   AL,CH
 061F  74 04			   JZ GETCHR_RET
 0621  66| 5B			   POP   EBX    ;Kill return address to STRGDAT loop
 0623  B0 FF			   MOV   AL,-1    ;Flag type as constant
 0625				GETCHR_RET:
 0625  C3			   RET

 0626				GETSYM:

				; The lexical scanner. Used only in the operand field. Returns with the token
				; in SYM and AL, sometimes with additional info in EBX or EDX.
				;
				; AL=SYM=0  Undefined label. EBX has pointer to information fields.
				;
				; AL=SYM=1  Constant (or defined label). EDX has value.
				;
				; AL=SYM=2,3,4  8-bit register, 16-bit register, or segment register,
				; respectively. DL has register number.
				;
				; AL=SYM=5  A mode flag (such as "B" for byte operation). Type of flag in DL
				; and also stored in FLAG: -1=no flags, 0=B, 1=W, 2=S, 3=L, 4=T.
				;
				; AL=SYM=6  8087 floating point register, ST(n) or ST. DL has register number.
				;
				; All other values are the ASCII code of the character. Note that this may
				; never be a letter or number.

 0626  66| 50			   PUSH  EAX    ;Save AH
 0628  E8 0024			   CALL  GETSY
 062B  66| 58			   POP   EAX
 062D  A0 10B1 R		   MOV   AL,[SYM]
 0630				GETSYM_RET:
 0630  C3			   RET

 0631				SCANB: ;DONE
 0631  A0 10B0 R		   MOV   AL,[CHR]
 0634				SCANT:
 0634  3C 20			   CMP   AL,' '
 0636  74 04			   JZ NEXB
 0638  3C 09			   CMP   AL,9   ;\t
 063A  75 05			   JNZ   SCANB_RET
 063C				NEXB:
 063C  E8 FBDF			   CALL  NEXTCHR
 063F  EB F3			   JMP SCANT
 0641				SCANB_RET:
 0641  C3			   RET

 0642				DOLLAR:
 0642  66| 8B 16 1090 R		   MOV   EDX,[OLDPC]
 0647  B0 01			   MOV   AL,CONST
 0649  A2 10B1 R		   MOV   [SYM],AL
 064C				NEXTCHJ:
 064C  E9 FBCF			   JMP   NEXTCHR

 064F				GETSY:
 064F  E8 FFDF			   CALL  SCANB
 0652  3C 24			   CMP   AL,'$'
 0654  74 EC			   JZ DOLLAR
 0656  A2 10B1 R		   MOV   [SYM],AL
 0659  0C 20			   OR AL,20H
 065B  3C 7B			   CMP   AL,'z'+1
 065D  73 ED			   JNC   NEXTCHJ
 065F  3C 61			   CMP   AL,'a'
 0661  72 03			   JC GETSY_SKIP
 0663  E9 00E3			   JMP   LETTER
 0666				GETSY_SKIP:
 0666  3C 3A			   CMP   AL,'9'+1
 0668  73 E2			   JNC   NEXTCHJ
 066A  3C 30			   CMP   AL,'0'
 066C  72 DE			   JC NEXTCHJ
 066E  66| BB 000010B1 R	   MOV   EBX,OFFSET SYM
 0674  67& C6 03 01		   MOV   BYTE PTR[EBX],CONST
 0678  E8 009E			   CALL  READID
 067B  66| 4B			   DEC   EBX
 067D  67& 8A 03		   MOV   AL,[EBX]
 0680  B1 07			   MOV   CL,7
 0682  66| BB 00000000		   MOV   EBX,0
 0688  3C 68			   CMP   AL,'h'
 068A  75 02			   JNZ   GETSY_SKIP2
 068C  EB 3F			   JMP   HEX
 068E				GETSY_SKIP2:
 068E  FE C1			   INC   CL
 0690  66| C7 06 110D R		   MOV   DWORD PTR[IX],OFFSET  ID
       0000103A R
 0699				_DEC:
 0699  66| 8B 36 110D R		   MOV   ESI,[IX]
 069E  67& 8A 06		   MOV   AL,[ESI]
 06A1  66| FF 06 110D R		   INC   DWORD PTR[IX]
 06A6  3C 3A			   CMP   AL,'9'+1
 06A8  72 03			   JC _DEC_SKIP
 06AA  E9 FB6D			   JMP   ERROR
 06AD				_DEC_SKIP:
 06AD  2C 30			   SUB   AL,'0'
 06AF  66| 8B D3		   MOV   EDX,EBX
 06B2  66| D1 E3		   SHL   EBX,1
 06B5  66| D1 E3		   SHL   EBX,1
 06B8  66| 03 DA		   ADD   EBX,EDX
 06BB  66| D1 E3		   SHL   EBX,1
 06BE  8A D0			   MOV   DL,AL
 06C0  B6 00			   MOV   DH,0
 06C2  66| 03 DA		   ADD   EBX,EDX
 06C5  FE CD			   DEC   CH
 06C7  75 D0			   JNZ   _DEC
 06C9  66| 87 D3		   XCHG  EDX,EBX
 06CC  C3			   RET

 06CD				HEX:
 06CD  66| BA 0000103A R	   MOV   EDX,OFFSET ID
 06D3  FE CD			   DEC   CH
 06D5				HEX1:
 06D5  66| 8B F2		   MOV   ESI,EDX
 06D8  AC			   LODSB
 06D9  66| 42			   INC   EDX
 06DB  2C 30			   SUB   AL,'0'
 06DD  3C 0A			   CMP   AL,10
 06DF  72 06			   JC GOTIT
 06E1  3C 37			   CMP   AL,'g'-'0'
 06E3  73 18			   JNC   ERR4
 06E5  2C 27			   SUB   AL,'a'-10-'0'
 06E7				GOTIT:
 06E7  66| D1 E3		   SHL   EBX,1
 06EA  66| D1 E3		   SHL   EBX,1
 06ED  66| D1 E3		   SHL   EBX,1
 06F0  66| D1 E3		   SHL   EBX,1
 06F3  02 D8			   ADD   BL,AL
 06F5  FE CD			   DEC   CH
 06F7  75 DC			   JNZ   HEX1
 06F9  66| 87 D3		   XCHG  EDX,EBX
 06FC  C3			   RET

 06FD  E9 FB1A			ERR4: JMP   ERROR

 0700				GETLET: ;SAVE LABEL AND RETURN ':'
 0700  E8 FF2E			   CALL  SCANB
 0703  3C 0D			   CMP   AL,EOL
 0705  F9			   STC
 0706  74 40			   JZ GETLET_RET
 0708  3C 3B			   CMP   AL,';'
 070A  F9			   STC
 070B  74 3B			   JZ GETLET_RET
 070D  B1 0A			   MOV   CL,10
 070F  0C 20			   OR AL,20H
 0711  3C 61			   CMP   AL,'a'
 0713  72 E8			   JC ERR4
 0715  3C 7B			   CMP   AL,'z'+1
 0717  73 E4			   JNC   ERR4
 0719				READID:
 0719  66| BB 0000103A R	   MOV   EBX,OFFSET ID
 071F  B5 00			   MOV   CH,0
 0721				MOREID: ;READ LABEL CHARS
 0721  67& 88 03		   MOV   [EBX],AL
 0724  FE C5			   INC   CH
 0726  66| 43			   INC   EBX
 0728  E8 FAF3			   CALL  NEXTCHR
 072B  3C 30			   CMP   AL,'0'
 072D  72 0E			   JC NOMORE
 072F  0C 20			   OR AL,20H
 0731  3C 7B			   CMP   AL,'z'+1
 0733  73 08			   JNC   NOMORE
 0735  3C 3A			   CMP   AL,'9'+1
 0737  72 E8			   JC MOREID
 0739  3C 61			   CMP   AL,'a'
 073B  73 E4			   JNC   MOREID
 073D				NOMORE:
 073D  8A C8			   MOV   CL,AL
 073F  8A C5			   MOV   AL,CH
 0741  A2 1036 R		   MOV   BYTE PTR[LENID],AL
 0744  0A C0			   OR AL,AL
 0746  8A C1			   MOV   AL,CL
 0748				GETLET_RET:
 0748  C3			   RET

 0749				LETTER:
 0749  E8 FFCD			   CALL  READID
 074C  8A C5			   MOV   AL,CH
 074E  FE C8			   DEC   AL
 0750  75 1A			   JNZ   NOFLG
 0752  A0 103A R		   MOV   AL,[ID]
 0755  66| B9 00000005		   MOV   ECX,5
 075B  66| BF 00000794 R	   MOV   EDI,FLGTAB
 0761  FC			   CLD
 0762  F2/ AE			   REPNE SCASB       ;See if one of B,W,S,L,T
 0764  74 1C			   JZ SAVFLG      ;Go save flag
 0766  32 C0			   XOR   AL,AL
 0768  8A 2E 1036 R		   MOV   CH,BYTE PTR[LENID]
 076C				NOFLG:
 076C  FE C8			   DEC   AL
 076E  66| 53			   PUSH  EBX
 0770  75 03			   JNZ   L0004
 0772  E8 005E			   CALL  REGCHK
 0775				L0004:   
 0775  66| 5B			   POP   EBX
 0777  8A C6			   MOV   AL,DH
 0779  74 03			   JZ SYMSAV
 077B  E8 0121			   CALL  LOOKRET
 077E				SYMSAV:
 077E  A2 10B1 R		   MOV   [SYM],AL
 0781  C3			   RET

 0782				SAVFLG:
 0782  8A D1			   MOV   DL,CL    ;Need flag type in DL
 0784  86 0E 1035 R		   XCHG  [FLAG],CL
 0788  80 F9 FF			   CMP   CL,-1
 078B  B1 20			   MOV   CL,32
 078D  B0 05			   MOV   AL,5
 078F  74 ED			   JZ SYMSAV
 0791  E9 FA86			ERRJ3:   JMP   ERROR

 0794 74 6C 73 77 62		FLGTAB:  DB "tlswb"

 0799				FPREG:
				;Have detected "ST" for 8087 floating point stack register
 0799  B2 00			   MOV   DL,0     ;Default is ST(0)
 079B  E8 FE93			   CALL  SCANB    ;Get next character
 079E  3C 28			   CMP   AL,"("      ;Specifying register number?
 07A0  75 2C			   JNZ   HAVREG
				;Get register number
 07A2  E8 FA79			   CALL  NEXTCHR     ;Skip over the "("
 07A5  E8 FC13			   CALL  GETOP    ;A little recursion never hurt anybody
 07A8  3C 01			   CMP   AL,CONST ;Better have found a constant
 07AA  B1 14			   MOV   CL,20    ;Operand error if not
 07AC  75 E3			   JNZ   ERRJ3
 07AE  66| 83 3E 10A4 R		   CMP   DWORD PTR[DLABEL],0  ;Constant must be defined
       00
 07B4  B1 1E			   MOV   CL,30
 07B6  75 D9			   JNZ   ERRJ3
 07B8  66| 8B 16 10A0 R		   MOV   EDX,[_DATA]  ;Get constant
 07BD  66| 83 FA 07		   CMP   EDX,7     ;Constant must be in range 0-7
 07C1  B1 1F			   MOV   CL,31
 07C3  77 CC			   JA ERRJ3
 07C5  A0 10B1 R		   MOV   AL,[SYM]
 07C8  3C 29			   CMP   AL,")"
 07CA  B1 18			   MOV   CL,24
 07CC  75 C3			   JNZ   ERRJ3
 07CE				HAVREG:
 07CE  B6 06			   MOV   DH,FREG
 07D0  32 C0			   XOR   AL,AL    ;Zero set means register found
 07D2  C3			   RET

 07D3				REGCHK:
 07D3  66| BB 0000103A R	   MOV   EBX,OFFSET ID
 07D9  67& 66| 81 3B		   CMP   DWORD PTR[EBX],"s"+7400H   ;"st"
       00007473
 07E1  74 B6			   JZ FPREG
 07E3  67& 8A 0B		   MOV   CL,[EBX]
 07E6  66| 43			   INC   EBX
 07E8  67& 8A 03		   MOV   AL,[EBX]
 07EB  66| BB 00000D06 R	   MOV   EBX,OFFSET REGTAB
 07F1  B6 03			   MOV   DH,XREG
 07F3  B2 00			   MOV   DL,0
 07F5  3C 78			   CMP   AL,'x'
 07F7  74 3E			   JZ SCANREG
 07F9  B6 02			   MOV   DH,REG
 07FB  3C 6C			   CMP   AL,'l'
 07FD  74 38			   JZ SCANREG
 07FF  B2 04			   MOV   DL,4
 0801  3C 68			   CMP   AL,'h'
 0803  74 32			   JZ SCANREG
 0805  B6 04			   MOV   DH,SREG
 0807  B2 00			   MOV   DL,0
 0809  66| BB 00000D0A R	   MOV   EBX,OFFSET SEGTAB
 080F  3C 73			   CMP   AL,'s'
 0811  74 24			   JZ SCANREG
 0813  B6 03			   MOV   DH,XREG
 0815  3C 70			   CMP   AL,'p'
 0817  74 11			   JZ PREG
 0819  3C 69			   CMP   AL,'i'
 081B  75 35			   JNZ   SCANREG_RET
 081D  B2 06			   MOV   DL,6
 081F  8A C1			   MOV   AL,CL
 0821  3C 73			   CMP   AL,'s'
 0823  74 2D			   JZ SCANREG_RET
 0825  FE C2			   INC   DL
 0827  3C 64			   CMP   AL,'d'
 0829  C3			   RET
 082A				PREG:
 082A  B2 04			   MOV   DL,4
 082C  8A C1			   MOV   AL,CL
 082E  3C 73			   CMP   AL,'s'
 0830  74 20			   JZ SCANREG_RET
 0832  FE C2			   INC   DL
 0834  3C 62			   CMP   AL,'b'
 0836  C3			   RET
 0837				SCANREG:
 0837  8A C1			   MOV   AL,CL
 0839  66| B9 00000004		   MOV   ECX,4
 083F  FC			   CLD
 0840  66| 8B FB		   MOV   EDI,EBX
 0843  F2/ AE			   REPNZ   SCASB
 0845  66| 8B DF		   MOV   EBX,EDI
 0848  75 08			   JNZ   SCANREG_RET
 084A  8A C1			   MOV   AL,CL
 084C  02 C2			   ADD   AL,DL
 084E  8A D0			   MOV   DL,AL
 0850  32 C0			   XOR   AL,AL
 0852				SCANREG_RET:
 0852  C3			   RET
				;-----------------------------------------------
 0853				LOOK:	;EBX:base of nodes
 0853  67& 8A 2B		   MOV   CH,[EBX]
 0856  66| 43			   INC   EBX
 0858  66| 43			   INC   EBX
 085A  66| 43			   INC   EBX
 085C  66| 43			   INC   EBX
 085E  66| BA 0000103A R	   MOV   EDX,OFFSET ID
 0864  E8 0138			   CALL  CPSLP
 0867  74 E9			   JZ SCANREG_RET
 0869  34 80			   XOR   AL,80H
 086B  D0 C0			   ROL   AL,1     ;Make end-of-symbol bit least significant
 086D  8A C8			   MOV   CL,AL
 086F  66| 4B			   DEC   EBX
 0871  67& 8A 03		   MOV   AL,[EBX] ;EBX: Start of ID in nodes
 0874  34 80			   XOR   AL,80H
 0876  D0 C0			   ROL   AL,1
 0878  3A C1			   CMP   AL,CL

 087A  66| 81 C3 00000080	   ADD   EBX,NODESIZE
 0881  73 04			   JNC   SMALL
 0883  66| 83 C3 04		   ADD  EBX,4 ;Skip Left Link
 0887				SMALL:
 0887  67& 66| 8B 13		   MOV   EDX,[EBX]	;EBX points to LEFT_LINK or RIGHT LINK
 088B  66| 43			   INC   EBX
 088D  66| 43			   INC	 EBX
 088F  66| 43			   INC   EBX
 0891  66| 43			   INC	 EBX
 0893  8A C2			   MOV   AL,DL
 0895  0A C6			   OR    AL,DH ;OR DH,DL
 0897  F9			   STC
 0898  74 6E			   JZ ALLRET_RET
 089A  66| 87 D3		   XCHG  EDX,EBX
 089D  EB B4			   JMP LOOK

 089F				LOOKRET:
 089F  8A C5			   MOV   AL,CH
 08A1  3C 03			   CMP   AL,3  ;RET has 3 letters
 08A3  75 64			   JNZ   LOOKUP
 08A5  66| 4B			   DEC   EBX    ;EBX left link, EBX-1 last char of "RET"
 08A7  67& 80 0B 80		   OR	 BYTE PTR[EBX],080H
 08AB  66| BA 00000CFF R	   MOV   EDX,OFFSET RETSTR+2
 08B1				CHKRET:
 08B1  66| 8B F2		   MOV   ESI,EDX
 08B4  AC			   LODSB
 08B5  67& 3A 03		   CMP   AL,[EBX]
 08B8  75 55			   JNZ   LOOKIT
 08BA  66| 4B			   DEC   EBX
 08BC  66| 4A			   DEC   EDX
 08BE  FE CD			   DEC   CH
 08C0  75 EF			   JNZ   CHKRET
 08C2  66| 8B 16 10F9 R		   MOV   EDX,[LSTRET]
 08C7  8A C2			   MOV   AL,DL
 08C9  22 C6			   AND   AL,DH
 08CB  FE C0			   INC   AL
 08CD  74 12			   JZ ALLRET
 08CF  66| 8B 1E 108C R		   MOV   EBX,[PC]
 08D4  66| 2B DA		   SUB   EBX,EDX
 08D7  8A C3			   MOV   AL,BL
 08D9  98			   CBW
 08DA  66| 3B C3		   CMP   EAX,EBX    ;Signed 8-bit number?
 08DD  B0 01			   MOV   AL,1
 08DF  74 27			   JZ ALLRET_RET
 08E1				ALLRET:
 08E1  66| 8B 1E 10FD R		   MOV   EBX,[RETPT]
 08E6  8A C7			   MOV   AL,BH
 08E8  0A C3			   OR AL,BL
 08EA  B0 00			   MOV   AL,0
 08EC  75 1A			   JNZ   ALLRET_RET
 08EE  66| 8B 1E 10B6 R		   MOV   EBX,[_HEAP]
 08F3  66| 4B			   DEC   EBX
 08F5  66| 4B			   DEC   EBX
 08F7  66| 4B			   DEC   EBX
 08F9  66| 89 1E 10B6 R		   MOV   [_HEAP],EBX
 08FE  32 C0			   XOR   AL,AL
 0900  67& 88 03		   MOV   [EBX],AL
 0903  66| 89 1E 10FD R		   MOV   [RETPT],EBX
 0908				ALLRET_RET:
 0908  C3			   RET

 0909				LOOKUP: ;EBX:Left link, EBX-1:Last char of Identifier
 0909  66| 4B			   DEC   EBX
 090B  67& 80 0B 80		   OR BYTE PTR[EBX],080H	;SET LAST CHAR WITH 0x80
 090F				LOOKIT:
 090F  66| 8B 1E 10B2 R		   MOV   EBX,[BASE]
 0914  8A C7			   MOV   AL,BH
 0916  0A C3			   OR AL,BL
 0918  74 2B			   JZ EMPTY
 091A  E8 FF36			   CALL  LOOK
 091D  72 19			   JC _ENTER
 091F  66| BA 00000004		   MOV   EDX,4
 0925  66| 03 DA		   ADD   EBX,EDX
 0928  67& 8A 03		   MOV   AL,[EBX]
 092B  0A C0			   OR AL,AL
 092D  74 08			   JZ LOOKIT_RET
 092F  66| 43			   INC   EBX
 0931  67& 66| 8B 13		   MOV   EDX,[EBX]
 0935  66| 43			   INC   EBX
 0937				LOOKIT_RET:
 0937  C3			   RET

 0938				_ENTER:
 0938  66| 53			   PUSH  EBX    ;Save pointer to link field
 093A  E8 0011			   CALL  CREATE      ;Add the node
 093D  66| 5E			   POP   ESI
 093F  67& 66| 89 56 B0		   MOV   [ESI-80],EDX   ;Link new node
 0944  C3			   RET         ;Zero was set by CREATE

 0945				EMPTY:
 0945  E8 0006			   CALL  CREATE
 0948  66| 89 16 10B2 R		   MOV   [BASE],EDX ;Save node start to BASE
 094D  C3			   RET


 094E				CREATE:

				; Add a new node to the identifier tree. The identifier is at ID with
				; bit 7 of the last character set to one. The length of the identifier is
				; in LENID, which is ID-4
				;
				; Node format:
				;  4+84+4+4+4+4 =104 ->USE 128
				;  1. Length of identifier (4 byte) :
				;  2. Identifier (1-80 bytes) :EXTEND TO 1-84, total 84
				;  3. Left link (4-byte pointer to alphabetically smaller identifiers) :4
				;  4. Right link (4-byte pointer 0 if none larger) :4
				;  5. Data field:
				;     a. Defined flag (0=undefined, 1=defined) (1 byte) :4
				;     b. Value (4 bytes) :4
				;
				; This routine returns with AL=zero and zero flag set (which indicates
				; on return from LOOKUP that it has not yet been defined), EDX points
				; to start of new node, and EBX points to data field of new node.

				   ;Storage needed for the node ;8 + 6 + 2
 094E  66| 8B 1E 10B6 R		   MOV   EBX,[_HEAP]
 0953  66| 33 D2		   XOR   EDX,EDX
 0956  66| 81 EB 00000080	   SUB   EBX,NODESIZE    ;Heap grows downward -128
 095D  66| 89 1E 10B6 R		   MOV   [_HEAP],EBX
 0962  66| 87 D3		   XCHG  EDX,EBX
 0965  66| 8B 1E 10BE R		   MOV   EBX,[CODE]   ;Check to make sure there's enough
				   ;db 0cch
 096A  66| 3B DA		   CMP   EBX,EDX		;OUT OF MEMORY
 096D  72 03			   JB SKIP_ABORT
 096F  E9 F87C			   JMP   ABORT
 0972				SKIP_ABORT:
 0972  66| 52			   PUSH  EDX	;EDX: START POS OF NODE
 0974  66| 8B 1E 1036 R		   MOV   EBX,LENID ;EBX: LENID + ID
 0979  66| 33 C9		   XOR   ECX,ECX
				   ;MOV   CL,[EBX] ;EBX:ID,CL=id length
 097C  66| B9 00000054		   MOV   ECX,4+80
 0982  FC			   CLD 
 0983  66| 8B F3		   MOV   ESI,EBX
 0986  66| 8B FA		   MOV   EDI,EDX
 0989  F3/ A4			   REP   MOVSB       ;Move identifier and length into node
				   
 098B  66| 8B DF		   MOV   EBX,EDI
 098E  66| 8B D6		   MOV   EDX,ESI
 0991  66| 33 C0		   XOR   EAX,EAX
 0994  66| AB			   STOSD ;LEFT LINK
 0996  66| AB			   STOSD ;RIGHT LINK
 0998  66| AB			   STOSD ;ZERO FLAG
 099A  66| AB			   STOSD ;VALUE
 099C  66| 5A			   POP   EDX    ;Restore pointer to node start
 099E  C3			   RET

 099F				CPSLP: ;COMPARE EDX: EBX (CH=LENGTH)
 099F  66| 8B F2		   MOV   ESI,EDX
 09A2  AC			   LODSB
 09A3  67& 3A 03		   CMP   AL,[EBX]
 09A6  9F			   LAHF
 09A7  66| 42			   INC   EDX
 09A9  66| 43			   INC   EBX
 09AB  9E			   SAHF
 09AC  75 04			   JNZ   CPSLP_RET
 09AE  FE CD			   DEC   CH
 09B0  75 ED			   JNZ   CPSLP
 09B2				CPSLP_RET:
 09B2  C3			   RET

 09B3				GETLAB:
 09B3  66| BB 00000000		   MOV   EBX,0
 09B9  66| 89 1E 1094 R		   MOV   [LABPT],EBX
 09BE  C6 06 1035 R FF		   MOV   BYTE PTR[FLAG],-1
 09C3  B6 00			   MOV   DH,0
 09C5  A0 10B0 R		   MOV   AL,[CHR]
 09C8  3C 21			   CMP   AL,' '+1
 09CA  72 03			   JC NOT1
 09CC  80 CE 01			   OR DH,001H
 09CF				NOT1:
 09CF  E8 FD2E			   CALL  GETLET
 09D2  72 DE			   JC CPSLP_RET
 09D4  3C 3A			   CMP   AL,':'
 09D6  75 05			   JNZ   LABCHK
 09D8  E8 F843			   CALL  NEXTCHR
 09DB  EB 07			   JMP _LABEL
 09DD				LABCHK:
 09DD  0A C0			   OR AL,AL
 09DF  F6 C6 01			   TEST  DH,001H
 09E2  74 CE			   JZ CPSLP_RET
 09E4				_LABEL:
 09E4  A0 10F4 R		   MOV   AL,[CHKLAB]
 09E7  0A C0			   OR AL,AL
 09E9  74 03			   JZ _LABEL_SKIP
 09EB  E9 FD12			   JMP   GETLET
 09EE				_LABEL_SKIP:
 09EE  E8 FF18			   CALL  LOOKUP ;EBX:Left link,EDX:Last top
 09F1  B1 0B			   MOV   CL,11
 09F3  75 21			   JNZ   ERR5
 09F5  66| 8B 16 108C R		   MOV   EDX,[PC]
 09FA  67& 66| C7 03		   MOV   DWORD PTR [EBX],1 ;SET FLAG
       00000001
 0A02  66| 43			   INC   EBX
 0A04  66| 43			   INC   EBX
 0A06  66| 43			   INC   EBX
 0A08  66| 43			   INC   EBX
 0A0A  67& 66| 89 13		   MOV   [EBX],EDX	;Set Left lik with last top
 0A0E  66| 89 1E 1094 R		   MOV   [LABPT],EBX
 0A13  E9 FCEA			   JMP   GETLET

 0A16  E9 F801			ERR5: JMP   ERROR

 0A19				ASMLIN:
 0A19  C6 06 1034 R 01		   MOV   BYTE PTR[MAXFLG],1 ;Allow only B and W flags normally
 0A1E  66| 8B 1E 108C R		   MOV   EBX,[PC]
 0A23  66| 89 1E 1090 R		   MOV   [OLDPC],EBX
 0A28  E8 FF88			   CALL  GETLAB
 0A2B  73 03			   JNC   ASMLIN_SKIP
 0A2D  E9 F799			   JMP   ENDLN
 0A30				ASMLIN_SKIP:
 0A30  66| BB 00001036 R	   MOV   EBX,OFFSET LENID
 0A36  67& 8A 03		   MOV   AL,[EBX]
 0A39  B1 0C			   MOV   CL,12
 0A3B  2C 02			   SUB   AL,2
 0A3D  8A E8			   MOV   CH,AL
 0A3F  72 D5			   JC ERR5
 0A41  66| 43			   INC   EBX
 0A43  66| 43			   INC   EBX
 0A45  66| 43			   INC   EBX
 0A47  66| 43			   INC   EBX
 0A49  67& 80 3B 66		   CMP   BYTE PTR[EBX],"f"   ;See if an 8087 mnemonic
 0A4D  74 72			   JZ NDPOP
 0A4F  3C 05			   CMP   AL,5
 0A51  73 C3			   JNC   ERR5

 0A53				LOCATE_OPTAB:
 0A53  66| 33 C0		   XOR   EAX,EAX
 0A56  67& 8A 03		   MOV   AL,[EBX] ;EBX:LABEL HEAP
 0A59  2C 61			   SUB   AL,'a'
 0A5B  8A C8			   MOV   CL,AL ;CL=AL=ch-'a'
				   ;ADD   AL,AL ;
				   ;ADD   AL,AL ;
 0A5D  66| 03 C0		   ADD   EAX,EAX
 0A60  66| 03 C0		   ADD   EAX,EAX

 0A63  02 C1			   ADD   AL,CL
 0A65  02 C5			   ADD   AL,CH
				   ;ADD   AL,AL

				   ;AL=(AL*5+CH)*4
 0A67  66| 03 C0		   ADD   EAX,EAX
 0A6A  66| 03 C0		   ADD   EAX,EAX

 0A6D  66| BB 000005EC R	   MOV   EBX,OPTAB
 0A73  66| 33 D2		   XOR   EDX,EDX
 0A76  66| 8B D0		   MOV   EDX,EAX
 0A79  66| 03 DA		   ADD   EBX,EDX
				   
 0A7C  67& 66| 8B 03		   MOV   EAX,[EBX];OPTAB+AL =PTR:E3:EQU
 0A80  FE C5			   INC   CH ;CH=1+1
 0A82  8A CD			   MOV   CL,CH ;CL=CH

 0A84  66| 8B D8		   MOV   EBX,EAX
 0A87  67& 8A 23		   MOV   AH,[EBX] ;OPERANDS COUNT
 0A8A  66| 43			   INC   EBX ;Pointer to following string
 0A8C  0A E4			   OR AH,AH
 0A8E  74 25			   JZ OPERR ;AH SHOULD NOT BE 0
 0A90				FINDOP:
 0A90  8A E9			   MOV   CH,CL
 0A92  66| BA 0000103B R	   MOV   EDX,OFFSET ID+1
 0A98  66| 95			   XCHG  EAX,EBP    ;Save count of opcodes in EBP
 0A9A  E8 FF02			   CALL  CPSLP ;CMP EBX,EDX, CH=LENGTH; EBX++,EDX++
 0A9D  74 1B			   JZ HAVOP
 0A9F  66| 95			   XCHG  EAX,EBP
 0AA1  66| 33 D2		   XOR   EDX,EDX
 0AA4  8A D5			   MOV   DL,CH
 0AA6  66| 42			   INC   EDX
 0AA8  66| 42			   INC   EDX
				   ;4 bytes ptr
 0AAA  66| 42			   INC   EDX
 0AAC  66| 42			   INC   EDX

 0AAE  66| 03 DA		   ADD   EBX,EDX
 0AB1  FE CC			   DEC   AH
 0AB3  75 DB			   JNZ   FINDOP
 0AB5				OPERR:
 0AB5  B1 0C			   MOV   CL,12
 0AB7  E9 F760			   JMP   ERROR

 0ABA				HAVOP:
				   ;EBX:Pointer to function
				   ;EBX+4:
 0ABA  67& 8A 43 04		   MOV   AL,[EBX+4]   ;Get opcode
 0ABE  67& FF 2B		   JMP   DWORD PTR[EBX]

 0AC1				NDPOP:   ;First letter is "F" so must be 8087 opcode ("Numeric Data Processor")
 0AC1  C6 06 1034 R 04		   MOV   BYTE PTR[MAXFLG],4 ;Allow all type flags
 0AC6  66| 43			   INC   EBX
 0AC8  67& 80 3B 6E		   CMP   BYTE PTR[EBX],"n"   ;"No-wait" form?
 0ACC  B4 00			   MOV   AH,0
 0ACE  75 06			   JNZ   SAVNFLG
 0AD0  B4 01			   MOV   AH,1
 0AD2  FE C8			   DEC   AL
 0AD4  66| 43			   INC   EBX    ;Skip over the "N"
 0AD6				SAVNFLG:
 0AD6  88 26 1109 R		   MOV   BYTE PTR[NOWAIT],AH ;0 for wait, 1 for no wait
 0ADA  3C 01			   CMP   AL,1
 0ADC  72 D7			   JB OPERR    ;Not enough char left for valid opcode?
 0ADE  3C 05			   CMP   AL,5
 0AE0  77 D3			   JA OPERR    ;Too many?
 0AE2  98			   CBW
 0AE3  66| 92			   XCHG  EAX,EDX    ;Save length in EDX
 0AE5  66| 8B F2		   MOV   ESI,EDX
 0AE8  67& 80 0C 1E 80		   OR BYTE PTR[ESI+EBX],80H   ;Set high bit of last character
 0AED  67& 8A 03		   MOV   AL,[EBX]     ;Get first char of opcode
 0AF0  66| 43			   INC   EBX
 0AF2  2C 61			   SUB   AL,"a"
 0AF4  72 38			   JB TRY2XM1     ;Go see if opcode starts with "2"
 0AF6  3C 19			   CMP   AL,"z"-"a"
 0AF8  77 BB			   JA OPERR
 0AFA  98			   CBW
 0AFB  66| D1 E0		   SHL   EAX,1     ;Double to index into address table
 0AFE  66| D1 E0		   SHL   EAX,1
 0B01  66| 96			   XCHG  EAX,ESI    ;Put in index register
 0B03  66| BF 000007F4 R	   MOV   EDI,OFFSET NDPTAB ;Get start of opcode table for this letter
 0B09  66| 03 FE		   ADD   EDI,ESI
 0B0C				LOOKNDP:
 0B0C  67& 8A 27		   MOV   AH,[EDI]     ;Number of opcodes starting with this letter
 0B0F  0A E4			   OR AH,AH
 0B11  74 A2			   JZ OPERR    ;Any start with this letter?
 0B13				FNDNDP:
 0B13  66| 47			   INC   EDI
 0B15  66| 8B F3		   MOV   ESI,EBX    ;Pointer to start of opcode
 0B18  66| 8B CA		   MOV   ECX,EDX    ;Get length of opcode
 0B1B  F3/ A6			   REPE CMPSB       ;Compare opcode to table entry
 0B1D  74 3F			   JZ HAVNDP
 0B1F  66| 4F			   DEC   EDI    ;Back up in case that was last letter
 0B21  B0 80			   MOV   AL,80H      ;Look for char with high bit set
 0B23				ENDOP:
 0B23  AE			   SCASB
 0B24  77 FD			   JA ENDOP
 0B26  66| 47			   INC   EDI    ;Skip over info about opcode
 0B28  FE CC			   DEC   AH
 0B2A  75 E7			   JNZ   FNDNDP
 0B2C  EB 87			OPERRJ:  JMP OPERR

 0B2E				TRY2XM1:
 0B2E  3C D1			   CMP   AL,"2"-"a"
 0B30  75 83			   JNZ   OPERR
 0B32  66| BF 00000479 R	   MOV   EDI,XM1
 0B38  EB D2			   JMP LOOKNDP

 0B3A				SPECIALOP:
 0B3A  24 07			   AND   AL,7     ;Mask to special op number
 0B3C  74 18			   JZ _FWAIT      ;If zero, go handle FWAIT
				;Handle FNOP
 0B3E  80 3E 1109 R 00		   CMP   BYTE PTR[NOWAIT],0 ;Was "N" present (If not opcode was "FOP")
 0B43  0F 84 FF6E		   JZ OPERR
 0B47  B0 9B			   MOV   AL,9BH      ;Need Wait opcode after all
 0B49  E8 0188			   CALL  PUT
 0B4C  B0 D9			   MOV   AL,0D9H
 0B4E  E8 0183			   CALL  PUT
 0B51  B0 D0			   MOV   AL,0D0H
 0B53  E9 017E			   JMP   PUT

 0B56				_FWAIT:
 0B56  80 3E 1109 R 00		   CMP   BYTE PTR[NOWAIT],0 ;"FNWAIT" not legal
 0B5B  75 CF			   JNZ   OPERRJ
 0B5D  C3			   RET         ;Nothing to do - "WAIT" already sent

 0B5E				HAVNDP:
 0B5E  66| 8B F7		   MOV   ESI,EDI
 0B61  80 3E 1109 R 00		   CMP   BYTE PTR[NOWAIT],0
 0B66  75 05			   JNZ   NWAIT
 0B68  B0 9B			   MOV   AL,9BH      ;Wait opcode
 0B6A  E8 0167			   CALL  PUT
 0B6D				NWAIT:
 0B6D  AD			   LODSW       ;Get opcode info
 0B6E  A8 F8			   TEST  AL,0F8H     ;Any operand bits set?
 0B70  74 73			   JZ NOOPS    ;If no operands, output code
 0B72  A8 78			   TEST  AL,78H      ;Special case?
 0B74  74 C4			   JZ SPECIALOP
 0B76  66| 50			   PUSH  EAX
 0B78  E8 FAAB			   CALL  GETSYM      ;See if any operands
 0B7B  66| 59			   POP   ECX
 0B7D  3C 3B			   CMP   AL,";"
 0B7F  74 5C			   JZ NOOPCHK
 0B81  3C 0D			   CMP   AL,EOL
 0B83  74 58			   JZ NOOPCHK
 0B85  3C 06			   CMP   AL,FREG     ;Is it 8087 register?
 0B87  0F 85 0080		   JNZ   MEMOP
 0B8B  66| 91			   XCHG  EAX,ECX
 0B8D  A8 40			   TEST  AL,ONEREG   ;One register OK as operand?
 0B8F  75 3B			   JNZ   PUTREG      ;Yes - save it
 0B91  A8 20			   TEST  AL,20H      ;Memory-only operation?
 0B93  B1 14			   MOV   CL,20
 0B95  75 71			   JNZ   ERRJ4
 0B97  A8 18			   TEST  AL,18H      ;Two-register operation?
 0B99  7A 6D			   JPE   ERRJ4    ;Must be exactly one bit set
 0B9B  66| 52			   PUSH  EDX    ;Save register number
 0B9D  66| 50			   PUSH  EAX    ;Save opcode
 0B9F  E8 FA84			   CALL  GETSYM
 0BA2  3C 2C			   CMP   AL,","
 0BA4  B1 15			   MOV   CL,15H
 0BA6  75 60			   JNZ   ERRJ4
 0BA8  E8 FA7B			   CALL  GETSYM
 0BAB  B1 14			   MOV   CL,20
 0BAD  3C 06			   CMP   AL,FREG
 0BAF  75 57			   JNZ   ERRJ4
 0BB1  66| 58			   POP   EAX
 0BB3  66| 5B			   POP   EBX
 0BB5  34 02			   XOR   AL,2     ;Flip "POP" bit
 0BB7  24 FB			   AND   AL,0FBH     ;Reset direction bit to ST(0)
 0BB9  0A DB			   OR BL,BL    ;Is first register ST(0)?
 0BBB  74 0B			   JZ ST0DEST
 0BBD  66| 87 D3		   XCHG  EDX,EBX
 0BC0  0A DB			   OR BL,BL    ;One of these must be ST(0)
 0BC2  75 44			   JNZ   ERRJ4
 0BC4  34 04			   XOR   AL,4     ;Flip direction
 0BC6  EB 04			   JMP   PUTREG
 0BC8				ST0DEST:
 0BC8  A8 02			   TEST  AL,2     ;Is POP bit set?
 0BCA  75 3C			   JNZ   ERRJ4    ;Don't allow destination ST(0) then pop
 0BCC				PUTREG:
 0BCC  80 E4 F8			   AND   AH,0F8H     ;Zero out register field
 0BCF  0A E2			   OR AH,DL
 0BD1  80 CC C0			   OR AH,0C0H
 0BD4  66| 50			   PUSH  EAX
 0BD6  E8 FA4D			   CALL  GETSYM      ;Get to next symbol
 0BD9  66| 58			   POP   EAX
 0BDB  EB 08			   JMP   NOOPS

 0BDD				NOOPCHK:
 0BDD  66| 91			   XCHG  EAX,ECX
 0BDF  A8 80			   TEST  AL,80H      ;Is no operands OK?
 0BE1  B1 14			   MOV   CL,20
 0BE3  75 23			   JNZ   ERRJ4
 0BE5				NOOPS:
				;First test for FDIV or FSUB and reverse "R" bit if "D" bit is set
 0BE5  66| 50			   PUSH  EAX
 0BE7  66| 25 0000E005		   AND   EAX,0E005H
 0BED  66| 3D 0000E004		   CMP   EAX,0E004H
 0BF3  66| 58			   POP   EAX
 0BF5  75 03			   JNZ   NOREV
 0BF7  80 F4 08			   XOR   AH,8     ;Reverse "R" bit
 0BFA				NOREV:
 0BFA  24 07			   AND   AL,7
 0BFC  0C D8			   OR AL,0D8H     ;ESC hook
 0BFE  E8 00D3			   CALL  PUT
 0C01  8A C4			   MOV   AL,AH
 0C03  E9 00CE			   JMP   PUT

 0C06				BADFLAG:
 0C06  B1 20			   MOV   CL,20H
 0C08  E9 F60F			ERRJ4:   JMP   ERROR

 0C0B				MEMOP:
 0C0B  66| 51			   PUSH  ECX    ;Save opcode
 0C0D  E8 F7AE			   CALL  GETOP1      ;Get memory operand
 0C10  3C 00			   CMP   AL,UNDEFID  ;Is it?
 0C12  B1 14			   MOV   CL,20
 0C14  75 F2			   JNZ   ERRJ4
 0C16  66| 58			   POP   EAX
 0C18  A8 20			   TEST  AL,20H      ;Does it have memory format field?
 0C1A  75 08			   JNZ   GETFORMAT
 0C1C  A8 08			   TEST  AL,8     ;Check if any memory operand legal
 0C1E  74 E8			   JZ ERRJ4
 0C20  A8 10			   TEST  AL,10H      ;Check for 2-op arithmetic
 0C22  75 21			   JNZ   PUTMEM      ;If not, just use as plain memory op
 0C24				GETFORMAT:
 0C24  24 F9			   AND   AL,0F9H     ;Zero memory format bits
 0C26  8A 0E 1035 R		   MOV   CL,[FLAG]
 0C2A  FE C9			   DEC   CL    ;Must now be in range 0-3
 0C2C  7C D8			   JL BADFLAG
 0C2E  8A E8			   MOV   CH,AL    ;Save opcode byte
 0C30  D0 E8			   SHR   AL,1     ;Put format bits in bits 2 & 3
 0C32  24 0C			   AND   AL,0CH
 0C34  0A C1			   OR AL,CL    ;Combine format bits with flag
 0C36  66| BB 00000C55 R	   MOV   EBX,FORMATTAB
 0C3C  D7			   XLATB
 0C3D  0A C0			   OR AL,AL    ;Valid combination?
 0C3F  78 C5			   JS BADFLAG
 0C41  0A E0			   OR AH,AL    ;Possibly set new bits in second byte
 0C43  0A C5			   OR AL,CH    ;Set memory format bits
 0C45				PUTMEM:
 0C45  24 07			   AND   AL,7
 0C47  0C D8			   OR AL,0D8H
 0C49  E8 0088			   CALL  PUT
 0C4C  8A C4			   MOV   AL,AH
 0C4E  24 38			   AND   AL,38H
 0C50  0A C2			   OR AL,DL    ;Combine addressing mode
 0C52  E9 0164			   JMP   PUTADD

 0C55				FORMATTAB:
				;There are 16 entries in this table. The 4-bit index is built like this:
				;  Bit 3    0 for normal memory ops, 1 if extended is OK
				;  Bit 2    0 for integer, 1 for real
				;  Bit 0 & 1   Flag: 00=W, 01=S, 10=L, 11=T
				;
				;The entries in the table are used as two 3-bit fields. Bits 0-2 are ORed
				;into the first byte of the opcode for the Memory Format field. Bits 3-6
				;are ORed into the second byte to modify the opcode for extended operands.
				;If bit 7 is set, then that combination is illegal.

 0C55  06 02 80 80		   DB 6,2,80H,80H ;Normal integers
 0C59  80 00 04 80		   DB 80H,0,4,80H ;Normal reals
 0C5D  06 02 2E 80		   DB 6,2,2EH,80H ;Extended integers
 0C61  80 00 04 2B		   DB 80H,0,4,2BH ;Extended reals

 0C65				GRP1:
 0C65  66| B9 00008A09		   MOV   ECX,8A09H
 0C6B  E8 F65C			   CALL  MROPS
 0C6E  66| B9 000000C6		   MOV   ECX,0C6H
 0C74  8A C7			   MOV   AL,BH
 0C76  3C 00			   CMP   AL,UNDEFID
 0C78  75 03			   JNZ   L0006
 0C7A  E8 003C			   CALL  STIMM
 0C7D				L0006:   
 0C7D  24 01			   AND   AL,1
 0C7F  74 0A			   JZ BYTIMM
 0C81  B0 B8			   MOV   AL,0B8H
 0C83  0A C3			   OR AL,BL
 0C85  E8 004C			   CALL  PUT
 0C88  E9 00AD			   JMP   PUTWOR

 0C8B				BYTIMM:
 0C8B  B0 B0			   MOV   AL,0B0H
 0C8D  0A C3			   OR AL,BL
 0C8F  E8 0042			   CALL  PUT
 0C92  E9 00AD			PUTBJ:   JMP   PUTBYT

 0C95				IMMED:
 0C95  8A C7			   MOV   AL,BH
 0C97  3C 00			   CMP   AL,UNDEFID
 0C99  74 1E			   JZ STIMM
 0C9B  8A C3			   MOV   AL,BL
 0C9D  0A C0			   OR AL,AL
 0C9F  74 32			   JZ IMM_RET
 0CA1  8A C7			   MOV   AL,BH
 0CA3  E8 001E			   CALL  IMM
 0CA6  0C C0			   OR AL,0C0H
 0CA8  E8 0029			   CALL  PUT
 0CAB				FINIMM:
 0CAB  8A C1			   MOV   AL,CL
 0CAD  66| 59			   POP   ECX
 0CAF  A8 01			   TEST  AL,1
 0CB1  74 DF			   JZ PUTBJ
 0CB3  3C 83			   CMP   AL,83H
 0CB5  74 DB			   JZ PUTBJ
 0CB7  EB 7F			   JMP   PUTWOR

 0CB9				STIMM:
 0CB9  A0 1035 R		   MOV   AL,[FLAG]
 0CBC  E8 0005			   CALL  IMM
 0CBF  E8 00F7			   CALL  PUTADD
 0CC2  EB E7			   JMP FINIMM

 0CC4				IMM:
 0CC4  24 01			   AND   AL,1
 0CC6  0A C1			   OR AL,CL
 0CC8  8A C8			   MOV   CL,AL
 0CCA  E8 0007			   CALL  PUT
 0CCD  8A C5			   MOV   AL,CH
 0CCF  24 38			   AND   AL,38H
 0CD1  0A C3			   OR AL,BL
 0CD3				IMM_RET:
 0CD3  C3			   RET

 0CD4				PUT:
				;Save byte in AL as pure code, with intermediate code bits 00. AL and
				;EDI destroyed, no other registers affected.
 0CD4  66| 53			   PUSH  EBX
 0CD6  66| 51			   PUSH  ECX
 0CD8  B5 00			   MOV   CH,0     ;Flag as pure code
 0CDA  E8 0005			   CALL  GEN
 0CDD  66| 59			   POP   ECX
 0CDF  66| 5B			   POP   EBX
 0CE1  C3			   RET

 0CE2				GEN:
				;Save byte of code in AL, given intermediate code bits in bits 7&8 of CH.
 0CE2  E8 0042			   CALL  PUTINC      ;Save it and bump code pointer
 0CE5				GEN1:
 0CE5  A0 10C3 R		   MOV   AL,BYTE PTR[RELOC]
 0CE8  D0 D5			   RCL   CH,1
 0CEA  D0 D0			   RCL   AL,1
 0CEC  D0 D5			   RCL   CH,1
 0CEE  D0 D0			   RCL   AL,1
 0CF0  A2 10C3 R		   MOV   BYTE PTR[RELOC],AL
 0CF3  66| 8B 1E 10C7 R		   MOV   EBX,BCOUNT
 0CF8  67& FE 0B		   DEC   BYTE PTR[EBX]
 0CFB  75 29			   JNZ   GEN1_RET
 0CFD  67& C6 03 04		   MOV   BYTE PTR[EBX],4
 0D01  66| 8B 1E 10C3 R		   MOV   EBX,RELOC
 0D06  67& 8A 03		   MOV   AL,[EBX]
 0D09  67& C6 03 00		   MOV   BYTE PTR[EBX],0
 0D0D  66| 8B 3E 1111 R		   MOV   EDI,[IY]
 0D12  67& 88 07		   MOV   [EDI],AL
 0D15  66| 8B 1E 10BE R		   MOV   EBX,[CODE]
 0D1A  66| 89 1E 1111 R		   MOV   [IY],EBX
 0D1F  66| 43			   INC   EBX
 0D21  66| 89 1E 10BE R		   MOV   [CODE],EBX
 0D26				GEN1_RET:
 0D26  C3			   RET

 0D27				PUTINC:
 0D27  66| FF 06 108C R		   INC   DWORD PTR[PC]
 0D2C				PUTCD:
 0D2C  66| 8B 3E 10BE R		   MOV   EDI,[CODE]
 0D31  AA			   STOSB
 0D32  66| 89 3E 10BE R		   MOV   [CODE],EDI
 0D37  C3			   RET

 0D38				PUTWOR:
				;Save the word value described by [DLABEL] and [DATA] as code. If defined,
				;two bytes of pure code will be produced. Otherwise, appropriate intermediate
				;code will be generated.
 0D38  66| 51			   PUSH  ECX
 0D3A  B5 80			   MOV   CH,80H
 0D3C  66| 52			   PUSH  EDX
 0D3E  66| 53			   PUSH  EBX
 0D40  EB 25			   JMP PUTBW

 0D42				PUTBYT:
				;Same as PUTWOR, above, but for byte value.
 0D42  66| 51			   PUSH  ECX
 0D44  B5 40			   MOV   CH,40H
 0D46  66| 52			   PUSH  EDX
 0D48  66| 53			   PUSH  EBX
 0D4A  66| 8B 1E 10A4 R		   MOV   EBX,[DLABEL]
 0D4F  8A C7			   MOV   AL,BH
 0D51  0A C3			   OR AL,BL
 0D53  75 12			   JNZ   PUTBW
 0D55  66| 8B 1E 10A0 R		   MOV   EBX,[_DATA]
 0D5A  0A C7			   OR AL,BH
 0D5C  74 09			   JZ PUTBW
 0D5E  FE C7			   INC   BH
 0D60  74 05			   JZ PUTBW
 0D62  B1 1F			   MOV   CL,31
 0D64  E9 F4B3			   JMP   ERROR
 0D67				PUTBW:
 0D67  66| 8B 16 10A4 R		   MOV   EDX,[DLABEL]
 0D6C  66| 8B 1E 10A0 R		   MOV   EBX,[_DATA]
 0D71				PUTCHK:
 0D71  66| 0B D2		   OR EDX,EDX
 0D74  74 28			   JZ NOUNDEF
 0D76  8A C2			   MOV   AL,DL
 0D78  E8 FFB1			   CALL  PUTCD
 0D7B  8A C6			   MOV   AL,DH
 0D7D  E8 FFAC			   CALL  PUTCD
 0D80  8A C3			   MOV   AL,BL
 0D82  E8 FFA2			   CALL  PUTINC
 0D85  8A C7			   MOV   AL,BH
 0D87  F6 C5 80			   TEST  CH,080H
 0D8A  74 05			   JZ SMPUT
 0D8C  E8 FF53			   CALL  GEN
 0D8F  EB 06			   JMP PRET
 0D91				SMPUT:
 0D91  E8 FF98			   CALL  PUTCD
 0D94  E8 FF4E			   CALL  GEN1
 0D97				PRET:
 0D97  66| 5B			   POP   EBX
 0D99  66| 5A			   POP   EDX
 0D9B  66| 59			   POP   ECX
 0D9D  C3			   RET

 0D9E				NOUNDEF:
 0D9E  8A C3			   MOV   AL,BL
 0DA0  8A CF			   MOV   CL,BH
 0DA2  66| 51			   PUSH  ECX
 0DA4  B5 00			   MOV   CH,0
 0DA6  E8 FF39			   CALL  GEN
 0DA9  66| 59			   POP   ECX
 0DAB  8A C1			   MOV   AL,CL
 0DAD  F6 C5 80			   TEST  CH,080H
 0DB0  B5 00			   MOV   CH,0
 0DB2  74 E3			   JZ PRET
 0DB4  E8 FF2B			   CALL  GEN
 0DB7  EB DE			   JMP PRET

 0DB9				PUTADD:
				;Save complete addressing mode. Addressing mode is in AL; if this is a register
				;operation (>=C0), then the one byte will be saved as pure code. Otherwise,
				;the details of the addressing mode will be investigated and the optional one-
				;or two-byte displacement will be added, as described by [_ADDR] and [ALABEL].
 0DB9  66| 51			   PUSH  ECX
 0DBB  66| 52			   PUSH  EDX
 0DBD  66| 53			   PUSH  EBX
 0DBF  B5 00			   MOV   CH,0
 0DC1  8A C8			   MOV   CL,AL
 0DC3  E8 FF1C			   CALL  GEN      ;Save the addressing mode as pure code
 0DC6  8A C1			   MOV   AL,CL
 0DC8  B5 80			   MOV   CH,80H
 0DCA  24 C7			   AND   AL,0C7H
 0DCC  3C 06			   CMP   AL,6
 0DCE  74 0A			   JZ TWOBT    ;Direct address?
 0DD0  24 C0			   AND   AL,0C0H
 0DD2  74 C3			   JZ PRET     ;Indirect through reg, no displacement?
 0DD4  3C C0			   CMP   AL,0C0H
 0DD6  74 BF			   JZ PRET     ;Register to register operation?
 0DD8  8A E8			   MOV   CH,AL    ;Save whether one- or two-byte displacement
 0DDA				TWOBT:
 0DDA  66| 8B 1E 1098 R		   MOV   EBX,[_ADDR]
 0DDF  66| 8B 16 109C R		   MOV   EDX,[ALABEL]
 0DE4  EB 8B			   JMP PUTCHK

 0DE6				GRP2:
 0DE6  E8 F5D2			   CALL  GETOP
 0DE9  66| B9 0000FF30		   MOV   ECX,0FF30H
 0DEF  3C 00			   CMP   AL,UNDEFID
 0DF1  74 14			   JZ PMEM
 0DF3  B5 50			   MOV   CH,50H
 0DF5  3C 03			   CMP   AL,XREG
 0DF7  74 19			   JZ PXREG
 0DF9  B5 06			   MOV   CH,6
 0DFB  3C 04			   CMP   AL,SREG
 0DFD  75 03			   JNZ   GRP2_SKIP
 0DFF  E9 0463			   JMP   PACKREG
 0E02				GRP2_SKIP:
 0E02  B1 14			   MOV   CL,20
 0E04  E9 F413			   JMP   ERROR

 0E07				PMEM:
 0E07  8A C5			   MOV   AL,CH
 0E09  E8 FEC8			   CALL  PUT
 0E0C  8A C1			   MOV   AL,CL
 0E0E  0A C2			   OR AL,DL
 0E10  EB A7			   JMP   PUTADD

 0E12				PXREG:
 0E12  8A C5			   MOV   AL,CH
 0E14  0A C2			   OR AL,DL
 0E16  E9 FEBB			   JMP   PUT

 0E19				GRP3:
 0E19  E8 F59F			   CALL  GETOP
 0E1C  66| 52			   PUSH  EDX
 0E1E  E8 F591			   CALL  GETOP2
 0E21  66| 5B			   POP   EBX
 0E23  66| B9 00008614		   MOV   ECX,8614H
 0E29  B0 04			   MOV   AL,SREG
 0E2B  3A C7			   CMP   AL,BH
 0E2D  74 4E			   JZ ERR6
 0E2F  3A C6			   CMP   AL,DH
 0E31  74 4A			   JZ ERR6
 0E33  B0 01			   MOV   AL,CONST
 0E35  3A C7			   CMP   AL,BH
 0E37  74 44			   JZ ERR6
 0E39  3A C6			   CMP   AL,DH
 0E3B  74 40			   JZ ERR6
 0E3D  B0 00			   MOV   AL,UNDEFID
 0E3F  3A C7			   CMP   AL,BH
 0E41  74 2E			   JZ EXMEM
 0E43  3A C6			   CMP   AL,DH
 0E45  74 2D			   JZ EXMEM1
 0E47  8A C7			   MOV   AL,BH
 0E49  3A C6			   CMP   AL,DH
 0E4B  B1 16			   MOV   CL,22
 0E4D  75 2E			   JNZ   ERR6
 0E4F  3C 03			   CMP   AL,XREG
 0E51  74 03			   JZ L0008
 0E53  E8 F4B9			   CALL  RR1
 0E56				L0008:         ;RR1 never returns
 0E56  8A C3			   MOV   AL,BL
 0E58  0A C0			   OR AL,AL
 0E5A  74 0E			   JZ EXACC
 0E5C  66| 87 D3		   XCHG  EDX,EBX
 0E5F  8A C3			   MOV   AL,BL
 0E61  0A C0			   OR AL,AL
 0E63  8A C7			   MOV   AL,BH
 0E65  74 03			   JZ EXACC
 0E67  E8 F4A5			   CALL  RR1
 0E6A				EXACC:
 0E6A  B0 90			   MOV   AL,90H
 0E6C  0A C2			   OR AL,DL
 0E6E  E9 FE63			   JMP   PUT

 0E71				EXMEM:
 0E71  66| 87 D3		   XCHG  EDX,EBX
 0E74				EXMEM1:
 0E74  3A C7			   CMP   AL,BH
 0E76  74 05			   JZ ERR6
 0E78  B1 01			   MOV   CL,1  ;Flag word as OK
 0E7A  E8 F514			   CALL  NOTAC ;NOTAC never returns
 0E7D  E9 F39A			ERR6: JMP   ERROR

 0E80				GRP4:
 0E80  66| 50			   PUSH  EAX
 0E82  E8 F536			   CALL  GETOP
 0E85  66| 59			   POP   ECX
 0E87  86 CD			   XCHG  CL,CH
 0E89  3C 01			   CMP   AL,CONST
 0E8B  74 13			   JZ FIXED
 0E8D  2C 03			   SUB   AL,XREG
 0E8F  FE CA			   DEC   DL
 0E91  FE CA			   DEC   DL
 0E93  0A C2			   OR AL,DL
 0E95  B1 14			   MOV   CL,20
 0E97  75 E4			   JNZ   ERR6
 0E99  8A C5			   MOV   AL,CH
 0E9B  0C 08			   OR AL,8
 0E9D  E9 FE34			   JMP   PUT
 0EA0				FIXED:
 0EA0  8A C5			   MOV   AL,CH
 0EA2  E8 FE2F			   CALL  PUT
 0EA5  E9 FE9A			   JMP   PUTBYT

 0EA8				GRP5:
 0EA8  66| 50			   PUSH  EAX
 0EAA  E8 F50E			   CALL  GETOP
 0EAD  B1 14			   MOV   CL,20
 0EAF  3C 01			   CMP   AL,CONST
 0EB1  75 CA			   JNZ   ERR6
 0EB3  66| 8B 1E 10A4 R		   MOV   EBX,[DLABEL]
 0EB8  8A C7			   MOV   AL,BH
 0EBA  0A C3			   OR AL,BL
 0EBC  B1 1E			   MOV   CL,30
 0EBE  75 BD			   JNZ   ERR6
 0EC0  66| 8B 1E 10A0 R		   MOV   EBX,[_DATA]
 0EC5  66| 58			   POP   EAX
 0EC7  0A C0			   OR AL,AL
 0EC9  74 50			   JZ _ORG
 0ECB  FE C8			   DEC   AL
 0ECD  74 1C			   JZ DSJ
 0ECF  FE C8			   DEC   AL
 0ED1  74 2F			   JZ _EQU
 0ED3  FE C8			   DEC   AL
 0ED5  74 03			   JZ PUTOP
 0ED7  E9 03F3			   JMP   _IF
 0EDA				PUTOP:
 0EDA  B0 FD			   MOV   AL,-3
 0EDC  EB 44			   JMP NEWLOC
 0EDE				_ALIGN:
 0EDE  A0 108C R		   MOV   AL,BYTE PTR[PC]
 0EE1  24 01			   AND   AL,1
 0EE3  74 35			   JZ _EQU_RET
 0EE5  66| BB 00000001		   MOV   EBX,1
 0EEB				DSJ:
 0EEB  66| 87 D3		   XCHG  EDX,EBX
 0EEE  66| 8B 1E 108C R		   MOV   EBX,[PC]
 0EF3  66| 03 DA		   ADD   EBX,EDX
 0EF6  66| 89 1E 108C R		   MOV   [PC],EBX
 0EFB  66| 87 D3		   XCHG  EDX,EBX
 0EFE  B0 FC			   MOV   AL,-4
 0F00  EB 20			   JMP NEWLOC
 0F02				_EQU:
 0F02  66| 87 D3		   XCHG  EDX,EBX
 0F05  66| 8B 1E 1094 R		   MOV   EBX,[LABPT]
 0F0A  8A C7			   MOV   AL,BH
 0F0C  0A C3			   OR AL,BL
 0F0E  B1 22			   MOV   CL,34
 0F10  74 2B			   JZ ERR7
 0F12  67& 88 13		   MOV   [EBX],DL
 0F15  66| 43			   INC   EBX
 0F17  67& 88 33		   MOV   [EBX],DH
 0F1A				_EQU_RET:
 0F1A  C3			   RET
 0F1B				_ORG:
 0F1B  66| 89 1E 108C R		   MOV   [PC],EBX
 0F20  B0 FE			   MOV   AL,-2
 0F22				NEWLOC:
 0F22  E8 FE07			   CALL  PUTCD
 0F25  8A C3			   MOV   AL,BL
 0F27  E8 FE02			   CALL  PUTCD
 0F2A  8A C7			   MOV   AL,BH
 0F2C  E8 FDFD			   CALL  PUTCD
 0F2F  B5 C0			   MOV   CH,0C0H
 0F31  E9 FDB1			   JMP   GEN1
 0F34				GRP6:
 0F34  8A E8			   MOV   CH,AL
 0F36  B1 04			   MOV   CL,4
 0F38  E8 F38F			   CALL  MROPS
 0F3B  B1 17			   MOV   CL,23
 0F3D  E9 F2DA			ERR7: JMP   ERROR
 0F40				GRP7:
 0F40  8A E8			   MOV   CH,AL
 0F42  B1 01			   MOV   CL,1
 0F44  E8 F383			   CALL  MROPS
 0F47  B1 80			   MOV   CL,80H
 0F49  66| 8B 16 10A4 R		   MOV   EDX,[DLABEL]
 0F4E  8A C6			   MOV   AL,DH
 0F50  0A C2			   OR AL,DL
 0F52  75 16			   JNZ   ACCJ
 0F54  66| 87 D3		   XCHG  EDX,EBX
 0F57  66| 8B 1E 10A0 R		   MOV   EBX,[_DATA]
 0F5C  8A C3			   MOV   AL,BL
 0F5E  98			   CBW
 0F5F  66| 3B C3		   CMP   EAX,EBX
 0F62  66| 87 D3		   XCHG  EDX,EBX
 0F65  75 03			   JNZ   ACCJ
 0F67  80 C9 02			   OR CL,002H
 0F6A  E9 00C1			ACCJ: JMP   ACCIMM
 0F6D				GRP8:
 0F6D  8A C8			   MOV   CL,AL
 0F6F  B5 FE			   MOV   CH,0FEH
 0F71  EB 04			   JMP ONEOP
 0F73				GRP9:
 0F73  8A C8			   MOV   CL,AL
 0F75  B5 F6			   MOV   CH,0F6H
 0F77				ONEOP:
 0F77  66| 51			   PUSH  ECX
 0F79  E8 F43F			   CALL  GETOP
 0F7C				ONE:
 0F7C  B1 1A			   MOV   CL,26
 0F7E  3C 01			   CMP   AL,CONST
 0F80  74 BB			   JZ ERR7
 0F82  3C 04			   CMP   AL,SREG
 0F84  B1 16			   MOV   CL,22
 0F86  74 B5			   JZ ERR7
 0F88  66| 59			   POP   ECX
 0F8A  3C 00			   CMP   AL,UNDEFID
 0F8C  74 12			   JZ MOP
 0F8E  24 01			   AND   AL,1
 0F90  74 21			   JZ ROP
 0F92  F6 C1 01			   TEST  CL,001H
 0F95  74 1C			   JZ ROP
 0F97  8A C1			   MOV   AL,CL
 0F99  24 F8			   AND   AL,0F8H
 0F9B  0A C2			   OR AL,DL
 0F9D  E9 FD34			   JMP   PUT
 0FA0				MOP:
 0FA0  A0 1035 R		   MOV   AL,[FLAG]
 0FA3  24 01			   AND   AL,1
 0FA5  0A C5			   OR AL,CH
 0FA7  E8 FD2A			   CALL  PUT
 0FAA  8A C1			   MOV   AL,CL
 0FAC  24 38			   AND   AL,38H
 0FAE  0A C2			   OR AL,DL
 0FB0  E9 FE06			   JMP   PUTADD
 0FB3				ROP:
 0FB3  0A C5			   OR AL,CH
 0FB5  E8 FD1C			   CALL  PUT
 0FB8  8A C1			   MOV   AL,CL
 0FBA  24 38			   AND   AL,38H
 0FBC  0C C0			   OR AL,0C0H
 0FBE  0A C2			   OR AL,DL
 0FC0  E9 FD11			   JMP   PUT
 0FC3				GRP10:
 0FC3  8A C8			   MOV   CL,AL
 0FC5  B5 F6			   MOV   CH,0F6H
 0FC7  66| 51			   PUSH  ECX
 0FC9  E8 F3EF			   CALL  GETOP
 0FCC  B1 14			   MOV   CL,20
 0FCE  8A C2			   MOV   AL,DL
 0FD0  0A C0			   OR AL,AL
 0FD2  75 08			   JNZ   ERRJ1
 0FD4  8A C6			   MOV   AL,DH
 0FD6  3C 03			   CMP   AL,XREG
 0FD8  74 04			   JZ G10
 0FDA  3C 02			   CMP   AL,REG
 0FDC  75 70			ERRJ1:   JNZ   ERR8
 0FDE				G10:
 0FDE  66| 50			   PUSH  EAX
 0FE0  E8 F3D8			   CALL  GETOP
 0FE3  66| 58			   POP   EAX
 0FE5  24 01			   AND   AL,1
 0FE7  A2 1035 R		   MOV   [FLAG],AL
 0FEA  8A C6			   MOV   AL,DH
 0FEC  EB 8E			ONEJ: JMP ONE
 0FEE				GRP11:
 0FEE  E8 FCE3			   CALL  PUT
 0FF1  B0 0A			   MOV   AL,0AH
 0FF3  E9 FCDE			   JMP   PUT
 0FF6				GRP12:
 0FF6  8A C8			   MOV   CL,AL
 0FF8  B5 D0			   MOV   CH,0D0H
 0FFA  66| 51			   PUSH  ECX
 0FFC  E8 F3BC			   CALL  GETOP
 0FFF  A0 10B1 R		   MOV   AL,[SYM]
 1002  3C 2C			   CMP   AL,','
 1004  8A C6			   MOV   AL,DH
 1006  75 E4			   JNZ   ONEJ
 1008  66| 52			   PUSH  EDX
 100A  E8 F3AE			   CALL  GETOP
 100D  2C 02			   SUB   AL,REG
 100F  B1 14			   MOV   CL,20
 1011  FE CA			   DEC   DL
 1013  0A C2			   OR AL,DL
 1015  75 37			   JNZ   ERR8
 1017  66| 5A			   POP   EDX
 1019  8A C6			   MOV   AL,DH
 101B  66| 59			   POP   ECX
 101D  80 CD 02			   OR CH,002H
 1020  66| 51			   PUSH  ECX
 1022  E9 FF57			   JMP   ONE
 1025				GRP13:
 1025  8A E8			   MOV   CH,AL
 1027  B1 01			   MOV   CL,1
 1029  E8 F29E			   CALL  MROPS
 102C  B1 80			   MOV   CL,80H
 102E				ACCIMM:
 102E  E8 FC64			   CALL  IMMED
 1031  80 CD 04			   OR CH,004H
 1034  80 E5 FD			   AND   CH,0FDH
 1037				AIMM:
 1037  8A C7			   MOV   AL,BH
 1039  24 01			   AND   AL,1
 103B  9F			   LAHF
 103C  66| 50			   PUSH  EAX
 103E  0A C5			   OR AL,CH
 1040  E8 FC91			   CALL  PUT
 1043  66| 58			   POP   EAX
 1045  9E			   SAHF
 1046  75 03			   JNZ   AIMM_SKIP
 1048  E9 FCF7			   JMP   PUTBYT
 104B				AIMM_SKIP:
 104B  E9 FCEA			   JMP   PUTWOR

 104E  E9 F1C9			ERR8: JMP   ERROR

 1051				GRP14:
				;JMP and CALL mnemonics
 1051  9F			   LAHF
 1052  86 E0			   XCHG  AH,AL
 1054  66| 50			   PUSH  EAX
 1056  86 E0			   XCHG  AH,AL
 1058  C6 06 1034 R 03		   MOV   BYTE PTR[MAXFLG],3 ;Allow "L" flag
 105D  E8 F35B			   CALL  GETOP
 1060  3C 01			   CMP   AL,CONST
 1062  74 34			   JZ DIRECT
 1064  B1 14			   MOV   CL,20
 1066  3C 02			   CMP   AL,REG
 1068  74 E4			   JZ ERR8
 106A  3C 04			   CMP   AL,SREG
 106C  74 E0			   JZ ERR8
 106E  3C 03			   CMP   AL,XREG
 1070  75 03			   JNZ   NOTRG
 1072  80 CA C0			   OR DL,0C0H
 1075				NOTRG:
				;Indirect jump. DL has addressing mode.
 1075  B0 FF			   MOV   AL,0FFH
 1077  E8 FC5A			   CALL  PUT
 107A  66| 58			   POP   EAX
 107C  86 E0			   XCHG  AH,AL
 107E  9E			   SAHF
 107F  24 38			   AND   AL,38H
 1081  0A C2			   OR AL,DL
 1083  8A 2E 1035 R		   MOV   CH,[FLAG]
 1087  80 FD 03			   CMP   CH,3     ;Flag "L" present?
 108A  74 09			   JZ PUTADDJ     ;If so, do inter-segment
 108C  B1 27			   MOV   CL,27H
 108E  80 FD FF			   CMP   CH,-1    ;Better not be a flag
 1091  75 BB			   JNZ   ERR8
 1093  24 F7			   AND   AL,0F7H     ;Convert to intra-segment
 1095				PUTADDJ:
 1095  E9 FD21			   JMP   PUTADD
 1098				DIRECT:
 1098  A0 10B1 R		   MOV   AL,[SYM]
 109B  3C 2C			   CMP   AL,','
 109D  74 21			   JZ LONGJ
 109F  66| 58			   POP   EAX
 10A1  86 E0			   XCHG  AH,AL
 10A3  9E			   SAHF
 10A4  FE C8			   DEC   AL
 10A6  3C E9			   CMP   AL,0E9H
 10A8  74 02			   JZ GOTOP
 10AA  B0 E8			   MOV   AL,0E8H
 10AC				GOTOP:
 10AC  E8 FC25			   CALL  PUT
 10AF  66| 8B 16 108C R		   MOV   EDX,[PC]
 10B4  66| 42			   INC   EDX
 10B6  66| 42			   INC   EDX
 10B8  66| 29 16 10A0 R		   SUB   [_DATA],EDX
 10BD  E9 FC78			   JMP   PUTWOR
 10C0				LONGJ:
 10C0  66| 58			   POP   EAX
 10C2  86 E0			   XCHG  AH,AL
 10C4  9E			   SAHF
 10C5  E8 FC0C			   CALL  PUT
 10C8  E8 FC6D			   CALL  PUTWOR
 10CB  E8 F2ED			   CALL  GETOP
 10CE  B1 14			   MOV   CL,20
 10D0  3C 01			   CMP   AL,CONST
 10D2  0F 85 FF78		   JNZ   ERR8
 10D6  E9 FC5F			   JMP   PUTWOR

 10D9				GRP16:
				;RET mnemonic
 10D9  9F			   LAHF
 10DA  86 E0			   XCHG  AH,AL
 10DC  66| 50			   PUSH  EAX
 10DE  86 E0			   XCHG  AH,AL
 10E0  E8 F543			   CALL  GETSYM
 10E3  3C 05			   CMP   AL,5
 10E5  74 1D			   JZ LONGR
 10E7  3C 0D			   CMP   AL,EOL
 10E9  74 44			   JZ NODEC
 10EB  3C 3B			   CMP   AL,';'
 10ED  74 40			   JZ NODEC
 10EF				GETSP:
 10EF  E8 F2CC			   CALL  GETOP1
 10F2  66| 59			   POP   ECX
 10F4  3C 01			   CMP   AL,CONST
 10F6  B1 14			   MOV   CL,20
 10F8  75 74			   JNZ   ERR9
 10FA  8A C5			   MOV   AL,CH
 10FC  24 FE			   AND   AL,0FEH
 10FE  E8 FBD3			   CALL  PUT
 1101  E9 FC34			   JMP   PUTWOR
 1104				LONGR:
 1104  80 FA 03			   CMP   DL,3     ;Is flag "L"?
 1107  B1 27			   MOV   CL,27H
 1109  0F 85 0094		   JNZ   ERR10    ;If not, bad flag
 110D  66| 58			   POP   EAX
 110F  86 E0			   XCHG  AH,AL
 1111  9E			   SAHF
 1112  0C 08			   OR AL,8
 1114  9F			   LAHF
 1115  86 E0			   XCHG  AH,AL
 1117  66| 50			   PUSH  EAX
 1119  86 E0			   XCHG  AH,AL
 111B				NOTLON:
 111B  E8 F508			   CALL  GETSYM
 111E  3C 0D			   CMP   AL,EOL
 1120  74 3A			   JZ DORET
 1122  3C 3B			   CMP   AL,';'
 1124  74 36			   JZ DORET
 1126  3C 2C			   CMP   AL,','
 1128  75 03			   JNZ   L0011
 112A  E8 F4F9			   CALL  GETSYM
 112D				L0011:   
 112D  EB C0			   JMP GETSP
 112F				NODEC:
				;Return is intra-segment (short) without add to ESP. 
				;Record position for RET symbol.
 112F  66| 8B 1E 108C R		   MOV   EBX,[PC]
 1134  66| 89 1E 10F9 R		   MOV   [LSTRET],EBX
 1139  66| 87 D3		   XCHG  EDX,EBX
 113C  66| 8B 1E 10FD R		   MOV   EBX,[RETPT]
 1141  8A C7			   MOV   AL,BH
 1143  0A C3			   OR AL,BL
 1145  74 15			   JZ DORET
 1147  67& C6 03 01		   MOV   BYTE PTR[EBX],1
 114B  66| 43			   INC   EBX
 114D  67& 66| 89 13		   MOV   [EBX],EDX
 1151  66| BB 00000000		   MOV   EBX,0
 1157  66| 89 1E 10FD R		   MOV   [RETPT],EBX
 115C				DORET:
 115C  66| 58			   POP   EAX
 115E  86 E0			   XCHG  AH,AL
 1160  9E			   SAHF
 1161  E9 FB70			   JMP   PUT

 1164				GRP17:
 1164  E8 FB6D			   CALL  PUT
 1167  E8 F251			   CALL  GETOP
 116A  3C 01			   CMP   AL,CONST
 116C  B1 14			   MOV   CL,20
 116E  75 31			ERR9: JNZ   ERR10
 1170  66| 8B 1E 10A0 R		   MOV   EBX,[_DATA]
 1175  66| 8B 16 108C R		   MOV   EDX,[PC]
 117A  66| 42			   INC   EDX
 117C  66| 2B DA		   SUB   EBX,EDX
 117F  66| 89 1E 10A0 R		   MOV   [_DATA],EBX
 1184  E8 FBBB			   CALL  PUTBYT
 1187  66| 8B 1E 10A4 R		   MOV   EBX,[DLABEL]
 118C  8A C7			   MOV   AL,BH
 118E  0A C3			   OR AL,BL
 1190  75 12			   JNZ   ERR9_RET
 1192  66| 8B 1E 10A0 R		   MOV   EBX,[_DATA]
 1197  8A C3			   MOV   AL,BL
 1199  98			   CBW
 119A  66| 3B C3		   CMP   EAX,EBX    ;Signed 8-bit number?
 119D  74 05			   JZ ERR9_RET
 119F  B1 1F			   MOV   CL,31
 11A1  E9 F076			ERR10:   JMP   ERROR
 11A4				ERR9_RET:
 11A4  C3			   RET
 11A5				GRP18:
 11A5  E8 F213			   CALL  GETOP
 11A8  3C 01			   CMP   AL,CONST
 11AA  B1 14			   MOV   CL,20
 11AC  75 F3			   JNZ   ERR10
 11AE  66| 8B 1E 10A4 R		   MOV   EBX,[DLABEL]
 11B3  8A C7			   MOV   AL,BH
 11B5  0A C3			   OR AL,BL
 11B7  75 15			   JNZ   GENINT
 11B9  66| 8B 1E 10A0 R		   MOV   EBX,[_DATA]
 11BE  66| BA 00000003		   MOV   EDX,3
 11C4  66| 1B DA		   SBB   EBX,EDX
 11C7  75 05			   JNZ   GENINT
 11C9  B0 CC			   MOV   AL,0CCH
 11CB  E9 FB06			   JMP   PUT
 11CE				GENINT:
 11CE  B0 CD			   MOV   AL,0CDH
 11D0  E8 FB01			   CALL  PUT
 11D3  E9 FB6C			   JMP   PUTBYT

 11D6				GRP19:   ;ESC opcode
 11D6  E8 F1E2			   CALL  GETOP
 11D9  B1 14			   MOV   CL,20
 11DB  3C 01			   CMP   AL,CONST
 11DD  75 40			   JNZ   ERRJ     ;First operand must be immediate
 11DF  B1 1E			   MOV   CL,1EH
 11E1  66| F7 06 10A4 R		   TEST  DWORD PTR[DLABEL],-1 ;See if all labels have been defined
       0000FFFF
 11EA  75 33			   JNZ   ERRJ
 11EC  66| A1 10A0 R		   MOV   EAX,[_DATA]
 11F0  66| 83 F8 40		   CMP   EAX,64    ;Must only be 6 bits
 11F4  B1 1F			   MOV   CL,1FH
 11F6  73 27			   JNB   ERRJ
 11F8  8A D8			   MOV   BL,AL    ;Save for second byte
 11FA  D0 E8			   SHR   AL,1
 11FC  D0 E8			   SHR   AL,1
 11FE  D0 E8			   SHR   AL,1
 1200  0C D8			   OR AL,0D8H     ;ESC opcode
 1202  E8 FACF			   CALL  PUT
 1205  66| 53			   PUSH  EBX
 1207  E8 F1A8			   CALL  GETOP2
 120A  66| 5B			   POP   EBX
 120C  80 E3 07			   AND   BL,7     ;Low 3 bits of first operand
 120F  D0 E3			   SHL   BL,1
 1211  D0 E3			   SHL   BL,1
 1213  D0 E3			   SHL   BL,1
 1215  3C 00			   CMP   AL,UNDEFID  ;Check for memory operand
 1217  74 09			   JZ ESCMEM
 1219  3C 01			   CMP   AL,CONST ;Check for another immediate
 121B  74 0C			   JZ ESCIMM
 121D  B1 14			   MOV   CL,20
 121F  E9 EFF8			ERRJ: JMP   ERROR

 1222				ESCMEM:
 1222  0A DA			   OR BL,DL    ;Combine mode with first operand
 1224  8A C3			   MOV   AL,BL
 1226  E9 FB90			   JMP   PUTADD

 1229				ESCIMM:
 1229  B1 1E			   MOV   CL,1EH
 122B  66| F7 06 10A4 R		   TEST  DWORD PTR[DLABEL],-1 ;See if second operand is fully defined
       0000FFFF
 1234  75 E9			   JNZ   ERRJ
 1236  66| A1 10A0 R		   MOV   EAX,[_DATA]
 123A  B1 1F			   MOV   CL,1FH
 123C  66| 83 F8 08		   CMP   EAX,8     ;Must only be 3 bit value
 1240  73 DD			   JNB   ERRJ
 1242  0A C3			   OR AL,BL    ;Combine first and second operands
 1244  0C C0			   OR AL,0C0H     ;Force "register" mode
 1246  E9 FA8B			   JMP   PUT

 1249				GRP20:
 1249  8A E8			   MOV   CH,AL
 124B  B1 01			   MOV   CL,1
 124D  E8 F07A			   CALL  MROPS
 1250  B1 F6			   MOV   CL,0F6H
 1252  E8 FA40			   CALL  IMMED
 1255  B5 A8			   MOV   CH,0A8H
 1257  E9 FDDD			   JMP   AIMM
 125A				GRP21:
 125A  E8 F15E			   CALL  GETOP
 125D  3C 04			   CMP   AL,SREG
 125F  B1 1C			   MOV   CL,28
 1261  75 BC			   JNZ   ERRJ
 1263  B5 26			   MOV   CH,26H
 1265				PACKREG:
 1265  8A C2			   MOV   AL,DL
 1267  02 C0			   ADD   AL,AL
 1269  02 C0			   ADD   AL,AL
 126B  02 C0			   ADD   AL,AL
 126D  0A C5			   OR AL,CH
 126F  E9 FA62			   JMP   PUT
 1272				GRP22:
 1272  E8 F146			   CALL  GETOP
 1275  66| B9 00008F00		   MOV   ECX,8F00H
 127B  3C 00			   CMP   AL,UNDEFID
 127D  75 03			   JNZ   GRP22_SKIP
 127F  E9 FB85			   JMP   PMEM
 1282				GRP22_SKIP:
 1282  B5 58			   MOV   CH,58H
 1284  3C 03			   CMP   AL,XREG
 1286  75 03			   JNZ   GRP22_SKIP2
 1288  E9 FB87			   JMP   PXREG
 128B				GRP22_SKIP2:
 128B  B5 07			   MOV   CH,7
 128D  3C 04			   CMP   AL,SREG
 128F  74 D4			   JZ PACKREG
 1291  B1 14			   MOV   CL,20
 1293  E9 EF84			ERR11:   JMP   ERROR
 1296				GRP23:
 1296  A2 10C2 R		   MOV   [DATSIZ],AL
 1299				GETDAT:
 1299  E8 F38A			   CALL  GETSYM
 129C  B0 02			   MOV   AL,2
 129E  E8 F133			   CALL  VAL1
 12A1  A0 10B1 R		   MOV   AL,[SYM]
 12A4  3C 2C			   CMP   AL,','
 12A6  A0 10C2 R		   MOV   AL,[DATSIZ]
 12A9  75 05			   JNZ   ENDDAT
 12AB  E8 0015			   CALL  SAVDAT
 12AE  EB E9			   JMP GETDAT
 12B0				ENDDAT:
 12B0  3C 02			   CMP   AL,2
 12B2  75 0F			   JNZ   SAVDAT
 12B4  66| 8B 1E 10A0 R		   MOV   EBX,[_DATA]
 12B9  9F			   LAHF
 12BA  80 CB 80			   OR BL,080H
 12BD  9E			   SAHF
 12BE  66| 89 1E 10A0 R		   MOV   [_DATA],EBX
 12C3				SAVDAT:
 12C3  0A C0			   OR AL,AL
 12C5  74 03			   JZ SAVDAT_SKIP
 12C7  E9 FA78			   JMP   PUTBYT
 12CA				SAVDAT_SKIP:
 12CA  E9 FA6B			   JMP   PUTWOR
 12CD				_IF:
 12CD  66| 0B DB		   OR EBX,EBX
 12D0  74 05			   JZ SKIPCD
 12D2  FE 06 10F3 R		   INC   BYTE PTR[IFFLG]
 12D6  C3			   RET

 12D7				SKIPCD:
 12D7  FE 06 10F4 R		   INC   BYTE PTR[CHKLAB]
 12DB				SKIPLP:
 12DB  32 C0			   XOR   AL,AL
 12DD  E8 EEF5			   CALL  NEXLIN
 12E0  E8 EF3B			   CALL  NEXTCHR
 12E3  3C 1A			   CMP AL,1AH
 12E5  74 4E			   JZ _END
 12E7  E8 F6C9			   CALL  GETLAB
 12EA  72 EF			   JC SKIPLP
 12EC  66| BF 00001036 R	   MOV   EDI,OFFSET LENID
 12F2  66| BE 00000CF4 R	   MOV   ESI,OFFSET IFEND
 12F8  B5 00			   MOV   CH,0
 12FA  67& 8A 0F		   MOV   CL,[EDI]
 12FD  FE C1			   INC   CL
 12FF  F3/ A6			   REPE CMPSB
 1301  74 1B			   JZ ENDCOND
 1303  66| BF 00001036 R	   MOV   EDI,OFFSET LENID
 1309  66| BE 00000CFA R	   MOV   ESI,OFFSET IFNEST
 130F  67& 8A 0F		   MOV   CL,[EDI]
 1312  FE C1			   INC   CL
 1314  F3/ A6			   REPE CMPSB
 1316  75 C3			   JNZ   SKIPLP
 1318  FE 06 10F4 R		   INC   BYTE PTR[CHKLAB]
 131C  EB BD			   JMP SKIPLP

 131E				ENDCOND:
 131E  FE 0E 10F4 R		   DEC   BYTE PTR[CHKLAB]
 1322  75 B7			   JNZ   SKIPLP
 1324  C3			   RET

 1325				_ENDIF:
 1325  A0 10F3 R		   MOV   AL,[IFFLG]
 1328  B1 24			   MOV   CL,36
 132A  FE C8			   DEC   AL
 132C  78 04			   JS ERRJMP
 132E  A2 10F3 R		   MOV   [IFFLG],AL
 1331  C3			   RET

 1332  E9 EEE5			ERRJMP:  JMP   ERROR

				;*********************************************************************
				;
				;  PASS 2
				;
				;*********************************************************************

 1335				_END:
 1335  B2 04			   MOV   DL,4
 1337				WREND:
 1337  B5 FF			   MOV   CH,0FFH
 1339  8A C5			   MOV   AL,CH
 133B  E8 F9A4			   CALL  GEN
 133E  FE CA			   DEC   DL
 1340  75 F5			   JNZ   WREND
				;----------------------------
 1342  66| C7 06 157C R		   MOV   DWORD PTR[BUFPT],OFFSET  SRCBUF
       00001580 R
 134B  C6 06 10E3 R FB		   MOV   BYTE PTR[HEXCNT],-5   ;FLAG HEX BUFFER AS EMPTY
 1350  66| C7 06 1119 R		   MOV   DWORD PTR[LSTPNT],OFFSET  LSTBUF
       0000117B R
 1359  66| C7 06 1115 R		   MOV   DWORD PTR[HEXPNT],OFFSET  HEXBUF
       00001135 R
 1362  66| 33 C0		   XOR   EAX,EAX
 1365  66| A3 10F5 R		   MOV   [ERRCNT],EAX
 1369  66| A3 108C R		   MOV   [PC],EAX
 136D  66| A3 10D3 R		   MOV   [LINE],EAX   ;Current line number
 1371  66| C7 06 10DB R		   MOV   DWORD PTR[HEXADD],OBJECT
       00000100
				   
 137A  6A 00			   PUSH SEEK_SET
 137C  6A 00			   PUSH 0
 137E  66| FF 36 0E1C R		   PUSH [SRCFILE]
 1383  E8 0000 E		   CALL _fseek
 1386  66| 83 C4 0C		   ADD ESP,12

 138A  66| 33 C0		   XOR   EAX,EAX
 138D  A2 10CB R		   MOV   BYTE PTR[COUNT],AL
 1390  B5 01			   MOV   CH,1
 1392  66| BE 00001A84 R	   MOV   ESI,CODE_START
				;------------------------
 1398				FIXLINE:
 1398  66| BF 00001A84 R	   MOV   EDI,CODE_START ;Store code over used up intermediate code
 139E  32 C0			   XOR   AL,AL
 13A0  A2 1105 R		   MOV   BYTE PTR[SPC],AL ;No "special" yet (ORG, PUT, DS)
 13A3  A2 10CF R		   MOV   BYTE PTR[_ERR],AL   ;No second pass errors yet
 13A6				NEXBT:
 13A6  D0 E1			   SHL   CL,1     ;Shift out last bit of previous code
 13A8  FE CD			   DEC   CH    ;Still have codes left?
 13AA  75 05			   JNZ   TESTTYP
 13AC  AC			   LODSB       ;Get next flag byte
 13AD  8A C8			   MOV   CL,AL
 13AF  B5 04			   MOV   CH,4
 13B1				TESTTYP:
 13B1  D0 E1			   SHL   CL,1     ;Set flags based on two bits
 13B3  70 06			   JO FIXUP
 13B5  AC			   LODSB
 13B6  72 58			   JC EMARK
 13B8				OBJBT:
 13B8  AA			   STOSB
 13B9  EB EB			   JMP NEXBT

 13BB				FIXUP:
				;Either a word or byte fixup is needed from a forward reference
 13BB  AC			   LODSB       ;Get pointer to symbol
 13BC  66| 93			   XCHG  EAX,EBX
 13BE  AC			   LODSB       ;Get constant part
 13BF  67& 66| 03 43 01		   ADD   EAX,[EBX+1]   ;Add symbol value to constant part
 13C4  67& 80 3B 00		   CMP   BYTE PTR[EBX],0  ;See if symbol got defined
 13C8  75 08			   JNZ   HAVDEF
 13CA  C6 06 10CF R 64		   MOV   BYTE PTR[_ERR],100 ;Undefined - flag error
 13CF  66| 33 C0		   XOR   EAX,EAX
 13D2				HAVDEF:
 13D2  0A C9			   OR CL,CL    ;See if word or byte fixup
 13D4  78 03			   JS DEFBYT
 13D6  AB			   STOSW
 13D7  EB CD			   JMP NEXBT

 13D9				DEFBYT:
 13D9  66| 8B D0		   MOV   EDX,EAX
 13DC  98			   CBW         ;Extend sign
 13DD  66| 3B C2		   CMP   EAX,EDX    ;See if in range +127 to -128
 13E0  74 D6			   JZ OBJBT    ;If so, it's always OK
 13E2  F6 D4			   NOT   AH    ;Check for range +255 to -256
 13E4  3A E6			   CMP   AH,DH
 13E6  75 1E			   JNZ   RNGERR      ;Must always be in this range
				;Check for short jump. If so, we're out of range; otherwise we're OK
 13E8  66| 81 FF 00001A85 R	   CMP   EDI,CODE_START+1  ;Only one other byte on line?
 13EF  75 C7			   JNZ   OBJBT    ;Can't be short jump if not
 13F1  A0 1A84 R		   MOV   AL,BYTE PTR[CODE_START]  ;Get the first byte of this line
 13F4  3C EB			   CMP   AL,0EBH     ;Direct short jump?
 13F6  74 0E			   JZ RNGERR
 13F8  24 FC			   AND   AL,0FCH
 13FA  3C E0			   CMP   AL,0E0H     ;LOOP or JCXZ instruction?
 13FC  74 08			   JZ RNGERR
 13FE  24 F0			   AND   AL,0F0H
 1400  3C 70			   CMP   AL,70H      ;Conditional jump?
 1402  8A C2			   MOV   AL,DL    ;Get code byte in AL
 1404  75 B2			   JNZ   OBJBT    ;If not, we're OK
 1406				RNGERR:
 1406  C6 06 10CF R 65		   MOV   BYTE PTR[_ERR],101 ;Value out of range
 140B  EB AB			   JMP OBJBT

 140D  E9 0194			FINIJ:   JMP   FINI

 1410				EMARK:
 1410  3C FF			   CMP   AL,-1    ;End of file?
 1412  74 F9			   JZ FINIJ
 1414  3C F6			   CMP   AL,-10      ;Special item?
 1416  77 6A			   JA SPEND
 1418  66| 51			   PUSH  ECX
 141A  66| 56			   PUSH  ESI
 141C  66| 50			   PUSH  EAX    ;Save error code
 141E  8A 26 1101 R		   MOV   AH,BYTE PTR[LSTDEV]
 1422  80 E4 FE			   AND   AH,0FEH     ;Reset error indicator
 1425  0A 06 10CF R		   OR AL,BYTE PTR[_ERR]   ;See if any errors on this line
 1429  74 03			   JZ NOERR
 142B  80 CC 01			   OR AH,1     ;Send line to console if error occured
 142E				NOERR:
 142E  88 26 1101 R		   MOV   BYTE PTR[LSTDEV],AH
 1432  66| 8B CF		   MOV   ECX,EDI
 1435  E8 010D			   CALL  STRTLIN     ;Print address of line
 1438  66| BE 00001A84 R	   MOV   ESI,CODE_START
 143E  66| 2B CE		   SUB   ECX,ESI    ;Get count of bytes of code
 1441  74 06			   JZ SHOLIN
 1443				CODLP:
 1443  AC			   LODSB
 1444  E8 02B4			   CALL  SAVCD    ;Ouput code to HEX and PRN files
 1447  E2 FA			   LOOP  CODLP
 1449				SHOLIN:
 1449  B0 00			   MOV   AL,0
 144B  86 06 10CB R		   XCHG  AL,BYTE PTR[COUNT]
 144F  66| B9 00000007		   MOV   ECX,7     ;Allow 7 bytes of code per line
 1455  2A C8			   SUB   CL,AL
 1457  B0 20			   MOV   AL,' '
 1459  74 0B			   JZ NOFIL
 145B				BLNK:          ;Put in 3 blanks for each byte not present
 145B  E8 00FD			   CALL  LIST
 145E  E8 00FA			   CALL  LIST
 1461  E8 00F7			   CALL  LIST
 1464  E2 F5			   LOOP  BLNK
 1466				NOFIL:
 1466  E8 004E			   CALL  OUTLIN
 1469  66| 58			   POP   EAX    ;Restore error code
 146B  E8 02D2			   CALL  REPERR
 146E  A0 10CF R		   MOV   AL,BYTE PTR[_ERR]
 1471  E8 02CC			   CALL  REPERR
 1474  66| 5E			   POP   ESI
 1476  66| 59			   POP   ECX
 1478  A0 1105 R		   MOV   AL,BYTE PTR[SPC] ;Any special funtion?
 147B  0A C0			   OR AL,AL
 147D  75 0E			   JNZ   SPCFUN
 147F  E9 FF16			   JMP   FIXLINE

 1482				SPEND:
 1482  A2 1105 R		   MOV   BYTE PTR[SPC],AL ;Record special function
 1485  AD			   LODSW       ;Get it's data
 1486  66| A3 10A0 R		   MOV   [_DATA],EAX
 148A  E9 FF19			   JMP   NEXBT

 148D				SPCFUN:
 148D  66| 8B 16 10A0 R		   MOV   EDX,[_DATA]
 1492  3C FE			   CMP   AL,-2
 1494  74 11			   JZ DORG
 1496  3C FD			   CMP   AL,-3
 1498  74 15			   JZ DPUT
 149A				DDS:
				;Handle DS pseudo-op
 149A  66| 01 16 108C R		   ADD   [PC],EDX
 149F  66| 01 16 10DB R		   ADD   [HEXADD],EDX
 14A4  E9 FEF1			   JMP   FIXLINE

 14A7				DORG:
				;Handle ORG pseudo-op
 14A7  66| 89 16 108C R		   MOV   [PC],EDX
 14AC  E9 FEE9			   JMP   FIXLINE

 14AF				DPUT:
				;Handle PUT pseudo-op
 14AF  66| 89 16 10DB R		   MOV   [HEXADD],EDX
 14B4  E9 FEE1			   JMP   FIXLINE

 14B7				OUTLIN:
				;Copy the source line to the ouput device. Line will be preceded by
				;assembler-generated line number. This routine may be called several times
				;on one line (once for each line of object code bytes), so it sets a flag
				;so the line will only be output on the first call.
 14B7  B0 FF			   MOV   AL,-1
 14B9  86 06 10EB R		   XCHG  AL,BYTE PTR[LINFLG]
 14BD  0A C0			   OR AL,AL
 14BF  75 39			   JNZ   CRLF     ;Output line only if first time
 14C1  66| A1 10D3 R		   MOV   EAX,[LINE]
 14C5  66| 40			   INC   EAX
 14C7  66| A3 10D3 R		   MOV   [LINE],EAX
 14CB  B7 00			   MOV   BH,0     ;No leading zero suppression
 14CD  E8 0033			   CALL  OUT10
 14D0  B0 20			   MOV   AL," "
 14D2  E8 0086			   CALL  LIST
 14D5  66| 56			   PUSH  ESI    ;Save the only register destroyed by NEXTCHR
 14D7				OUTLN:
 14D7  E8 ED44			   CALL  NEXTCHR
 14DA  E8 007E			   CALL  LIST
 14DD  3C 0A			   CMP   AL,10    ;Output until linefeed found
 14DF  75 F6			   JNZ   OUTLN
 14E1  66| 5E			   POP   ESI
 14E3  C3			   RET

 14E4				PRTCNT:
 14E4  66| A1 10F5 R		   MOV   EAX,[ERRCNT]
 14E8  66| BB 00000CA1 R	   MOV   EBX,OFFSET ERCNTM
 14EE				PRNT10:
 14EE  66| 50			   PUSH  EAX
 14F0  E8 0288			   CALL  PRINT
 14F3  66| 58			   POP   EAX
 14F5  B7 10			   MOV   BH,"0"-" "  ;Enable leading zero suppression
 14F7  E8 0009			   CALL  OUT10
 14FA				CRLF:
 14FA  B0 0D			   MOV   AL,13
 14FC  E8 005C			   CALL  LIST
 14FF  B0 0A			   MOV   AL,10
 1501  EB 58			   JMP LIST

 1503				OUT10:
 1503  66| 33 D2		   XOR   EDX,EDX
 1506  66| BF 00002710		   MOV   EDI,10000
 150C  66| F7 F7		   DIV   EDI
 150F  0A C0			   OR AL,AL    ;>10,000?
 1511  75 02			   JNZ   LEAD
 1513  2C 10			   SUB   AL,"0"-" "  ;Convert leading zero to blank
 1515				LEAD:
 1515  04 30			   ADD   AL,"0"
 1517  E8 0041			   CALL  LIST
 151A  66| 92			   XCHG  EAX,EDX
 151C  B3 64			   MOV   BL,100
 151E  F6 F3			   DIV   BL
 1520  8A DC			   MOV   BL,AH
 1522  E8 000C			   CALL  HIDIG    ;Convert to decimal and print 1000s digit
 1525  E8 0011			   CALL  DIGIT    ;Print 100s digit
 1528  8A C3			   MOV   AL,BL
 152A  E8 0004			   CALL  HIDIG    ;Convert to decimal and print 10s digit
 152D  B7 00			   MOV   BH,0     ;Ensure leading zero suppression is off
 152F  EB 08			   JMP DIGIT

 1531				HIDIG:
 1531  D4 0A			   AAM         ;Convert binary to unpacked BCD
 1533  66| 0D 00003030		   OR EAX,3030H ;Add "0" bias
 1539				DIGIT:
 1539  86 C4			   XCHG  AL,AH
 153B  3C 30			   CMP   AL,"0"
 153D  74 02			   JZ SUPZ
 153F  B7 00			   MOV   BH,0     ;Turn off zero suppression if not zero
 1541				SUPZ:
 1541  2A C7			   SUB   AL,BH    ;Convert leading zeros to blanks
 1543  EB 16			   JMP LIST

 1545				STRTLIN:
 1545  C6 06 10EB R 00		   MOV   BYTE PTR[LINFLG],0
 154A  66| 8B 1E 108C R		   MOV   EBX,[PC]
 154F  8A C7			   MOV   AL,BH
 1551  E8 0041			   CALL  PHEX
 1554  8A C3			   MOV   AL,BL
 1556				PHEXB:
 1556  E8 003C			   CALL  PHEX
 1559  B0 20			   MOV   AL,' '
 155B				LIST:
 155B  66| 50			   PUSH  EAX
 155D  66| 52			   PUSH  EDX
 155F  24 7F			   AND   AL,7FH
 1561  8A D0			   MOV   DL,AL
 1563				FILCHK:
 1563  8A C2			   MOV   AL,DL
 1565  66| 5A			   POP   EDX
 1567  E8 0003			   CALL  WRTBUF
 156A  66| 58			   POP   EAX
 156C  C3			   RET

 156D				WRTBUF:
 156D  66| 57			   PUSH  EDI
 156F  66| 8B 3E 1119 R		   MOV   EDI,[LSTPNT]
 1574  AA			   STOSB
 1575  66| 81 FF 0000157B R	   CMP   EDI,OFFSET LSTBUF+LSTBUFSIZ
 157C  75 0F			   JNZ   SAVPT
 157E  66| 50			   PUSH  EAX
 1580  66| 51			   PUSH  ECX
 1582  66| 52			   PUSH  EDX
 1584  E8 02E5			   CALL  FLUSHBUF
 1587  66| 5A			   POP   EDX
 1589  66| 59			   POP   ECX
 158B  66| 58			   POP   EAX
 158D				SAVPT:
 158D  66| 89 3E 1119 R		   MOV   [LSTPNT],EDI
 1592  66| 5F			   POP   EDI
 1594  C3			   RET

 1595				PHEX:
 1595  66| 50			   PUSH  EAX
 1597  E8 0302			   CALL  UHALF
 159A  E8 FFBE			   CALL  LIST
 159D  66| 58			   POP   EAX
 159F  E8 0302			   CALL  LHALF
 15A2  EB B7			   JMP LIST

 15A4				FINI:
 15A4  80 0E 1101 R 01		   OR BYTE PTR[LSTDEV],1
 15A9  E8 FF38			   CALL  PRTCNT
 15AC  66| BB 00000CB2 R	   MOV   EBX,OFFSET SYMSIZE
 15B2  66| B8 00001B84 R	   MOV   EAX,OFFSET HEAP_START
 15B8  66| 2B 06 10B6 R		   SUB   EAX,[_HEAP]     ;Size of symbol table
 15BD  E8 FF2E			   CALL  PRNT10
 15C0  66| BB 00000CC8 R	   MOV   EBX,OFFSET FRESIZE
 15C6  66| A1 10B6 R		   MOV   EAX,[_HEAP]
 15CA  66| 2B 06 10BE R		   SUB   EAX,[CODE]      ;Free space remaining
 15CF  E8 FF1C			   CALL  PRNT10
 15D2  80 26 1101 R FE		   AND   BYTE PTR[LSTDEV],0FEH
 15D7  A0 10E3 R		   MOV   AL,BYTE PTR[HEXCNT]
 15DA  3C FB			   CMP   AL,-5
 15DC  74 03			   JZ L0012
 15DE  E8 022D			   CALL  ENHEXL
 15E1				L0012:   
 15E1  B0 3A			   MOV   AL,':'
 15E3  E8 027A			   CALL  PUTCHR
 15E6  B5 0A			   MOV   CH,10
 15E8				HEXEND:
 15E8  66| 51			   PUSH  ECX
 15EA  B0 30			   MOV   AL,'0'
 15EC  E8 0271			   CALL  PUTCHR
 15EF  66| 59			   POP   ECX
 15F1  FE CD			   DEC   CH
 15F3  75 F3			   JNZ   HEXEND
 15F5  B0 0D			   MOV   AL,13
 15F7  E8 0266			   CALL  PUTCHR
 15FA  B0 0A			   MOV   AL,10
 15FC  E8 0261			   CALL  PUTCHR
 15FF  E8 0236			   CALL  WRTHEX      ;Flush HEX file buffer
 1602  66| FF 36 0E20 R		   PUSH  [HEXFILE]
 1607  E8 0000 E		   CALL  _fclose
 160A  66| 83 C4 04		   ADD   ESP,4

 160E				DOSYMTAB:
 160E  66| BB 00000CDC R	   MOV   EBX,OFFSET SYMMES
 1614  E8 0164			   CALL  PRINT
 1617  66| 8B 16 10B2 R		   MOV   EDX,[BASE]
 161C  8A C6			   MOV   AL,DH
 161E  0A C2			   OR AL,DL
 1620  74 10			   JZ ENDSYM
 1622  C6 06 10BA R 05		   MOV   BYTE PTR[SYMLIN],SYMWID  ;No symbols on this line yet
 1627  66| 8B 1E 10B6 R		   MOV   EBX,[_HEAP]
 162C  66| 8B E3		   MOV   ESP,EBX    ;Need maximum stack for recursive tree walk
 162F  E8 0030			   CALL  NODE
 1632				ENDSYM:
 1632  F6 06 1101 R 80		   TEST  BYTE PTR[LSTDEV],80H  ;Print listing to file?
 1637  74 19			   JZ EXIT
 1639  B0 1A			   MOV AL,1AH
 163B  E8 FF2F			   CALL  WRTBUF      ;Write end-of-file mark
 163E  66| 8B 3E 1119 R		   MOV   EDI,[LSTPNT]
 1643  E8 0226			   CALL  FLUSHBUF
 1646  66| FF 36 0E24 R		   PUSH  [LSTFILE]
 164B  E8 0000 E		   CALL  _fclose
 164E  66| 83 C4 04		   ADD   ESP,4

 1652				EXIT: 
 1652  66| FF 36 0E1C R		   PUSH  [SRCFILE]
 1657  66| 33 C0		   XOR   EAX,EAX
 165A  E8 0000 E		   CALL  _fclose
 165D  66| 83 C4 04		   ADD   ESP,4
 1661  C3			   RET
 1662				NODE:
 1662  66| 87 D3		   XCHG  EDX,EBX
 1665  66| 53			   PUSH  EBX
 1667  66| 33 D2		XOR EDX,EDX
 166A  67& 8A 13		   MOV   DL,[EBX]
 166D  66| 43				INC   EBX
 166F  66| 43				INC   EBX
 1671  66| 43				INC   EBX
 1673  66| 43				INC   EBX
 1675  66| 03 DA		   ADD   EBX,EDX
 1678  67& 66| 8B 13		   MOV   EDX,[EBX]
 167C  66| 0B D2		   OR EDX,EDX
 167F  74 03			   JZ L0014
 1681  E8 FFDE			   CALL  NODE
 1684				L0014:   
 1684  66| 5B			   POP   EBX
 1686  67& 8A 03		   MOV   AL,[EBX]
 1689  66| 43			   INC   EBX
 168B  8A E8			   MOV   CH,AL
 168D  04 18			   ADD   AL,24
 168F  D0 E8			   SHR   AL,1
 1691  D0 E8			   SHR   AL,1
 1693  D0 E8			   SHR   AL,1
 1695  8A C8			   MOV   CL,AL
 1697  FE C1			   INC   CL    ;Invert last bit
 1699  80 E1 01			   AND   CL,1     ;Number of extra tabs needed (0 or 1)
 169C  D0 E8			   SHR   AL,1     ;Number of positions wide this symbol needs
 169E  28 06 10BA R		   SUB   BYTE PTR[SYMLIN],AL
 16A2  73 0A			   JNC   WRTSYM      ;Will it fit?
 16A4  2C 05			   SUB   AL,SYMWID
 16A6  F6 D8			   NEG   AL
 16A8  A2 10BA R		   MOV   BYTE PTR[SYMLIN],AL
 16AB  E8 FE4C			   CALL  CRLF     ;Start new line if not
 16AE				WRTSYM:
 16AE  67& 8A 03		   MOV   AL,[EBX]
 16B1  66| 43			   INC   EBX
 16B3  E8 FEA5			   CALL  LIST
 16B6  FE CD			   DEC   CH
 16B8  75 F4			   JNZ   WRTSYM
 16BA  FE C1			   INC   CL
 16BC				TABVAL:
 16BC  B0 09			   MOV   AL,9
 16BE  E8 FE9A			   CALL  LIST
 16C1  E2 F9			   LOOP  TABVAL
 16C3  66| 43			   INC   EBX
 16C5  66| 43			   INC   EBX
 16C7  66| 53			   PUSH  EBX
 16C9  67& 8A 43 04		   MOV   AL,[EBX+4]
 16CD  E8 FEC5			   CALL  PHEX
 16D0  67& 8A 43 03		   MOV   AL,[EBX+3]
 16D4  E8 FEBE			   CALL  PHEX
 16D7  80 3E 10BA R 00		   CMP   BYTE PTR[SYMLIN],0 ;Will any more fit on line?
 16DC  74 07			   JZ NEXSYMLIN
 16DE  B0 09			   MOV   AL,9
 16E0  E8 FE78			   CALL  LIST
 16E3  EB 08			   JMP RIGHTSON
 16E5				NEXSYMLIN:
 16E5  E8 FE12			   CALL  CRLF
 16E8  C6 06 10BA R 05		   MOV   BYTE PTR[SYMLIN],SYMWID
 16ED				RIGHTSON:
 16ED  66| 5B			   POP   EBX
 16EF  67& 66| 8B 13		   MOV   EDX,[EBX]
 16F3  66| 0B D2		   OR EDX,EDX
 16F6  0F 85 FF68		   JNZ   NODE
 16FA  C3			   RET

 16FB				SAVCD:
 16FB  A2 10EF R		   MOV   BYTE PTR[PREV],AL
 16FE  66| 53			   PUSH  EBX
 1700  66| 51			   PUSH  ECX
 1702  66| 50			   PUSH  EAX
 1704  66| 52			   PUSH  EDX
 1706  E8 0088			   CALL  CODBYT
 1709  66| 5A			   POP   EDX
 170B  66| 8B 1E 10CB R		   MOV   EBX,COUNT
 1710  67& FE 03		   INC   BYTE PTR[EBX]
 1713  67& 8A 03		   MOV   AL,[EBX]
 1716  3C 08			   CMP   AL,8
 1718  75 12			   JNZ   NOEXT
 171A  67& C6 03 01		   MOV   BYTE PTR[EBX],1
 171E  E8 FD96			   CALL  OUTLIN
 1721  B0 20			   MOV   AL,' '
 1723  B5 05			   MOV   CH,5
 1725				TAB:
 1725  E8 FE33			   CALL  LIST
 1728  FE CD			   DEC   CH
 172A  75 F9			   JNZ   TAB
 172C				NOEXT:
 172C  66| 58			   POP   EAX
 172E  E8 FE25			   CALL  PHEXB
 1731  66| 59			   POP   ECX
 1733  66| FF 06 108C R		   INC   DWORD PTR[PC]
 1738  66| FF 06 10DB R		   INC   DWORD PTR[HEXADD]
 173D  66| 5B			   POP   EBX
 173F				NOEXT_RET:
 173F  C3			   RET

 1740				REPERR:
 1740  0A C0   OR AL,AL    ;Did an error occur?
 1742  74 FB			   JZ NOEXT_RET
 1744  66| FF 06 10F5 R		   INC   DWORD PTR[ERRCNT]
 1749  66| 50			   PUSH  EAX
 174B  66| BB 00000C2B R	   MOV   EBX,OFFSET _ERRMES   ;Print "ERROR"
 1751  E8 0027			   CALL  PRINT
 1754  66| 58			   POP   EAX
				;We have error number in AL. See if there's an error message for it
 1756  66| BF 0000085C R	   MOV   EDI,ERRTAB
 175C  B3 80			   MOV   BL,80H
 175E				ERRLOOK:
 175E  AE			   SCASB       ;Do we have the error message
 175F  76 09			   JBE   HAVMES      ;Quit looking if we have it or passed it
 1761  66| 93			   XCHG  EAX,EBX    ;Put 80H in AL to look for end of this message
 1763				NEXTMES:
 1763  AE			   SCASB       ;Look for high bit set in message
 1764  77 FD			   JA NEXTMES     ;   which means we've reached the end
 1766  66| 93			   XCHG  EAX,EBX    ;Restore error number to AL
 1768  EB F4			   JMP   ERRLOOK     ;Keep looking

 176A				HAVMES:
 176A  66| 8B DF		   MOV   EBX,EDI    ;Put address of message in EBX
 176D  74 06			   JZ PRNERR      ;Do we have a message for this error?
 176F  E8 FE23			   CALL  PHEX     ;If not, just print error number
 1772  E9 FD85			   JMP   CRLF

 1775				PRNERR:
 1775  E8 0003			   CALL  PRINT
 1778  E9 FD7F			   JMP   CRLF

 177B				PRINT:
 177B  67& 8A 03		   MOV   AL,[EBX]
 177E  E8 FDDA			   CALL  LIST
 1781  0A C0			   OR AL,AL
 1783  78 0B			   JS SYSTEM_RET
 1785  66| 43			   INC   EBX
 1787  EB F2			   JMP PRINT

 1789				OUTA:
 1789  8A D0			   MOV   DL,AL
 178B				_OUT:
 178B  80 E2 7F			   AND   DL,7FH
 178E  B1 02			   MOV   CL,2
 1790				SYSTEM:
				   ;CALL  5
 1790				SYSTEM_RET:
 1790  C3			   RET

 1791				CODBYT:
 1791  66| 50			   PUSH  EAX
 1793  66| 8B 16 10DF R		   MOV   EDX,[LASTAD]
 1798  66| 8B 1E 10DB R		   MOV   EBX,[HEXADD]
 179D  66| 89 1E 10DF R		   MOV   [LASTAD],EBX
 17A2  66| 42			   INC   EDX
 17A4  A0 10E3 R		   MOV   AL,BYTE PTR[HEXCNT]
 17A7  3C FB			   CMP   AL,-5
 17A9  74 08			   JZ NEWLIN
 17AB  66| 3B DA		   CMP   EBX,EDX
 17AE  74 30			   JZ AFHEX
 17B0  E8 005B			   CALL  ENHEXL
 17B3				NEWLIN:
 17B3  B0 3A			   MOV   AL,':'
 17B5  E8 00A8			   CALL  PUTCHR
 17B8  B0 FC			   MOV   AL,-4
 17BA  A2 10E3 R		   MOV   BYTE PTR[HEXCNT],AL
 17BD  32 C0			   XOR   AL,AL
 17BF  A2 10E7 R		   MOV   BYTE PTR[CHKSUM],AL
 17C2  66| 8B 1E 1115 R		   MOV   EBX,[HEXPNT]
 17C7  66| 89 1E 10D7 R		   MOV   [HEXLEN],EBX
 17CC  E8 0013			   CALL  HEXBYT
 17CF  A0 10DC R		   MOV   AL,BYTE PTR[HEXADD+1]
 17D2  E8 000D			   CALL  HEXBYT
 17D5  A0 10DB R		   MOV   AL,BYTE PTR[HEXADD]
 17D8  E8 0007			   CALL  HEXBYT
 17DB  32 C0			   XOR   AL,AL
 17DD  E8 0002			   CALL  HEXBYT
 17E0				AFHEX:
 17E0  66| 58			   POP   EAX
 17E2				HEXBYT:
 17E2  8A E8			   MOV   CH,AL
 17E4  66| 8B 1E 10E7 R		   MOV   EBX,CHKSUM
 17E9  67& 02 03		   ADD   AL,[EBX]
 17EC  67& 88 03		   MOV   [EBX],AL
 17EF  8A C5			   MOV   AL,CH
 17F1  E8 00A8			   CALL  UHALF
 17F4  E8 0069			   CALL  PUTCHR
 17F7  8A C5			   MOV   AL,CH
 17F9  E8 00A8			   CALL  LHALF
 17FC  E8 0061			   CALL  PUTCHR
 17FF  66| 8B 1E 10E3 R		   MOV   EBX,HEXCNT
 1804  67& FE 03		   INC   BYTE PTR[EBX]
 1807  67& 8A 03		   MOV   AL,[EBX]
 180A  3C 1A			   CMP   AL,26
 180C  75 51			   JNZ   WRTHEX_RET
 180E				ENHEXL:
 180E  66| 8B 3E 10D7 R		   MOV   EDI,[HEXLEN]
 1813  8A E8			   MOV   CH,AL
 1815  E8 0084			   CALL  UHALF
 1818  AA			   STOSB
 1819  8A C5			   MOV   AL,CH
 181B  E8 0086			   CALL  LHALF
 181E  AA			   STOSB
 181F  B0 FA			   MOV   AL,-6
 1821  A2 10E3 R		   MOV   BYTE PTR[HEXCNT],AL
 1824  A0 10E7 R		   MOV   AL,BYTE PTR[CHKSUM]
 1827  02 C5			   ADD   AL,CH
 1829  F6 D8			   NEG   AL
 182B  E8 FFB4			   CALL  HEXBYT
 182E  B0 0D			   MOV   AL,13
 1830  E8 002D			   CALL  PUTCHR
 1833  B0 0A			   MOV   AL,10
 1835  E8 0028			   CALL  PUTCHR
 1838				WRTHEX:
				;Write out the line
 1838  66| BA 00001135 R	   MOV   EDX,OFFSET HEXBUF
 183E  66| 89 16 1115 R		   MOV   [HEXPNT],EDX
 1843  66| 2B FA		   SUB   EDI,EDX    ;Length of buffer
 1846  66| 8B CF		   MOV   ECX,EDI

 1849  66| FF 36 0E20 R		   PUSH  [HEXFILE]
 184E  66| 51			   PUSH  ECX
 1850  6A 01			   PUSH  1
 1852  66| 52			   PUSH  EDX
 1854  E8 0000 E		   CALL  _fwrite
 1857  66| 83 C4 10		   ADD   ESP,16

 185B  0A C0			   OR AL,AL
 185D  75 34			   JNZ   DSKFUL
 185F				WRTHEX_RET:
 185F  C3			   RET

 1860				PUTCHR:
 1860  66| 8B 3E 1115 R		   MOV   EDI,[HEXPNT]
 1865  AA			   STOSB
 1866  66| 89 3E 1115 R		   MOV   [HEXPNT],EDI
 186B  C3			   RET

 186C				FLUSHBUF: ;EDI FLUSH SIZE
 186C  66| 8B CF		   MOV   ECX,EDI
 186F  66| BA 0000117B R	   MOV   EDX,OFFSET LSTBUF
 1875  66| 8B FA		   MOV   EDI,EDX
 1878  66| 2B CA		   SUB   ECX,EDX
 187B  74 31			   JZ LHALF_RET      ;Buffer empty?

 187D  66| FF 36 0E24 R		   PUSH [LSTFILE]
 1882  66| 51			   PUSH  ECX
 1884  6A 01			   PUSH  1
 1886  66| 52			   PUSH  EDX
 1888  E8 0000 E		   CALL _fwrite
 188B  66| 83 C4 10		   ADD   ESP,16
 188F  0A C0			   OR AL,AL
 1891  75 1B			   JNZ LHALF_RET
 1893				DSKFUL:
 1893  66| BB 00000C7C R	   MOV   EBX,OFFSET WRTERR
 1899  E9 E958			   JMP   PRERR

 189C				UHALF:
 189C  D0 D8			   RCR   AL,1
 189E  D0 D8			   RCR   AL,1
 18A0  D0 D8			   RCR   AL,1
 18A2  D0 D8			   RCR   AL,1
 18A4				LHALF:
 18A4  24 0F			   AND   AL,0FH
 18A6  0C 30			   OR AL,30H
 18A8  3C 3A			   CMP   AL,'9'+1
 18AA  72 02			   JC LHALF_RET
 18AC  04 07			   ADD   AL,7
 18AE				LHALF_RET:
 18AE  C3			   RET

 18AF				CODESEG ENDS

 0000				DATASEG SEGMENT "DATA" PUBLIC

 0000 00			NONE DB 0

				; 8086 MNEMONIC TABLE

				; This table is actually a sequence of subtables, each starting with a label.
				; The label signifies which mnemonics the subtable applies to--A3, for example,
				; means all 3-letter mnemonics beginning with A.

 0001				A3:
 0001  07			   DB 7     ;items count
 0002  64 64			   DB 'dd'  ;chars following 'a''
 0004  0F40 0000 R		   DD OFFSET GRP7  ;handler
 0008  02			   DB 2		;opcode or count of operand
 0009  6E 64			   DB 'nd'
 000B  1025 0000 R		   DD OFFSET GRP13
 000F  22			   DB 22H
 0010  64 63			   DB 'dc'

 0012  0F40 0000 R		   DD OFFSET GRP7
 0016  12			   DB 12H
 0017  61 61			   DB 'aa'
 0019  0CD4 0000 R		   DD OFFSET PUT
 001D  37			   DB 37H
 001E  61 73			   DB 'as'
 0020  0CD4 0000 R		   DD OFFSET PUT
 0024  3F			   DB 3FH
 0025  61 6D			   DB 'am'
 0027  0FEE 0000 R		   DD OFFSET GRP11
 002B  D4			   DB 0D4H ;opcode
 002C  61 64			   DB 'ad'
 002E  0FEE 0000 R		   DD OFFSET GRP11
 0032  D5			   DB 0D5H	;opcode
 0033				A5:
 0033  01			   DB 1
 0034  6C 69 67 6E		   DB 'lign'
 0038  0EDE 0000 R		   DD OFFSET _ALIGN
 003C  00			   DB 0
 003D				C3:
 003D  07			   DB 7
 003E  6D 70			   DB 'mp'
 0040  0F40 0000 R		   DD OFFSET GRP7
 0044  3A			   DB 3AH
 0045  6C 63			   DB 'lc'
 0047  0CD4 0000 R		   DD OFFSET PUT
 004B  F8			   DB 0F8H
 004C  6C 64			   DB 'ld'
 004E  0CD4 0000 R		   DD OFFSET PUT
 0052  FC			   DB 0FCH
 0053  6C 69			   DB 'li'
 0055  0CD4 0000 R		   DD OFFSET PUT
 0059  FA			   DB 0FAH
 005A  6D 63			   DB 'mc'
 005C  0CD4 0000 R		   DD OFFSET PUT
 0060  F5			   DB 0F5H
 0061  62 77			   DB 'bw'
 0063  0CD4 0000 R		   DD OFFSET PUT
 0067  98			   DB 98H
 0068  77 64			   DB 'wd'
 006A  0CD4 0000 R		   DD OFFSET PUT
 006E  99			   DB 99H
 006F				C4:
 006F  03			   DB 3
 0070  61 6C 6C			   DB 'all'
 0073  1051 0000 R		   DD OFFSET GRP14
 0077  9A			   DB 9AH
 0078  6D 70 62			   DB 'mpb'
 007B  0CD4 0000 R		   DD OFFSET PUT
 007F  A6			   DB 0A6H
 0080  6D 70 77			   DB 'mpw'
 0083  0CD4 0000 R		   DD OFFSET PUT
 0087  A7			   DB 0A7H
 0088				C5:
 0088  02			   DB 2
 0089  6D 70 73 62		   DB 'mpsb'
 008D  0CD4 0000 R		   DD OFFSET PUT
 0091  A6			   DB 0A6H
 0092  6D 70 73 77		   DB 'mpsw'
 0096  0CD4 0000 R		   DD OFFSET PUT
 009A  A7			   DB 0A7H
 009B				D2:
 009B  05			   DB 5
 009C  62			   DB 'b'
 009D  1296 0000 R		   DD OFFSET GRP23
 00A1  01			   DB 1
 00A2  77			   DB 'w'
 00A3  1296 0000 R		   DD OFFSET GRP23
 00A7  00			   DB 0
 00A8  6D			   DB 'm'
 00A9  1296 0000 R		   DD OFFSET GRP23
 00AD  02			   DB 2
 00AE  73			   DB 's'
 00AF  0EA8 0000 R		   DD OFFSET GRP5
 00B3  01			   DB 1
 00B4  69			   DB 'i'
 00B5  0CD4 0000 R		   DD OFFSET PUT
 00B9  FA			   DB 0FAH
 00BA				D3:
 00BA  04			   DB 4
 00BB  65 63			   DB 'ec'
 00BD  0F6D 0000 R		   DD OFFSET GRP8
 00C1  49			   DB 49H
 00C2  69 76			   DB 'iv'
 00C4  0FC3 0000 R		   DD OFFSET GRP10
 00C8  30			   DB 30H
 00C9  61 61			   DB 'aa'
 00CB  0CD4 0000 R		   DD OFFSET PUT
 00CF  27			   DB 27H
 00D0  61 73			   DB 'as'
 00D2  0CD4 0000 R		   DD OFFSET PUT
 00D6  2F			   DB 2FH
 00D7				D4:
 00D7  01			   DB 1
 00D8  6F 77 6E			   DB 'own'
 00DB  0CD4 0000 R		   DD OFFSET PUT
 00DF  FD			   DB 0FDH
 00E0				E2:
 00E0  01			   DB 1
 00E1  69			   DB 'i'
 00E2  0CD4 0000 R		   DD OFFSET PUT
 00E6  FB			   DB 0FBH
 00E7				E3:
 00E7  03			   DB 3 ;OPERANDS COUNT
 00E8  71 75			   DB 'qu'
 00EA  0EA8 0000 R		   DD OFFSET GRP5
 00EE  02			   DB 2
 00EF  73 63			   DB 'sc'
 00F1  11D6 0000 R		   DD OFFSET GRP19
 00F5  D8			   DB 0D8H
 00F6  6E 64			   DB 'nd'
 00F8  1335 0000 R		   DD OFFSET _END
 00FC  00			   DB 0
 00FD				E5:
 00FD  01			   DB 1
 00FE  6E 64 69 66		   DB 'ndif'
 0102  1325 0000 R		   DD OFFSET _ENDIF
 0106  00			   DB 0
 0107				H3:
 0107  01			   DB 1
 0108  6C 74			   DB 'lt'
 010A  0CD4 0000 R		   DD OFFSET PUT
 010E  F4			   DB 0F4H
 010F				H4:
 010F  01			   DB 1
 0110  61 6C 74			   DB 'alt'
 0113  0CD4 0000 R		   DD OFFSET PUT
 0117  F4			   DB 0F4H
 0118				I2:
 0118  02			   DB 2
 0119  6E			   DB 'n'
 011A  0E80 0000 R		   DD OFFSET GRP4
 011E  E4			   DB 0E4H
 011F  66			   DB 'f'
 0120  0EA8 0000 R		   DD OFFSET GRP5
 0124  04			   DB 4
 0125				I3:
 0125  04			   DB 4
 0126  6E 63			   DB 'nc'
 0128  0F6D 0000 R		   DD OFFSET GRP8
 012C  41			   DB 41H
 012D  6E 62			   DB 'nb'
 012F  0E80 0000 R		   DD OFFSET GRP4
 0133  E4			   DB 0E4H
 0134  6E 77			   DB 'nw'
 0136  0E80 0000 R		   DD OFFSET GRP4
 013A  E5			   DB 0E5H
 013B  6E 74			   DB 'nt'
 013D  11A5 0000 R		   DD OFFSET GRP18
 0141  CC			   DB 0CCH
 0142				I4:
 0142  04			   DB 4
 0143  6D 75 6C			   DB 'mul'
 0146  0FC3 0000 R		   DD OFFSET GRP10
 014A  28			   DB 28H
 014B  64 69 76			   DB 'div'
 014E  0FC3 0000 R		   DD OFFSET GRP10
 0152  38			   DB 38H
 0153  72 65 74			   DB 'ret'
 0156  0CD4 0000 R		   DD OFFSET PUT
 015A  CF			   DB 0CFH
 015B  6E 74 6F			   DB 'nto'
 015E  0CD4 0000 R		   DD OFFSET PUT
 0162  CE			   DB 0CEH
 0163				J2:
 0163  0A			   DB 10
 0164  70			   DB 'p'
 0165  1164 0000 R		   DD OFFSET GRP17
 0169  EB			   DB 0EBH
 016A  7A			   DB 'z'
 016B  1164 0000 R		   DD OFFSET GRP17
 016F  74			   DB 74H
 0170  65			   DB 'e'
 0171  1164 0000 R		   DD OFFSET GRP17
 0175  74			   DB 74H
 0176  6C			   DB 'l'
 0177  1164 0000 R		   DD OFFSET GRP17
 017B  7C			   DB 7CH
 017C  62			   DB 'b'
 017D  1164 0000 R		   DD OFFSET GRP17
 0181  72			   DB 72H
 0182  61			   DB 'a'
 0183  1164 0000 R		   DD OFFSET GRP17
 0187  77			   DB 77H
 0188  67			   DB 'g'
 0189  1164 0000 R		   DD OFFSET GRP17
 018D  7F			   DB 7FH
 018E  6F			   DB 'o'
 018F  1164 0000 R		   DD OFFSET GRP17
 0193  70			   DB 70H
 0194  73			   DB 's'
 0195  1164 0000 R		   DD OFFSET GRP17
 0199  78			   DB 78H
 019A  63			   DB 'c'
 019B  1164 0000 R		   DD OFFSET GRP17
 019F  72			   DB 72H
 01A0				J3:
 01A0  11			   DB 17
 01A1  6D 70			   DB 'mp'
 01A3  1051 0000 R		   DD OFFSET GRP14
 01A7  EA			   DB 0EAH
 01A8  6E 7A			   DB 'nz'
 01AA  1164 0000 R		   DD OFFSET GRP17
 01AE  75			   DB 75H
 01AF  6E 65			   DB 'ne'
 01B1  1164 0000 R		   DD OFFSET GRP17
 01B5  75			   DB 75H
 01B6  6E 6C			   DB 'nl'
 01B8  1164 0000 R		   DD OFFSET GRP17
 01BC  7D			   DB 7DH
 01BD  67 65			   DB 'ge'
 01BF  1164 0000 R		   DD OFFSET GRP17
 01C3  7D			   DB 7DH
 01C4  6E 62			   DB 'nb'
 01C6  1164 0000 R		   DD OFFSET GRP17
 01CA  73			   DB 73H
 01CB  61 65			   DB 'ae'
 01CD  1164 0000 R		   DD OFFSET GRP17
 01D1  73			   DB 73H
 01D2  6E 63			   DB 'nc'
 01D4  1164 0000 R		   DD OFFSET GRP17
 01D8  73			   DB 73H
 01D9  6E 67			   DB 'ng'
 01DB  1164 0000 R		   DD OFFSET GRP17
 01DF  7E			   DB 7EH
 01E0  6C 65			   DB 'le'
 01E2  1164 0000 R		   DD OFFSET GRP17
 01E6  7E			   DB 7EH
 01E7  6E 61			   DB 'na'
 01E9  1164 0000 R		   DD OFFSET GRP17
 01ED  76			   DB 76H
 01EE  62 65			   DB 'be'
 01F0  1164 0000 R		   DD OFFSET GRP17
 01F4  76			   DB 76H
 01F5  70 65			   DB 'pe'
 01F7  1164 0000 R		   DD OFFSET GRP17
 01FB  7A			   DB 7AH
 01FC  6E 70			   DB 'np'
 01FE  1164 0000 R		   DD OFFSET GRP17
 0202  7B			   DB 7BH
 0203  70 6F			   DB 'po'
 0205  1164 0000 R		   DD OFFSET GRP17
 0209  7B			   DB 7BH
 020A  6E 6F			   DB 'no'
 020C  1164 0000 R		   DD OFFSET GRP17
 0210  71			   DB 71H
 0211  6E 73			   DB 'ns'
 0213  1164 0000 R		   DD OFFSET GRP17
 0217  79			   DB 79H
 0218				J4:
 0218  06			   DB 6
 0219  6D 70 73			   DB 'mps'
 021C  1164 0000 R		   DD OFFSET GRP17
 0220  EB			   DB 0EBH
 0221  63 78 7A			   DB 'cxz'
 0224  1164 0000 R		   DD OFFSET GRP17
 0228  E3			   DB 0E3H
 0229  6E 67 65			   DB 'nge'
 022C  1164 0000 R		   DD OFFSET GRP17
 0230  7C			   DB 7CH
 0231  6E 61 65			   DB 'nae'
 0234  1164 0000 R		   DD OFFSET GRP17
 0238  72			   DB 72H
 0239  6E 62 65			   DB 'nbe'
 023C  1164 0000 R		   DD OFFSET GRP17
 0240  77			   DB 77H
 0241  6E 6C 65			   DB 'nle'
 0244  1164 0000 R		   DD OFFSET GRP17
 0248  7F			   DB 7FH
 0249				L3:
 0249  03			   DB 3
 024A  65 61			   DB 'ea'
 024C  0F34 0000 R		   DD OFFSET GRP6
 0250  8D			   DB 8DH
 0251  64 73			   DB 'ds'
 0253  0F34 0000 R		   DD OFFSET GRP6
 0257  C5			   DB 0C5H
 0258  65 73			   DB 'es'
 025A  0F34 0000 R		   DD OFFSET GRP6
 025E  C4			   DB 0C4H
 025F				L4:
 025F  05			   DB 5
 0260  6F 6F 70			   DB 'oop'
 0263  1164 0000 R		   DD OFFSET GRP17
 0267  E2			   DB 0E2H
 0268  6F 64 62			   DB 'odb'
 026B  0CD4 0000 R		   DD OFFSET PUT
 026F  AC			   DB 0ACH
 0270  6F 64 77			   DB 'odw'
 0273  0CD4 0000 R		   DD OFFSET PUT
 0277  AD			   DB 0ADH
 0278  61 68 66			   DB 'ahf'
 027B  0CD4 0000 R		   DD OFFSET PUT
 027F  9F			   DB 9FH
 0280  6F 63 6B			   DB 'ock'
 0283  0CD4 0000 R		   DD OFFSET PUT
 0287  F0			   DB 0F0H
 0288				L5:
 0288  04			   DB 4
 0289  6F 6F 70 65		   DB 'oope'
 028D  1164 0000 R		   DD OFFSET GRP17
 0291  E1			   DB 0E1H
 0292  6F 6F 70 7A		   DB 'oopz'
 0296  1164 0000 R		   DD OFFSET GRP17
 029A  E1			   DB 0E1H
 029B  6F 64 73 62		   DB 'odsb'
 029F  0CD4 0000 R		   DD OFFSET PUT
 02A3  AC			   DB 0ACH
 02A4  6F 64 73 77		   DB 'odsw'
 02A8  0CD4 0000 R		   DD OFFSET PUT
 02AC  AD			   DB 0ADH
 02AD				L6:
 02AD  02			   DB 2
 02AE  6F 6F 70 6E 65		   DB 'oopne'
 02B3  1164 0000 R		   DD OFFSET GRP17
 02B7  E0			   DB 0E0H
 02B8  6F 6F 70 6E 7A		   DB 'oopnz'
 02BD  1164 0000 R		   DD OFFSET GRP17
 02C1  E0			   DB 0E0H
 02C2				M3:
 02C2  02			   DB 2
 02C3  6F 76			   DB 'ov'
 02C5  0C65 0000 R		   DD OFFSET GRP1
 02C9  88			   DB 88H
 02CA  75 6C			   DB 'ul'
 02CC  0FC3 0000 R		   DD OFFSET GRP10
 02D0  20			   DB 20H
 02D1				M4:
 02D1  02			   DB 2
 02D2  6F 76 62			   DB 'ovb'
 02D5  0CD4 0000 R		   DD OFFSET PUT
 02D9  A4			   DB 0A4H
 02DA  6F 76 77			   DB 'ovw'
 02DD  0CD4 0000 R		   DD OFFSET PUT
 02E1  A5			   DB 0A5H
 02E2				M5:
 02E2  02			   DB 2
 02E3  6F 76 73 62		   DB 'ovsb'
 02E7  0CD4 0000 R		   DD OFFSET PUT
 02EB  A4			   DB 0A4H
 02EC  6F 76 73 77		   DB 'ovsw'
 02F0  0CD4 0000 R		   DD OFFSET PUT
 02F4  A5			   DB 0A5H
 02F5				N3:
 02F5  03			   DB 3
 02F6  6F 74			   DB 'ot'
 02F8  0F73 0000 R		   DD OFFSET GRP9
 02FC  10			   DB 10H
 02FD  65 67			   DB 'eg'
 02FF  0F73 0000 R		   DD OFFSET GRP9
 0303  18			   DB 18H
 0304  6F 70			   DB 'op'
 0306  0CD4 0000 R		   DD OFFSET PUT
 030A  90			   DB 90H
 030B				O2:
 030B  01			   DB 1
 030C  72			   DB 'r'
 030D  1025 0000 R		   DD OFFSET GRP13
 0311  0A			   DB 0AH
 0312				O3:
 0312  02			   DB 2
 0313  75 74			   DB 'ut'
 0315  0E80 0000 R		   DD OFFSET GRP4
 0319  E6			   DB 0E6H
 031A  72 67			   DB 'rg'
 031C  0EA8 0000 R		   DD OFFSET GRP5
 0320  00			   DB 0
 0321				O4:
 0321  02			   DB 2
 0322  75 74 62			   DB 'utb'
 0325  0E80 0000 R		   DD OFFSET GRP4
 0329  E6			   DB 0E6H
 032A  75 74 77			   DB 'utw'
 032D  0E80 0000 R		   DD OFFSET GRP4
 0331  E7			   DB 0E7H
 0332				P3:
 0332  02			   DB 2
 0333  6F 70			   DB 'op'
 0335  1272 0000 R		   DD OFFSET GRP22
 0339  8F			   DB 8FH
 033A  75 74			   DB 'ut'
 033C  0EA8 0000 R		   DD OFFSET GRP5
 0340  03			   DB 3
 0341				P4:
 0341  02			   DB 2
 0342  75 73 68			   DB 'ush'
 0345  0DE6 0000 R		   DD OFFSET GRP2
 0349  FF			   DB 0FFH
 034A  6F 70 66			   DB 'opf'
 034D  0CD4 0000 R		   DD OFFSET PUT
 0351  9D			   DB 9DH
 0352				P5:
 0352  01			   DB 1
 0353  75 73 68 66		   DB 'ushf'
 0357  0CD4 0000 R		   DD OFFSET PUT
 035B  9C			   DB 9CH
 035C				R3:
 035C  06			   DB 6
 035D  65 74			   DB 'et'
 035F  10D9 0000 R		   DD OFFSET GRP16
 0363  C3			   DB 0C3H
 0364  65 70			   DB 'ep'
 0366  0CD4 0000 R		   DD OFFSET PUT
 036A  F3			   DB 0F3H
 036B  6F 6C			   DB 'ol'
 036D  0FF6 0000 R		   DD OFFSET GRP12
 0371  00			   DB 0
 0372  6F 72			   DB 'or'
 0374  0FF6 0000 R		   DD OFFSET GRP12
 0378  08			   DB 8
 0379  63 6C			   DB 'cl'
 037B  0FF6 0000 R		   DD OFFSET GRP12
 037F  10			   DB 10H
 0380  63 72			   DB 'cr'
 0382  0FF6 0000 R		   DD OFFSET GRP12
 0386  18			   DB 18H
 0387				R4:
 0387  02			   DB 2
 0388  65 70 7A			   DB 'epz'
 038B  0CD4 0000 R		   DD OFFSET PUT
 038F  F3			   DB 0F3H
 0390  65 70 65			   DB 'epe'
 0393  0CD4 0000 R		   DD OFFSET PUT
 0397  F3			   DB 0F3H
 0398				R5:
 0398  02			   DB 2
 0399  65 70 6E 7A		   DB 'epnz'
 039D  0CD4 0000 R		   DD OFFSET PUT
 03A1  F2			   DB 0F2H
 03A2  65 70 6E 65		   DB 'epne'
 03A6  0CD4 0000 R		   DD OFFSET PUT
 03AA  F2			   DB 0F2H
 03AB				S3:
 03AB  0B			   DB 11
 03AC  75 62			   DB 'ub'
 03AE  0F40 0000 R		   DD OFFSET GRP7
 03B2  2A			   DB 2AH
 03B3  62 62			   DB 'bb'
 03B5  0F40 0000 R		   DD OFFSET GRP7
 03B9  1A			   DB 1AH
 03BA  62 63			   DB 'bc'
 03BC  0F40 0000 R		   DD OFFSET GRP7
 03C0  1A			   DB 1AH
 03C1  74 63			   DB 'tc'
 03C3  0CD4 0000 R		   DD OFFSET PUT
 03C7  F9			   DB 0F9H
 03C8  74 64			   DB 'td'
 03CA  0CD4 0000 R		   DD OFFSET PUT
 03CE  FD			   DB 0FDH
 03CF  74 69			   DB 'ti'
 03D1  0CD4 0000 R		   DD OFFSET PUT
 03D5  FB			   DB 0FBH
 03D6  68 6C			   DB 'hl'
 03D8  0FF6 0000 R		   DD OFFSET GRP12
 03DC  20			   DB 20H
 03DD  68 72			   DB 'hr'
 03DF  0FF6 0000 R		   DD OFFSET GRP12
 03E3  28			   DB 28H
 03E4  61 6C			   DB 'al'
 03E6  0FF6 0000 R		   DD OFFSET GRP12
 03EA  20			   DB 20H
 03EB  61 72			   DB 'ar'
 03ED  0FF6 0000 R		   DD OFFSET GRP12
 03F1  38			   DB 38H
 03F2  65 67			   DB 'eg'
 03F4  125A 0000 R		   DD OFFSET GRP21
 03F8  26			   DB 26H
 03F9				S4:
 03F9  05			   DB 5
 03FA  63 61 62			   DB 'cab'
 03FD  0CD4 0000 R		   DD OFFSET PUT
 0401  AE			   DB 0AEH
 0402  63 61 77			   DB 'caw'
 0405  0CD4 0000 R		   DD OFFSET PUT
 0409  AF			   DB 0AFH
 040A  74 6F 62			   DB 'tob'
 040D  0CD4 0000 R		   DD OFFSET PUT
 0411  AA			   DB 0AAH
 0412  74 6F 77			   DB 'tow'
 0415  0CD4 0000 R		   DD OFFSET PUT
 0419  AB			   DB 0ABH
 041A  61 68 66			   DB 'ahf'
 041D  0CD4 0000 R		   DD OFFSET PUT
 0421  9E			   DB 9EH
 0422				S5:
 0422  04			   DB 4
 0423  63 61 73 62		   DB 'casb'
 0427  0CD4 0000 R		   DD OFFSET PUT
 042B  AE			   DB 0AEH
 042C  63 61 73 77		   DB 'casw'
 0430  0CD4 0000 R		   DD OFFSET PUT
 0434  AF			   DB 0AFH
 0435  74 6F 73 62		   DB 'tosb'
 0439  0CD4 0000 R		   DD OFFSET PUT
 043D  AA			   DB 0AAH
 043E  74 6F 73 77		   DB 'tosw'
 0442  0CD4 0000 R		   DD OFFSET PUT
 0446  AB			   DB 0ABH
 0447				T4:
 0447  01			   DB 1
 0448  65 73 74			   DB 'est'
 044B  1249 0000 R		   DD OFFSET GRP20
 044F  84			   DB 84H
 0450				U2:
 0450  01			   DB 1
 0451  70			   DB 'p'
 0452  0CD4 0000 R		   DD OFFSET PUT
 0456  FC			   DB 0FCH
 0457				W4:
 0457  01			   DB 1
 0458  61 69 74			   DB 'ait'
 045B  0CD4 0000 R		   DD OFFSET PUT
 045F  9B			   DB 9BH
 0460				X3:
 0460  01			   DB 1
 0461  6F 72			   DB 'or'
 0463  1025 0000 R		   DD OFFSET GRP13
 0467  32			   DB 32H
 0468				X4:
 0468  02			   DB 2
 0469  63 68 67			   DB 'chg'
 046C  0E19 0000 R		   DD OFFSET GRP3
 0470  86			   DB 86H
 0471  6C 61 74			   DB 'lat'
 0474  0CD4 0000 R		   DD OFFSET PUT
 0478  D7			   DB 0D7H


				; 8087 MNEMONIC TABLE
				; Similar to 8086 table above, except NOT distinguished by opcode length

 0479				XM1:	;F2XM1
 0479  01				DB	1		;One opcode
 047A  78 6D B1				DB	"xm", '1'+ 080H
 047D  01 F0				DB	1,0F0H

 047F				NDPA:
 047F  03				DB	3
 0480  64 E4				DB	"d", 'd'+ 080H
 0482  0E C1				DB	6+ARITH,0C1H
 0484  64 64 F0				DB	"dd", 'p'+ 080H
 0487  90 00				DB	NEEDOP+STACKOP,0
 0489  62 F3				DB	"b", 's'+ 080H
 048B  01 E1				DB	1,0E1H

 048D				NDPB:
 048D  02				DB	2
 048E  6C E4				DB	"l", 'd'+ 080H
 0490  9F 20				DB	7+NEEDOP+MEMORY,20H
 0492  73 74 F0				DB	"st", 'p'+ 080H
 0495  9F 30				DB	7+NEEDOP+MEMORY,30H

 0497				NDPC:
 0497  05				DB	5
 0498  6F ED				DB	"o", 'm'+ 080H
 049A  68 D1				DB	0+ONEREG+REAL,0D1H
 049C  6F 6D F0				DB	"om", 'p'+ 080H
 049F  68 D9				DB	0+ONEREG+REAL,0D9H
 04A1  68 F3				DB	"h", 's'+ 080H
 04A3  01 E0				DB	1,0E0H
 04A5  6F 6D 70 F0			DB	"omp", 'p'+ 080H
 04A9  06 D9				DB	6,0D9H
 04AB  6C 65 F8				DB	"le", 'x'+ 080H
 04AE  03 E2				DB	3,0E2H

 04B0				NDPD:
 04B0  06				DB	6
 04B1  69 F6				DB	"i", 'v'+ 080H
 04B3  0E F1				DB	6+ARITH,0F1H
 04B5  69 76 F0				DB	"iv", 'p'+ 080H
 04B8  90 30				DB	NEEDOP+STACKOP,30H
 04BA  69 76 F2				DB	"iv", 'r'+ 080H
 04BD  0E F9				DB	6+ARITH,0F9H
 04BF  69 76 72 F0			DB	"ivr", 'p'+ 080H
 04C3  90 38				DB	NEEDOP+STACKOP,38H
 04C5  65 63 73 74 F0			DB	"ecst", 'p'+ 080H
 04CA  01 F6				DB	1,0F6H
 04CC  69 73 E9				DB	"is", 'i'+ 080H
 04CF  03 E1				DB	3,0E1H

 04D1				NDPE:
 04D1  01				DB	1
 04D2  6E E9				DB	"n", 'i'+ 080H
 04D4  03 E0				DB	3,0E0H

 04D6				NDPF:
 04D6  01				DB	1
 04D7  72 65 E5				DB	"re", 'e'+ 080H
 04DA  C5 00				DB	5+NEEDOP+ONEREG,0

 04DC				NDPI:
 04DC  0D				DB	13
 04DD  61 64 E4				DB	"ad", 'd'+ 080H
 04E0  A2 00				DB	2+NEEDOP+INTEGER,0
 04E2  6C E4				DB	"l", 'd'+ 080H
 04E4  B3 00				DB	3+NEEDOP+INTEGER+EXTENDED,0
 04E6  73 75 E2				DB	"su", 'b'+ 080H
 04E9  A2 20				DB	2+NEEDOP+INTEGER,20H
 04EB  73 74 F0				DB	"st", 'p'+ 080H
 04EE  B3 18				DB	3+NEEDOP+INTEGER+EXTENDED,18H
 04F0  73 F4				DB	"s", 't'+ 080H
 04F2  A3 10				DB	3+NEEDOP+INTEGER,10H
 04F4  6D 75 EC				DB	"mu", 'l'+ 080H
 04F7  A2 08				DB	2+NEEDOP+INTEGER,8
 04F9  64 69 F6				DB	"di", 'v'+ 080H
 04FC  A2 30				DB	2+NEEDOP+INTEGER,30H
 04FE  73 75 62 F2			DB	"sub", 'r'+ 080H
 0502  A2 28				DB	2+NEEDOP+INTEGER,28H
 0504  64 69 76 F2			DB	"div", 'r'+ 080H
 0508  A2 38				DB	2+NEEDOP+INTEGER,38H
 050A  63 6F ED				DB	"co", 'm'+ 080H
 050D  A2 10				DB	2+NEEDOP+INTEGER,10H
 050F  63 6F 6D F0			DB	"com", 'p'+ 080H
 0513  A2 18				DB	2+NEEDOP+INTEGER,18H
 0515  6E 63 73 74 F0			DB	"ncst", 'p'+ 080H
 051A  01 F7				DB	1,0F7H
 051C  6E 69 F4				DB	"ni", 't'+ 080H
 051F  03 E3				DB	3,0E3H

 0521				NDPL:
 0521  0A				DB	10
 0522  E4				DB	'd' + 080H
 0523  F9 00				DB	1+NEEDOP+ONEREG+REAL+EXTENDED,0
 0525  64 FA				DB	"d", 'z'+ 080H
 0527  01 EE				DB	1,0EEH
 0529  64 B1				DB	"d", '1'+ 080H
 052B  01 E8				DB	1,0E8H
 052D  64 70 E9				DB	"dp", 'i'+ 080H
 0530  01 EB				DB	1,0EBH
 0532  64 6C 32 F4			DB	"dl2", 't'+ 080H
 0536  01 E9				DB	1,0E9H
 0538  64 6C 32 E5			DB	"dl2", 'e'+ 080H
 053C  01 EA				DB	1,0EAH
 053E  64 6C 67 B2			DB	"dlg", '2'+ 080H
 0542  01 EC				DB	1,0ECH
 0544  64 6C 6E B2			DB	"dln", '2'+ 080H
 0548  01 ED				DB	1,0EDH
 054A  64 63 F7				DB	"dc", 'w'+ 080H
 054D  99 28				DB	1+NEEDOP+MEMORY,28H
 054F  64 65 6E F6			DB	"den", 'v'+ 080H
 0553  99 20				DB	1+NEEDOP+MEMORY,20H

 0555				NDPM:
 0555  02				DB	2
 0556  75 EC				DB	"u", 'l'+ 080H
 0558  0E C9				DB	6+ARITH,0C9H
 055A  75 6C F0				DB	"ul", 'p'+ 080H
 055D  90 08				DB	NEEDOP+STACKOP,8

 055F				NDPO:
 055F  01				DB	1
 0560  F0				DB	'p' + 080H
 0561  81 00				DB	NEEDOP+1,0	;Flag special handling

 0563				NDPN:
 0563  01				DB	1
 0564  6F F0				DB	"o", 'p'+ 080H
 0566  01 D0				DB	1,0D0H

 0568				NDPP:
 0568  03				DB	3
 0569  72 65 ED				DB	"re", 'm'+ 080H
 056C  01 F8				DB	1,0F8H
 056E  74 61 EE				DB	"ta", 'n'+ 080H
 0571  01 F2				DB	1,0F2H
 0573  61 74 61 EE			DB	"ata", 'n'+ 080H
 0577  01 F3				DB	1,0F3H

 0579				NDPR:
 0579  02				DB	2
 057A  6E 64 69 6E F4			DB	"ndin", 't'+ 080H
 057F  01 FC				DB	1,0FCH
 0581  73 74 6F F2			DB	"sto", 'r'+ 080H
 0585  9D 20				DB	5+NEEDOP+MEMORY,20H

 0587				NDPS:
 0587  0C				DB	12
 0588  F4				DB	't' + 080H
 0589  ED D0				DB	5+NEEDOP+ONEREG+REAL,0D0H
 058B  74 F0				DB	"t", 'p'+ 080H
 058D  FF D8				DB	7+NEEDOP+ONEREG+REAL+EXTENDED,0D8H
 058F  75 E2				DB	"u", 'b'+ 080H
 0591  0E E1				DB	6+ARITH,0E1H
 0593  75 62 F0				DB	"ub", 'p'+ 080H
 0596  90 E0				DB	NEEDOP+STACKOP,0E0H
 0598  75 62 F2				DB	"ub", 'r'+ 080H
 059B  0E E9				DB	6+ARITH,0E9H
 059D  75 62 72 F0			DB	"ubr", 'p'+ 080H
 05A1  90 E8				DB	NEEDOP+STACKOP,0E8H
 05A3  71 72 F4				DB	"qr", 't'+ 080H
 05A6  01 FA				DB	1,0FAH
 05A8  63 61 6C E5			DB	"cal", 'e'+ 080H
 05AC  01 FD				DB	1,0FDH
 05AE  61 76 E5				DB	"av", 'e'+ 080H
 05B1  9D 30				DB	5+NEEDOP+MEMORY,30H
 05B3  74 63 F7				DB	"tc", 'w'+ 080H
 05B6  99 38				DB	1+NEEDOP+MEMORY,38H
 05B8  74 65 6E F6			DB	"ten", 'v'+ 080H
 05BC  99 30				DB	1+NEEDOP+MEMORY,30H
 05BE  74 73 F7				DB	"ts", 'w'+ 080H
 05C1  9D 38				DB	5+NEEDOP+MEMORY,38H

 05C3				NDPT:
 05C3  01				DB	1
 05C4  73 F4				DB	"s", 't'+ 080H
 05C6  01 E4				DB	1,0E4H

 05C8				NDPW:
 05C8  01				DB	1
 05C9  61 69 F4				DB	"ai", 't'+ 080H
 05CC  80 00				DB	NEEDOP,0	;Flag special handling

 05CE				NDPX:
 05CE  03				DB	3
 05CF  63 E8				DB	"c", 'h'+ 080H
 05D1  41 C9				DB	1+ONEREG,0C9H
 05D3  61 ED				DB	"a", 'm'+ 080H
 05D5  01 E5				DB	1,0E5H
 05D7  74 72 61 63 F4			DB	"trac", 't'+ 080H
 05DC  01 F4				DB	1,0F4H

 05DE				NDPY:
 05DE  02				DB	2
 05DF  6C 32 F8				DB	"l2", 'x'+ 080H
 05E2  01 F1				DB	1,0F1H
 05E4  6C 32 78 70 B1			DB	"l2xp", '1'+ 080H
 05E9  01 F9				DB	1,0F9H

				ALIGN 4
 05EC				OPTAB:
				; Table of pointers  to mnemonics. For each letter of the alphabet (the
				; starting letter of the mnemonic), there are 5 entries. Each entry
				; corresponds to a mnemonic whose length is 2, 3, 4, 5, and 6 characters
				; long, respectively. If there are no mnemonics for a given combination
				; of first letter and length (such as A-2), then the corresponding entry
				; points to NONE. Otherwise, it points to a place in the mnemonic table
				; for that type.

				; This table only needs to be modified if a mnemonic is added to a group
				; previously marked NONE. Change the NONE to a label made up of the first
				; letter of the mnemonic and its length, then add a new subsection to
				; the mnemonic table in alphabetical order.

 05EC  0000 0000 R		   DD OFFSET NONE  ;A2
 05F0  0001 0000 R		   DD OFFSET A3    ;A3
 05F4  0000 0000 R		   DD OFFSET NONE  ;A4
 05F8  0033 0000 R		   DD OFFSET A5    ;A5
 05FC  0000 0000 R		   DD OFFSET NONE  ;B1
 0600  0000 0000 R		   DD OFFSET NONE  ;B2
 0604  0000 0000 R		   DD OFFSET NONE  ;B3
 0608  0000 0000 R		   DD OFFSET NONE  ;B4
 060C  0000 0000 R		   DD OFFSET NONE  ;B5
 0610  0000 0000 R		   DD OFFSET NONE  ;C1
 0614  0000 0000 R		   DD OFFSET NONE  ;C2
 0618  003D 0000 R		   DD OFFSET C3    ;C3
 061C  006F 0000 R		   DD OFFSET C4    ;C4
 0620  0088 0000 R		   DD OFFSET C5    ;C5
 0624  0000 0000 R		   DD OFFSET NONE  ;D1
 0628  009B 0000 R		   DD OFFSET D2    ;D2
 062C  00BA 0000 R		   DD OFFSET D3    ;D3
 0630  00D7 0000 R		   DD OFFSET D4    ;D4
 0634  0000 0000 R		   DD OFFSET NONE  ;D5
 0638  0000 0000 R		   DD OFFSET NONE  ;E1
 063C  00E0 0000 R		   DD OFFSET E2    ;E2
 0640  00E7 0000 R		   DD OFFSET E3    ;E3
 0644  0000 0000 R		   DD OFFSET NONE  ;E4
 0648  00FD 0000 R		   DD OFFSET E5    ;E5
 064C  0000 0000 R		   DD OFFSET NONE
 0650  0000 0000 R		   DD OFFSET NONE  ;F
 0654  0000 0000 R		   DD OFFSET NONE
 0658  0000 0000 R		   DD OFFSET NONE
 065C  0000 0000 R		   DD OFFSET NONE
 0660  0000 0000 R		   DD OFFSET NONE
 0664  0000 0000 R		   DD OFFSET NONE  ;G
 0668  0000 0000 R		   DD OFFSET NONE
 066C  0000 0000 R		   DD OFFSET NONE
 0670  0000 0000 R		   DD OFFSET NONE
 0674  0000 0000 R		   DD OFFSET NONE
 0678  0000 0000 R		   DD OFFSET NONE  ;H
 067C  0107 0000 R		   DD OFFSET H3
 0680  010F 0000 R		   DD OFFSET H4
 0684  0000 0000 R		   DD OFFSET NONE
 0688  0000 0000 R		   DD OFFSET NONE
 068C  0118 0000 R		   DD OFFSET I2 ;I
 0690  0125 0000 R		   DD OFFSET I3
 0694  0142 0000 R		   DD OFFSET I4
 0698  0000 0000 R		   DD OFFSET NONE
 069C  0000 0000 R		   DD OFFSET NONE
 06A0  0163 0000 R		   DD OFFSET J2 ;J
 06A4  01A0 0000 R		   DD OFFSET J3
 06A8  0218 0000 R		   DD OFFSET J4
 06AC  0000 0000 R		   DD OFFSET NONE
 06B0  0000 0000 R		   DD OFFSET NONE
 06B4  0000 0000 R		   DD OFFSET NONE  ;K
 06B8  0000 0000 R		   DD OFFSET NONE
 06BC  0000 0000 R		   DD OFFSET NONE
 06C0  0000 0000 R		   DD OFFSET NONE
 06C4  0000 0000 R		   DD OFFSET NONE
 06C8  0000 0000 R		   DD OFFSET NONE  ;L
 06CC  0249 0000 R		   DD OFFSET L3
 06D0  025F 0000 R		   DD OFFSET L4
 06D4  0288 0000 R		   DD OFFSET L5
 06D8  02AD 0000 R		   DD OFFSET L6
 06DC  0000 0000 R		   DD OFFSET NONE  ;M
 06E0  02C2 0000 R		   DD OFFSET M3
 06E4  02D1 0000 R		   DD OFFSET M4
 06E8  02E2 0000 R		   DD OFFSET M5
 06EC  0000 0000 R		   DD OFFSET NONE
 06F0  0000 0000 R		   DD OFFSET NONE  ;N
 06F4  02F5 0000 R		   DD OFFSET N3
 06F8  0000 0000 R		   DD OFFSET NONE
 06FC  0000 0000 R		   DD OFFSET NONE
 0700  0000 0000 R		   DD OFFSET NONE
 0704  030B 0000 R		   DD OFFSET O2 ;O
 0708  0312 0000 R		   DD OFFSET O3
 070C  0321 0000 R		   DD OFFSET O4
 0710  0000 0000 R		   DD OFFSET NONE
 0714  0000 0000 R		   DD OFFSET NONE
 0718  0000 0000 R		   DD OFFSET NONE  ;P
 071C  0332 0000 R		   DD OFFSET P3
 0720  0341 0000 R		   DD OFFSET P4
 0724  0352 0000 R		   DD OFFSET P5
 0728  0000 0000 R		   DD OFFSET NONE
 072C  0000 0000 R		   DD OFFSET NONE  ;Q
 0730  0000 0000 R		   DD OFFSET NONE
 0734  0000 0000 R		   DD OFFSET NONE
 0738  0000 0000 R		   DD OFFSET NONE
 073C  0000 0000 R		   DD OFFSET NONE
 0740  0000 0000 R		   DD OFFSET NONE  ;R
 0744  035C 0000 R		   DD OFFSET R3
 0748  0387 0000 R		   DD OFFSET R4
 074C  0398 0000 R		   DD OFFSET R5
 0750  0000 0000 R		   DD OFFSET NONE
 0754  0000 0000 R   DD OFFSET NONE  ;S
 0758  03AB 0000 R		   DD OFFSET S3
 075C  03F9 0000 R		   DD OFFSET S4
 0760  0422 0000 R		   DD OFFSET S5
 0764  0000 0000 R		   DD OFFSET NONE
 0768  0000 0000 R		   DD OFFSET NONE  ;T
 076C  0000 0000 R		   DD OFFSET NONE
 0770  0447 0000 R		   DD OFFSET T4
 0774  0000 0000 R		   DD OFFSET NONE
 0778  0000 0000 R		   DD OFFSET NONE
 077C  0450 0000 R		   DD OFFSET U2 ;U
 0780  0000 0000 R		   DD OFFSET NONE
 0784  0000 0000 R		   DD OFFSET NONE
 0788  0000 0000 R		   DD OFFSET NONE
 078C  0000 0000 R		   DD OFFSET NONE
 0790  0000 0000 R		   DD OFFSET NONE  ;V
 0794  0000 0000 R		   DD OFFSET NONE
 0798  0000 0000 R		   DD OFFSET NONE
 079C  0000 0000 R		   DD OFFSET NONE
 07A0  0000 0000 R		   DD OFFSET NONE
 07A4  0000 0000 R		   DD OFFSET NONE  ;W
 07A8  0000 0000 R		   DD OFFSET NONE
 07AC  0457 0000 R		   DD OFFSET W4
 07B0  0000 0000 R		   DD OFFSET NONE
 07B4  0000 0000 R		   DD OFFSET NONE
 07B8  0000 0000 R		   DD OFFSET NONE  ;X
 07BC  0460 0000 R		   DD OFFSET X3
 07C0  0468 0000 R		   DD OFFSET X4
 07C4  0000 0000 R		   DD OFFSET NONE
 07C8  0000 0000 R		   DD OFFSET NONE
 07CC  0000 0000 R		   DD OFFSET NONE  ;Y
 07D0  0000 0000 R		   DD OFFSET NONE
 07D4  0000 0000 R		   DD OFFSET NONE
 07D8  0000 0000 R		   DD OFFSET NONE
 07DC  0000 0000 R		   DD OFFSET NONE
 07E0  0000 0000 R		   DD OFFSET NONE  ;Z
 07E4  0000 0000 R		   DD OFFSET NONE
 07E8  0000 0000 R		   DD OFFSET NONE
 07EC  0000 0000 R		   DD OFFSET NONE
 07F0  0000 0000 R		   DD OFFSET NONE
				ALIGN 4
 07F4				NDPTAB:
				;Lookup table for 8087 mnemonics. There is one entry for each letter of the
				;alphabet
 07F4  047F 0000 R		   DD OFFSET NDPA
 07F8  048D 0000 R		   DD OFFSET NDPB
 07FC  0497 0000 R		   DD OFFSET NDPC
 0800  04B0 0000 R		   DD OFFSET NDPD
 0804  04D1 0000 R		   DD OFFSET NDPE
 0808  04D6 0000 R		   DD OFFSET NDPF
 080C  0000 0000 R		   DD OFFSET NONE  ;G
 0810  0000 0000 R		   DD OFFSET NONE  ;H
 0814  04DC 0000 R		   DD OFFSET NDPI
 0818  0000 0000 R		   DD OFFSET NONE  ;J
 081C  0000 0000 R		   DD OFFSET NONE  ;K
 0820  0521 0000 R		   DD OFFSET NDPL
 0824  0555 0000 R		   DD OFFSET NDPM
 0828  0563 0000 R		   DD OFFSET NDPN
 082C  055F 0000 R		   DD OFFSET NDPO
 0830  0568 0000 R		   DD OFFSET NDPP
 0834  0000 0000 R		   DD OFFSET NONE  ;Q
 0838  0579 0000 R		   DD OFFSET NDPR
 083C  0587 0000 R		   DD OFFSET NDPS
 0840  05C3 0000 R		   DD OFFSET NDPT
 0844  0000 0000 R		   DD OFFSET NONE  ;U
 0848  0000 0000 R		   DD OFFSET NONE  ;V
 084C  05C8 0000 R		   DD OFFSET NDPW
 0850  05CE 0000 R		   DD OFFSET NDPX
 0854  05DE 0000 R		   DD OFFSET NDPY
 0858  0000 0000 R		   DD OFFSET NONE  ;Z

				;Error message table

				;Error message table

 085C				ERRTAB:
 085C  01 52 65 67 69 73		DB	1, "Register not allowed in immediate valu", 'e'+ 080H
       74 65 72 20 6E 6F
       74 20 61 6C 6C 6F
       77 65 64 20 69 6E
       20 69 6D 6D 65 64
       69 61 74 65 20 76
       61 6C 75 E5
 0884  02 49 6E 64 65 78		DB	2, "Index or base register must be BP, BX, SI, or D", 'I'+ 080H
       20 6F 72 20 62 61
       73 65 20 72 65 67
       69 73 74 65 72 20
       6D 75 73 74 20 62
       65 20 42 50 2C 20
       42 58 2C 20 53 49
       2C 20 6F 72 20 44
       C9
 08B5  03 4F 6E 6C 79 20		DB	3, "Only one base register (BX, BP) allowe", 'd'+ 080H
       6F 6E 65 20 62 61
       73 65 20 72 65 67
       69 73 74 65 72 20
       28 42 58 2C 20 42
       50 29 20 61 6C 6C
       6F 77 65 E4
 08DD  04 4F 6E 6C 79 20		DB	4, "Only one index register (SI or DI) allowe", 'd'+ 080H
       6F 6E 65 20 69 6E
       64 65 78 20 72 65
       67 69 73 74 65 72
       20 28 53 49 20 6F
       72 20 44 49 29 20
       61 6C 6C 6F 77 65
       E4
 0908  05 4F 6E 6C 79 20		DB	5, "Only addition allowed on register or undefined labe", 'l'+ 080H
       61 64 64 69 74 69
       6F 6E 20 61 6C 6C
       6F 77 65 64 20 6F
       6E 20 72 65 67 69
       73 74 65 72 20 6F
       72 20 75 6E 64 65
       66 69 6E 65 64 20
       6C 61 62 65 EC
 093D  06 4F 6E 6C 79 20		DB	6, "Only one undefined label per expression allowe", 'd'+ 080H
       6F 6E 65 20 75 6E
       64 65 66 69 6E 65
       64 20 6C 61 62 65
       6C 20 70 65 72 20
       65 78 70 72 65 73
       73 69 6F 6E 20 61
       6C 6C 6F 77 65 E4
 096D  07 49 6C 6C 65 67		DB	7, "Illegal digit in hexadecimal numbe", 'r'+ 080H
       61 6C 20 64 69 67
       69 74 20 69 6E 20
       68 65 78 61 64 65
       63 69 6D 61 6C 20
       6E 75 6D 62 65 F2
 0991  08 49 6C 6C 65 67		DB	8, "Illegal digit in decimal numbe", 'r'+ 080H
       61 6C 20 64 69 67
       69 74 20 69 6E 20
       64 65 63 69 6D 61
       6C 20 6E 75 6D 62
       65 F2
 09B1  0A 49 6C 6C 65 67		DB	10, "Illegal character in label or opcod", 'e'+ 080H
       61 6C 20 63 68 61
       72 61 63 74 65 72
       20 69 6E 20 6C 61
       62 65 6C 20 6F 72
       20 6F 70 63 6F 64
       E5
 09D6  0B 4C 61 62 65 6C		DB	11, "Label defined twic", 'e'+ 080H
       20 64 65 66 69 6E
       65 64 20 74 77 69
       63 E5
 09EA  0C 4F 70 63 6F 64		DB	12, "Opcode not recognize", 'd'+ 080H
       65 20 6E 6F 74 20
       72 65 63 6F 67 6E
       69 7A 65 E4
 0A00  14 49 6E 76 61 6C		DB	20, "Invalid operan", 'd'+ 080H
       69 64 20 6F 70 65
       72 61 6E E4
 0A10  15 22 2C 20 22 20		DB	21, '", " and second operand expected'
       61 6E 64 20 73 65
       63 6F 6E 64 20 6F
       70 65 72 61 6E 64
       20 65 78 70 65 63
       74 65 64
 0A31  16 52 65 67 69 73		DB	22, "Register mismatc", 'h'+ 080H
       74 65 72 20 6D 69
       73 6D 61 74 63 E8
 0A43  17 49 6D 6D 65 64		DB	23, "Immediate operand not allowe", 'd'+ 080H
       69 61 74 65 20 6F
       70 65 72 61 6E 64
       20 6E 6F 74 20 61
       6C 6C 6F 77 65 E4
 0A61  18 22 5D 22 20 65		DB	24, '"]" expecte', 'd'+ 080H
       78 70 65 63 74 65
       E4
 0A6E  19 54 77 6F 20 6D		DB	25, "Two memory operands not allowe", 'd'+ 080H
       65 6D 6F 72 79 20
       6F 70 65 72 61 6E
       64 73 20 6E 6F 74
       20 61 6C 6C 6F 77
       65 E4
 0A8E  1A 44 65 73 74 69		DB	26, "Destination must not be immediate valu", 'e'+ 080H
       6E 61 74 69 6F 6E
       20 6D 75 73 74 20
       6E 6F 74 20 62 65
       20 69 6D 6D 65 64
       69 61 74 65 20 76
       61 6C 75 E5
 0AB6  1B 42 6F 74 68 20		DB	27, "Both operands must not be register", 's'+ 080H
       6F 70 65 72 61 6E
       64 73 20 6D 75 73
       74 20 6E 6F 74 20
       62 65 20 72 65 67
       69 73 74 65 72 F3
 0ADA  1C 4F 70 65 72 61		DB	28, "Operand must be segment registe", 'r'+ 080H
       6E 64 20 6D 75 73
       74 20 62 65 20 73
       65 67 6D 65 6E 74
       20 72 65 67 69 73
       74 65 F2
 0AFB  1D 46 69 72 73 74		DB	29, "First operand must be registe", 'r'+ 080H
       20 6F 70 65 72 61
       6E 64 20 6D 75 73
       74 20 62 65 20 72
       65 67 69 73 74 65
       F2
 0B1A  1E 55 6E 64 65 66		DB	30, "Undefined label not allowe", 'd'+ 080H
       69 6E 65 64 20 6C
       61 62 65 6C 20 6E
       6F 74 20 61 6C 6C
       6F 77 65 E4
 0B36  1F 56 61 6C 75 65		DB	31, "Value out of rang", 'e'+ 080H
       20 6F 75 74 20 6F
       66 20 72 61 6E 67
       E5
 0B49  20 4D 69 73 73 69		DB	32, "Missing or illegal operand size fla", 'g'+ 080H
       6E 67 20 6F 72 20
       69 6C 6C 65 67 61
       6C 20 6F 70 65 72
       61 6E 64 20 73 69
       7A 65 20 66 6C 61
       E7
 0B6E  21 4D 75 73 74 20		DB	33, "Must have label on same lin", 'e'+ 080H
       68 61 76 65 20 6C
       61 62 65 6C 20 6F
       6E 20 73 61 6D 65
       20 6C 69 6E E5
 0B8B  23 5A 65 72 6F 2D		DB	35, "Zero-length string illega", 'l'+ 080H
       6C 65 6E 67 74 68
       20 73 74 72 69 6E
       67 20 69 6C 6C 65
       67 61 EC
 0BA6  24 45 4E 44 49 46		DB	36, "ENDIF without I", 'F'+ 080H
       20 77 69 74 68 6F
       75 74 20 49 C6
 0BB7  25 4F 6E 65 2D 63		DB	37, "One-character strings onl", 'y'+ 080H
       68 61 72 61 63 74
       65 72 20 73 74 72
       69 6E 67 73 20 6F
       6E 6C F9
 0BD2  26 49 6C 6C 65 67		DB	38, "Illegal expressio", 'n'+ 080H
       61 6C 20 65 78 70
       72 65 73 73 69 6F
       EE
 0BE5  27 45 6E 64 20 6F		DB	39, "End of string not foun", 'd'+ 080H
       66 20 73 74 72 69
       6E 67 20 6E 6F 74
       20 66 6F 75 6E E4
 0BFD  64 55 6E 64 65 66		DB	100, "Undefined labe", 'l'+ 080H
       69 6E 65 64 20 6C
       61 62 65 EC
 0C0D  65 56 61 6C 75 65		DB	101, "Value out of range (forward", ')'+ 080H
       20 6F 75 74 20 6F
       66 20 72 61 6E 67
       65 20 28 66 6F 72
       77 61 72 64 A9
 0C2A  FF				DB	255

 0C2B 2A 2A 2A 2A 2A 20		_ERRMES	DB	'***** ERROR: ',0A0H
       45 52 52 4F 52 3A
       20 A0
 0C39 0D 0A 46 69 6C 65		NOSPAC	DB	13,10,'File creation error',13,10,"$"
       20 63 72 65 61 74
       69 6F 6E 20 65 72
       72 6F 72 0D 0A 24
 0C51 0D 0A 49 6E 73 75		NOMEM	DB	13,10,'Insufficient memory',13,10,'$'
       66 66 69 63 69 65
       6E 74 20 6D 65 6D
       6F 72 79 0D 0A 24
 0C69 0D 0A 46 69 6C 65		NOFILE	DB	13,10,'File not found',13,10,'$'
       20 6E 6F 74 20 66
       6F 75 6E 64 0D 0A
       24
 0C7C 0D 0A 44 69 73 6B		WRTERR	DB	13,10,'Disk full',13,10,'$'
       20 66 75 6C 6C 0D
       0A 24
 0C8A 0D 0A 42 61 64 20		BADDSK	DB	13,10,'Bad disk specifier',13,10,'$'
       64 69 73 6B 20 73
       70 65 63 69 66 69
       65 72 0D 0A 24
 0CA1 0D 0A 0D 0A 45 72		ERCNTM	DB	13, 10, 13, 10, 'Error Count ', '='+ 080H
       72 6F 72 20 43 6F
       75 6E 74 20 BD
 0CB2 0D 0A 53 79 6D 62		SYMSIZE	DB	13, 10, 'Symbol Table size =', ' '+ 080H
       6F 6C 20 54 61 62
       6C 65 20 73 69 7A
       65 20 3D A0
 0CC8 46 72 65 65 20 73		FRESIZE	DB	'Free space =       ', ' '+ 080H
       70 61 63 65 20 3D
       20 20 20 20 20 20
       20 A0
 0CDC 0D 0A 53 79 6D 62		SYMMES	DB	13, 10, 'Symbol Tabl', 'e'+ 080H, 13, 10, 13, 10
       6F 6C 20 54 61 62
       6C E5 0D 0A 0D 0A
 0CEE 2E 41 53 4D 00 00		EXTEND	DB	'.ASM',0,0
 0CF4 05 65 6E 64 69 66		IFEND	DB	5,'endif'
 0CFA 02 69 66			IFNEST	DB	2,'if'
 0CFD 72 65 F4			RETSTR	DB	're', 't'+ 080H
				;NOTICE: should use rb to make length correct
 0D00 72 62 00			OPEN_FLAG  DB 'rb',0
 0D03 77 62 00			WRITE_FLAG DB 'wb',0

 0D06 62 64 63 61		REGTAB  DB 'bdca'
 0D0A 64 73 63 65		SEGTAB  DB 'dsce'

 0D0E  0106 [			SRCNAME  DB (NAME_LENGTH + 2) DUP(0)
        00
       ]

 0E14 00000000			SRCNAME_LENGTH DD 0
 0E18 00000000			SRCLENGTH DD 0
 0E1C 00000000			SRCFILE  DD 0
 0E20 00000000			HEXFILE  DD 0
 0E24 00000000			LSTFILE  DD 0

 0E28  0106 [			HEXNAME  DB (NAME_LENGTH + 2) DUP(0)
        00
       ]

 0F2E  0106 [			LSTNAME  DB (NAME_LENGTH + 2) DUP(0)
        00
       ]
				ALIGN 4
 1034 00			MAXFLG  DB 0
 1035 00			FLAG    DB 0
				;4+80
 1036 00000000			LENID   DD 0	;USE 4 BYTES
 103A  0050 [			ID      DB 80 DUP(0)
        00
       ]
				ALIGN 4
 108C 00000000			PC      DD 0
 1090 00000000			OLDPC   DD 0
 1094 00000000			LABPT   DD 0
 1098 00000000			_ADDR    DD 0
 109C 00000000			ALABEL  DD 0
 10A0 00000000			_DATA   DD 0
 10A4 00000000			DLABEL  DD 0
 10A8 00000000			CON     DD 0
 10AC 00000000			UNDEF   DD 0
 10B0 FF			CHR     DB -1
 10B1 00			SYM     DB 0
 10B2 00000000			BASE    DD 0
 10B6 00000000			_HEAP   DD 0
 10BA 00000000			SYMLIN  DD 0
 10BE 00000000			CODE    DD 0
 10C2 00			DATSIZ  DB 0
 10C3 00000000			RELOC   DD 0
 10C7 00000000			BCOUNT  DD 0
 10CB 00000000			COUNT   DD 0
 10CF 00000000			_ERR    DD 0
 10D3 00000000			LINE    DD 0
 10D7 00000000			HEXLEN  DD 0
 10DB 00000000			HEXADD  DD 0
 10DF 00000000			LASTAD  DD 0
 10E3 00000000			HEXCNT  DD 0
 10E7 00000000			CHKSUM  DD 0
 10EB 00000000			LINFLG  DD 0
 10EF 00000000			PREV    DD 0
 10F3 00			IFFLG   DB 0
 10F4 00			CHKLAB  DB 0
 10F5 00000000			ERRCNT  DD 0
 10F9 00000000			LSTRET  DD 0
 10FD 00000000			RETPT   DD 0
 1101 00000000			LSTDEV  DD 0
 1105 00000000			SPC     DD 0
 1109 00000000			NOWAIT  DD 0
 110D 00000000			IX      DD 0
 1111 00000000			IY      DD 0
 1115 00000000			HEXPNT  DD 0
 1119 00000000			LSTPNT  DD 0
 111D 00000000			STACK_  DD 0
 1121 00000001			LINE_COUNT DD 1
 1125 00000000			CHAR_LOCATION DD 0
 1129 00000000			LAST_READ_CHAR_COUNT DD 0
 112D 00000000			TOTAL_READ_CHAR_COUNT DD 0
 1131 00000000			SRCBUF_COUNT DD 0
 1135  0046 [			HEXBUF  DB HEXBUFSIZ DUP(0)
        00
       ]
 117B  0400 [			LSTBUF  DB LSTBUFSIZ DUP(0)
        00
       ]
				ALIGN 4
 157C 00000000			BUFPT   DD 0
 1580  0400 [			SRCBUF  DB BUFSIZ DUP(0)
        00
       ]
 1980  00000000					DD 0
 1984  0100 [			        DB 100H DUP(0)
        00
       ]
				ALIGN 4
 1A84				CODE_START: 
 1A84  0100 [					DB 100H DUP(0)
        00
       ]
				;1M
 1B84				HEAP_START: 
 1B84  0100 [					DB 100H DUP(0)
        00
       ]

 1C84				DATASEG ENDS
						END
Microsoft (R) Macro Assembler Version 14.44.35221.0	    12/05/25 19:37:33
ASM32.ASM						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

CODESEG  . . . . . . . . . . . .	16 Bit	 18AF	  	  Public  'CODE'	
DATASEG  . . . . . . . . . . . .	16 Bit	 1C84	  	  Public  'DATA'	


Symbols:

                N a m e                 Type     Value    Attr

A3 . . . . . . . . . . . . . . .	L Near	 0001	  DATASEG	
A5 . . . . . . . . . . . . . . .	L Near	 0033	  DATASEG	
ABORT  . . . . . . . . . . . . .	L Near	 01EE	  CODESEG	
ACCIMM . . . . . . . . . . . . .	L Near	 102E	  CODESEG	
ACCJ . . . . . . . . . . . . . .	L Near	 0F6A	  CODESEG	
AFHEX  . . . . . . . . . . . . .	L Near	 17E0	  CODESEG	
AIMM_SKIP  . . . . . . . . . . .	L Near	 104B	  CODESEG	
AIMM . . . . . . . . . . . . . .	L Near	 1037	  CODESEG	
ALABEL . . . . . . . . . . . . .	DWord	 109C	  DATASEG	
ALLRET_RET . . . . . . . . . . .	L Near	 0908	  CODESEG	
ALLRET . . . . . . . . . . . . .	L Near	 08E1	  CODESEG	
ARITH  . . . . . . . . . . . . .	Number	 0008h	 
ASMLIN_SKIP  . . . . . . . . . .	L Near	 0A30	  CODESEG	
ASMLIN . . . . . . . . . . . . .	L Near	 0A19	  CODESEG	
BADDSK . . . . . . . . . . . . .	Byte	 0C8A	  DATASEG	
BADFLAG  . . . . . . . . . . . .	L Near	 0C06	  CODESEG	
BADOP  . . . . . . . . . . . . .	L Near	 04F6	  CODESEG	
BASE . . . . . . . . . . . . . .	DWord	 10B2	  DATASEG	
BCOUNT . . . . . . . . . . . . .	DWord	 10C7	  DATASEG	
BLNK . . . . . . . . . . . . . .	L Near	 145B	  CODESEG	
BPJ  . . . . . . . . . . . . . .	L Near	 0598	  CODESEG	
BUFPT  . . . . . . . . . . . . .	DWord	 157C	  DATASEG	
BUFSIZ . . . . . . . . . . . . .	Number	 0400h	 
BXJ  . . . . . . . . . . . . . .	L Near	 059B	  CODESEG	
BYTIMM . . . . . . . . . . . . .	L Near	 0C8B	  CODESEG	
BYTSIZ . . . . . . . . . . . . .	L Near	 0601	  CODESEG	
C3 . . . . . . . . . . . . . . .	L Near	 003D	  DATASEG	
C4 . . . . . . . . . . . . . . .	L Near	 006F	  DATASEG	
C5 . . . . . . . . . . . . . . .	L Near	 0088	  DATASEG	
CHAR_LOCATION  . . . . . . . . .	DWord	 1125	  DATASEG	
CHKLAB . . . . . . . . . . . . .	Byte	 10F4	  DATASEG	
CHKRET . . . . . . . . . . . . .	L Near	 08B1	  CODESEG	
CHKSUM . . . . . . . . . . . . .	DWord	 10E7	  DATASEG	
CHR  . . . . . . . . . . . . . .	Byte	 10B0	  DATASEG	
CODBYT . . . . . . . . . . . . .	L Near	 1791	  CODESEG	
CODE_START . . . . . . . . . . .	L Near	 1A84	  DATASEG	
CODE . . . . . . . . . . . . . .	DWord	 10BE	  DATASEG	
CODLP  . . . . . . . . . . . . .	L Near	 1443	  CODESEG	
CONST  . . . . . . . . . . . . .	Number	 0001h	 
CON  . . . . . . . . . . . . . .	DWord	 10A8	  DATASEG	
COPY_NAME  . . . . . . . . . . .	L Near	 0033	  CODESEG	
COUNT  . . . . . . . . . . . . .	DWord	 10CB	  DATASEG	
CPSLP_RET  . . . . . . . . . . .	L Near	 09B2	  CODESEG	
CPSLP  . . . . . . . . . . . . .	L Near	 099F	  CODESEG	
CREATE_FILE  . . . . . . . . . .	L Near	 01FF	  CODESEG	
CREATE . . . . . . . . . . . . .	L Near	 094E	  CODESEG	
CRLF . . . . . . . . . . . . . .	L Near	 14FA	  CODESEG	
D2 . . . . . . . . . . . . . . .	L Near	 009B	  DATASEG	
D3 . . . . . . . . . . . . . . .	L Near	 00BA	  DATASEG	
D4 . . . . . . . . . . . . . . .	L Near	 00D7	  DATASEG	
DATSIZ . . . . . . . . . . . . .	Byte	 10C2	  DATASEG	
DDS  . . . . . . . . . . . . . .	L Near	 149A	  CODESEG	
DEFBYT . . . . . . . . . . . . .	L Near	 13D9	  CODESEG	
DIGIT  . . . . . . . . . . . . .	L Near	 1539	  CODESEG	
DIJ  . . . . . . . . . . . . . .	L Near	 058C	  CODESEG	
DIRECT . . . . . . . . . . . . .	L Near	 1098	  CODESEG	
DLABEL . . . . . . . . . . . . .	DWord	 10A4	  DATASEG	
DOLLAR . . . . . . . . . . . . .	L Near	 0642	  CODESEG	
DOMUL  . . . . . . . . . . . . .	L Near	 053C	  CODESEG	
DORET  . . . . . . . . . . . . .	L Near	 115C	  CODESEG	
DORG . . . . . . . . . . . . . .	L Near	 14A7	  CODESEG	
DOSYMTAB . . . . . . . . . . . .	L Near	 160E	  CODESEG	
DO_OPEN  . . . . . . . . . . . .	L Near	 007A	  CODESEG	
DPUT . . . . . . . . . . . . . .	L Near	 14AF	  CODESEG	
DSJ  . . . . . . . . . . . . . .	L Near	 0EEB	  CODESEG	
DSKFUL . . . . . . . . . . . . .	L Near	 1893	  CODESEG	
E2 . . . . . . . . . . . . . . .	L Near	 00E0	  DATASEG	
E3 . . . . . . . . . . . . . . .	L Near	 00E7	  DATASEG	
E5 . . . . . . . . . . . . . . .	L Near	 00FD	  DATASEG	
EMARK  . . . . . . . . . . . . .	L Near	 1410	  CODESEG	
EMPTY  . . . . . . . . . . . . .	L Near	 0945	  CODESEG	
ENDCOND  . . . . . . . . . . . .	L Near	 131E	  CODESEG	
ENDDAT . . . . . . . . . . . . .	L Near	 12B0	  CODESEG	
ENDJ . . . . . . . . . . . . . .	L Near	 01C6	  CODESEG	
ENDLIN . . . . . . . . . . . . .	L Near	 01CB	  CODESEG	
ENDLN  . . . . . . . . . . . . .	L Near	 01C9	  CODESEG	
ENDOP  . . . . . . . . . . . . .	L Near	 0B23	  CODESEG	
ENDSYM . . . . . . . . . . . . .	L Near	 1632	  CODESEG	
ENDTERM_RET  . . . . . . . . . .	L Near	 054C	  CODESEG	
ENDTERM  . . . . . . . . . . . .	L Near	 0548	  CODESEG	
ENHEXL . . . . . . . . . . . . .	L Near	 180E	  CODESEG	
EOL  . . . . . . . . . . . . . .	Number	 000Dh	 
ERCNTM . . . . . . . . . . . . .	Byte	 0CA1	  DATASEG	
ERR10  . . . . . . . . . . . . .	L Near	 11A1	  CODESEG	
ERR11  . . . . . . . . . . . . .	L Near	 1293	  CODESEG	
ERR1 . . . . . . . . . . . . . .	L Near	 03AF	  CODESEG	
ERR2 . . . . . . . . . . . . . .	L Near	 0589	  CODESEG	
ERR30  . . . . . . . . . . . . .	L Near	 05C4	  CODESEG	
ERR4 . . . . . . . . . . . . . .	L Near	 06FD	  CODESEG	
ERR5 . . . . . . . . . . . . . .	L Near	 0A16	  CODESEG	
ERR6 . . . . . . . . . . . . . .	L Near	 0E7D	  CODESEG	
ERR7 . . . . . . . . . . . . . .	L Near	 0F3D	  CODESEG	
ERR8 . . . . . . . . . . . . . .	L Near	 104E	  CODESEG	
ERR9_RET . . . . . . . . . . . .	L Near	 11A4	  CODESEG	
ERR9 . . . . . . . . . . . . . .	L Near	 116E	  CODESEG	
ERRCNT . . . . . . . . . . . . .	DWord	 10F5	  DATASEG	
ERRJ1  . . . . . . . . . . . . .	L Near	 0FDC	  CODESEG	
ERRJ3  . . . . . . . . . . . . .	L Near	 0791	  CODESEG	
ERRJ4  . . . . . . . . . . . . .	L Near	 0C08	  CODESEG	
ERRJMP . . . . . . . . . . . . .	L Near	 1332	  CODESEG	
ERRJ . . . . . . . . . . . . . .	L Near	 121F	  CODESEG	
ERRLOOK  . . . . . . . . . . . .	L Near	 175E	  CODESEG	
ERROR  . . . . . . . . . . . . .	L Near	 021A	  CODESEG	
ERRTAB . . . . . . . . . . . . .	L Near	 085C	  DATASEG	
ESCIMM . . . . . . . . . . . . .	L Near	 1229	  CODESEG	
ESCMEM . . . . . . . . . . . . .	L Near	 1222	  CODESEG	
EXACC  . . . . . . . . . . . . .	L Near	 0E6A	  CODESEG	
EXIT . . . . . . . . . . . . . .	L Near	 1652	  CODESEG	
EXMEM1 . . . . . . . . . . . . .	L Near	 0E74	  CODESEG	
EXMEM  . . . . . . . . . . . . .	L Near	 0E71	  CODESEG	
EXPRESSION . . . . . . . . . . .	L Near	 04A1	  CODESEG	
EXTENDED . . . . . . . . . . . .	Number	 0010h	 
EXTEND . . . . . . . . . . . . .	Byte	 0CEE	  DATASEG	
FACTOR . . . . . . . . . . . . .	L Near	 054D	  CODESEG	
FILCHK . . . . . . . . . . . . .	L Near	 1563	  CODESEG	
FINDOP . . . . . . . . . . . . .	L Near	 0A90	  CODESEG	
FIND_DOT . . . . . . . . . . . .	L Near	 0043	  CODESEG	
FINIJ  . . . . . . . . . . . . .	L Near	 140D	  CODESEG	
FINIMM . . . . . . . . . . . . .	L Near	 0CAB	  CODESEG	
FINI . . . . . . . . . . . . . .	L Near	 15A4	  CODESEG	
FIXED  . . . . . . . . . . . . .	L Near	 0EA0	  CODESEG	
FIXLINE  . . . . . . . . . . . .	L Near	 1398	  CODESEG	
FIXUP  . . . . . . . . . . . . .	L Near	 13BB	  CODESEG	
FLAG . . . . . . . . . . . . . .	Byte	 1035	  DATASEG	
FLGTAB . . . . . . . . . . . . .	L Near	 0794	  CODESEG	
FLG  . . . . . . . . . . . . . .	L Near	 0427	  CODESEG	
FLUSHBUF . . . . . . . . . . . .	L Near	 186C	  CODESEG	
FNDNDP . . . . . . . . . . . . .	L Near	 0B13	  CODESEG	
FORMATTAB  . . . . . . . . . . .	L Near	 0C55	  CODESEG	
FPREG  . . . . . . . . . . . . .	L Near	 0799	  CODESEG	
FREG . . . . . . . . . . . . . .	Number	 0006h	 
FRESIZE  . . . . . . . . . . . .	Byte	 0CC8	  DATASEG	
G10  . . . . . . . . . . . . . .	L Near	 0FDE	  CODESEG	
GEN1_RET . . . . . . . . . . . .	L Near	 0D26	  CODESEG	
GEN1 . . . . . . . . . . . . . .	L Near	 0CE5	  CODESEG	
GENINT . . . . . . . . . . . . .	L Near	 11CE	  CODESEG	
GEN  . . . . . . . . . . . . . .	L Near	 0CE2	  CODESEG	
GETCHR_RET . . . . . . . . . . .	L Near	 0625	  CODESEG	
GETCHR . . . . . . . . . . . . .	L Near	 0613	  CODESEG	
GETCH  . . . . . . . . . . . . .	L Near	 025A	  CODESEG	
GETDAT . . . . . . . . . . . . .	L Near	 1299	  CODESEG	
GETEOL . . . . . . . . . . . . .	L Near	 01E0	  CODESEG	
GETFACT  . . . . . . . . . . . .	L Near	 050F	  CODESEG	
GETFORMAT  . . . . . . . . . . .	L Near	 0C24	  CODESEG	
GETLAB . . . . . . . . . . . . .	L Near	 09B3	  CODESEG	
GETLET_RET . . . . . . . . . . .	L Near	 0748	  CODESEG	
GETLET . . . . . . . . . . . . .	L Near	 0700	  CODESEG	
GETOP1 . . . . . . . . . . . . .	L Near	 03BE	  CODESEG	
GETOP2 . . . . . . . . . . . . .	L Near	 03B2	  CODESEG	
GETOP  . . . . . . . . . . . . .	L Near	 03BB	  CODESEG	
GETSP  . . . . . . . . . . . . .	L Near	 10EF	  CODESEG	
GETSYM_RET . . . . . . . . . . .	L Near	 0630	  CODESEG	
GETSYM . . . . . . . . . . . . .	L Near	 0626	  CODESEG	
GETSY_SKIP2  . . . . . . . . . .	L Near	 068E	  CODESEG	
GETSY_SKIP . . . . . . . . . . .	L Near	 0666	  CODESEG	
GETSY  . . . . . . . . . . . . .	L Near	 064F	  CODESEG	
GETVAL . . . . . . . . . . . . .	L Near	 0438	  CODESEG	
GOTIT  . . . . . . . . . . . . .	L Near	 06E7	  CODESEG	
GOTOP  . . . . . . . . . . . . .	L Near	 10AC	  CODESEG	
GRP10  . . . . . . . . . . . . .	L Near	 0FC3	  CODESEG	
GRP11  . . . . . . . . . . . . .	L Near	 0FEE	  CODESEG	
GRP12  . . . . . . . . . . . . .	L Near	 0FF6	  CODESEG	
GRP13  . . . . . . . . . . . . .	L Near	 1025	  CODESEG	
GRP14  . . . . . . . . . . . . .	L Near	 1051	  CODESEG	
GRP16  . . . . . . . . . . . . .	L Near	 10D9	  CODESEG	
GRP17  . . . . . . . . . . . . .	L Near	 1164	  CODESEG	
GRP18  . . . . . . . . . . . . .	L Near	 11A5	  CODESEG	
GRP19  . . . . . . . . . . . . .	L Near	 11D6	  CODESEG	
GRP1 . . . . . . . . . . . . . .	L Near	 0C65	  CODESEG	
GRP20  . . . . . . . . . . . . .	L Near	 1249	  CODESEG	
GRP21  . . . . . . . . . . . . .	L Near	 125A	  CODESEG	
GRP22_SKIP2  . . . . . . . . . .	L Near	 128B	  CODESEG	
GRP22_SKIP . . . . . . . . . . .	L Near	 1282	  CODESEG	
GRP22  . . . . . . . . . . . . .	L Near	 1272	  CODESEG	
GRP23  . . . . . . . . . . . . .	L Near	 1296	  CODESEG	
GRP2_SKIP  . . . . . . . . . . .	L Near	 0E02	  CODESEG	
GRP2 . . . . . . . . . . . . . .	L Near	 0DE6	  CODESEG	
GRP3 . . . . . . . . . . . . . .	L Near	 0E19	  CODESEG	
GRP4 . . . . . . . . . . . . . .	L Near	 0E80	  CODESEG	
GRP5 . . . . . . . . . . . . . .	L Near	 0EA8	  CODESEG	
GRP6 . . . . . . . . . . . . . .	L Near	 0F34	  CODESEG	
GRP7 . . . . . . . . . . . . . .	L Near	 0F40	  CODESEG	
GRP8 . . . . . . . . . . . . . .	L Near	 0F6D	  CODESEG	
GRP9 . . . . . . . . . . . . . .	L Near	 0F73	  CODESEG	
H3 . . . . . . . . . . . . . . .	L Near	 0107	  DATASEG	
H4 . . . . . . . . . . . . . . .	L Near	 010F	  DATASEG	
HAS_FILE_NAME  . . . . . . . . .	L Near	 001D	  CODESEG	
HAVDEF . . . . . . . . . . . . .	L Near	 13D2	  CODESEG	
HAVMES . . . . . . . . . . . . .	L Near	 176A	  CODESEG	
HAVNDP . . . . . . . . . . . . .	L Near	 0B5E	  CODESEG	
HAVOP  . . . . . . . . . . . . .	L Near	 0ABA	  CODESEG	
HAVREG . . . . . . . . . . . . .	L Near	 07CE	  CODESEG	
HEAP_START . . . . . . . . . . .	L Near	 1B84	  DATASEG	
HEX1 . . . . . . . . . . . . . .	L Near	 06D5	  CODESEG	
HEXADD . . . . . . . . . . . . .	DWord	 10DB	  DATASEG	
HEXBUFSIZ  . . . . . . . . . . .	Number	 0046h	 
HEXBUF . . . . . . . . . . . . .	Byte	 1135	  DATASEG	
HEXBYT . . . . . . . . . . . . .	L Near	 17E2	  CODESEG	
HEXCNT . . . . . . . . . . . . .	DWord	 10E3	  DATASEG	
HEXEND . . . . . . . . . . . . .	L Near	 15E8	  CODESEG	
HEXFILE  . . . . . . . . . . . .	DWord	 0E20	  DATASEG	
HEXLEN . . . . . . . . . . . . .	DWord	 10D7	  DATASEG	
HEXNAME  . . . . . . . . . . . .	Byte	 0E28	  DATASEG	
HEXPNT . . . . . . . . . . . . .	DWord	 1115	  DATASEG	
HEX  . . . . . . . . . . . . . .	L Near	 06CD	  CODESEG	
HIDIG  . . . . . . . . . . . . .	L Near	 1531	  CODESEG	
I2 . . . . . . . . . . . . . . .	L Near	 0118	  DATASEG	
I3 . . . . . . . . . . . . . . .	L Near	 0125	  DATASEG	
I4 . . . . . . . . . . . . . . .	L Near	 0142	  DATASEG	
ID . . . . . . . . . . . . . . .	Byte	 103A	  DATASEG	
IFEND  . . . . . . . . . . . . .	Byte	 0CF4	  DATASEG	
IFFLG  . . . . . . . . . . . . .	Byte	 10F3	  DATASEG	
IFNEST . . . . . . . . . . . . .	Byte	 0CFA	  DATASEG	
IMMED  . . . . . . . . . . . . .	L Near	 0C95	  CODESEG	
IMM_RET  . . . . . . . . . . . .	L Near	 0CD3	  CODESEG	
IMM  . . . . . . . . . . . . . .	L Near	 0CC4	  CODESEG	
INTEGER  . . . . . . . . . . . .	Number	 0020h	 
IX . . . . . . . . . . . . . . .	DWord	 110D	  DATASEG	
IY . . . . . . . . . . . . . . .	DWord	 1111	  DATASEG	
J2 . . . . . . . . . . . . . . .	L Near	 0163	  DATASEG	
J3 . . . . . . . . . . . . . . .	L Near	 01A0	  DATASEG	
J4 . . . . . . . . . . . . . . .	L Near	 0218	  DATASEG	
L0002  . . . . . . . . . . . . .	L Near	 01BA	  CODESEG	
L0003  . . . . . . . . . . . . .	L Near	 05D9	  CODESEG	
L0004  . . . . . . . . . . . . .	L Near	 0775	  CODESEG	
L0006  . . . . . . . . . . . . .	L Near	 0C7D	  CODESEG	
L0008  . . . . . . . . . . . . .	L Near	 0E56	  CODESEG	
L0011  . . . . . . . . . . . . .	L Near	 112D	  CODESEG	
L0012  . . . . . . . . . . . . .	L Near	 15E1	  CODESEG	
L0014  . . . . . . . . . . . . .	L Near	 1684	  CODESEG	
L3 . . . . . . . . . . . . . . .	L Near	 0249	  DATASEG	
L4 . . . . . . . . . . . . . . .	L Near	 025F	  DATASEG	
L5 . . . . . . . . . . . . . . .	L Near	 0288	  DATASEG	
L6 . . . . . . . . . . . . . . .	L Near	 02AD	  DATASEG	
LABCHK . . . . . . . . . . . . .	L Near	 09DD	  CODESEG	
LABPT  . . . . . . . . . . . . .	DWord	 1094	  DATASEG	
LASTAD . . . . . . . . . . . . .	DWord	 10DF	  DATASEG	
LAST_READ_CHAR_COUNT . . . . . .	DWord	 1129	  DATASEG	
LEAD . . . . . . . . . . . . . .	L Near	 1515	  CODESEG	
LENID  . . . . . . . . . . . . .	DWord	 1036	  DATASEG	
LETTER . . . . . . . . . . . . .	L Near	 0749	  CODESEG	
LHALF_RET  . . . . . . . . . . .	L Near	 18AE	  CODESEG	
LHALF  . . . . . . . . . . . . .	L Near	 18A4	  CODESEG	
LINE_COUNT . . . . . . . . . . .	DWord	 1121	  DATASEG	
LINE . . . . . . . . . . . . . .	DWord	 10D3	  DATASEG	
LINFLG . . . . . . . . . . . . .	DWord	 10EB	  DATASEG	
LIST . . . . . . . . . . . . . .	L Near	 155B	  CODESEG	
LOCATE_OPTAB . . . . . . . . . .	L Near	 0A53	  CODESEG	
LONGJ  . . . . . . . . . . . . .	L Near	 10C0	  CODESEG	
LONGR  . . . . . . . . . . . . .	L Near	 1104	  CODESEG	
LOOKIT_RET . . . . . . . . . . .	L Near	 0937	  CODESEG	
LOOKIT . . . . . . . . . . . . .	L Near	 090F	  CODESEG	
LOOKNDP  . . . . . . . . . . . .	L Near	 0B0C	  CODESEG	
LOOKRET  . . . . . . . . . . . .	L Near	 089F	  CODESEG	
LOOKUP . . . . . . . . . . . . .	L Near	 0909	  CODESEG	
LOOK . . . . . . . . . . . . . .	L Near	 0853	  CODESEG	
LSTBUFSIZ  . . . . . . . . . . .	Text   	 BUFSIZ
LSTBUF . . . . . . . . . . . . .	Byte	 117B	  DATASEG	
LSTDEV . . . . . . . . . . . . .	DWord	 1101	  DATASEG	
LSTFILE  . . . . . . . . . . . .	DWord	 0E24	  DATASEG	
LSTNAME  . . . . . . . . . . . .	Byte	 0F2E	  DATASEG	
LSTPNT . . . . . . . . . . . . .	DWord	 1119	  DATASEG	
LSTRET . . . . . . . . . . . . .	DWord	 10F9	  DATASEG	
M3 . . . . . . . . . . . . . . .	L Near	 02C2	  DATASEG	
M4 . . . . . . . . . . . . . . .	L Near	 02D1	  DATASEG	
M5 . . . . . . . . . . . . . . .	L Near	 02E2	  DATASEG	
MAKFIL_RET . . . . . . . . . . .	L Near	 0219	  CODESEG	
MAXFLG . . . . . . . . . . . . .	Byte	 1034	  DATASEG	
MEMOP  . . . . . . . . . . . . .	L Near	 0C0B	  CODESEG	
MEMORY . . . . . . . . . . . . .	Number	 0018h	 
MEM  . . . . . . . . . . . . . .	L Near	 03F8	  CODESEG	
MODE_RET . . . . . . . . . . . .	L Near	 0494	  CODESEG	
MODE . . . . . . . . . . . . . .	L Near	 0463	  CODESEG	
MOP  . . . . . . . . . . . . . .	L Near	 0FA0	  CODESEG	
MOREID . . . . . . . . . . . . .	L Near	 0721	  CODESEG	
MRERR  . . . . . . . . . . . . .	L Near	 03AD	  CODESEG	
MROPS  . . . . . . . . . . . . .	L Near	 02CA	  CODESEG	
MULOP  . . . . . . . . . . . . .	L Near	 04FE	  CODESEG	
N3 . . . . . . . . . . . . . . .	L Near	 02F5	  DATASEG	
NAME_LENGTH  . . . . . . . . . .	Number	 0104h	 
NDPA . . . . . . . . . . . . . .	L Near	 047F	  DATASEG	
NDPB . . . . . . . . . . . . . .	L Near	 048D	  DATASEG	
NDPC . . . . . . . . . . . . . .	L Near	 0497	  DATASEG	
NDPD . . . . . . . . . . . . . .	L Near	 04B0	  DATASEG	
NDPE . . . . . . . . . . . . . .	L Near	 04D1	  DATASEG	
NDPF . . . . . . . . . . . . . .	L Near	 04D6	  DATASEG	
NDPI . . . . . . . . . . . . . .	L Near	 04DC	  DATASEG	
NDPL . . . . . . . . . . . . . .	L Near	 0521	  DATASEG	
NDPM . . . . . . . . . . . . . .	L Near	 0555	  DATASEG	
NDPN . . . . . . . . . . . . . .	L Near	 0563	  DATASEG	
NDPOP  . . . . . . . . . . . . .	L Near	 0AC1	  CODESEG	
NDPO . . . . . . . . . . . . . .	L Near	 055F	  DATASEG	
NDPP . . . . . . . . . . . . . .	L Near	 0568	  DATASEG	
NDPR . . . . . . . . . . . . . .	L Near	 0579	  DATASEG	
NDPS . . . . . . . . . . . . . .	L Near	 0587	  DATASEG	
NDPTAB . . . . . . . . . . . . .	L Near	 07F4	  DATASEG	
NDPT . . . . . . . . . . . . . .	L Near	 05C3	  DATASEG	
NDPW . . . . . . . . . . . . . .	L Near	 05C8	  DATASEG	
NDPX . . . . . . . . . . . . . .	L Near	 05CE	  DATASEG	
NDPY . . . . . . . . . . . . . .	L Near	 05DE	  DATASEG	
NEEDOP . . . . . . . . . . . . .	Number	 0080h	 
NEL  . . . . . . . . . . . . . .	Number	 000Ah	 
NEWLIN . . . . . . . . . . . . .	L Near	 17B3	  CODESEG	
NEWLOC . . . . . . . . . . . . .	L Near	 0F22	  CODESEG	
NEXBT  . . . . . . . . . . . . .	L Near	 13A6	  CODESEG	
NEXB . . . . . . . . . . . . . .	L Near	 063C	  CODESEG	
NEXFACT  . . . . . . . . . . . .	L Near	 053F	  CODESEG	
NEXLIN_RET . . . . . . . . . . .	L Near	 01ED	  CODESEG	
NEXLIN . . . . . . . . . . . . .	L Near	 01D5	  CODESEG	
NEXSYMLIN  . . . . . . . . . . .	L Near	 16E5	  CODESEG	
NEXTCHJ  . . . . . . . . . . . .	L Near	 064C	  CODESEG	
NEXTCHR  . . . . . . . . . . . .	L Near	 021E	  CODESEG	
NEXTERM  . . . . . . . . . . . .	L Near	 04E3	  CODESEG	
NEXTMES  . . . . . . . . . . . .	L Near	 1763	  CODESEG	
NOCON  . . . . . . . . . . . . .	L Near	 04F1	  CODESEG	
NODEC  . . . . . . . . . . . . .	L Near	 112F	  CODESEG	
NODESIZE . . . . . . . . . . . .	Number	 0080h	 
NODE . . . . . . . . . . . . . .	L Near	 1662	  CODESEG	
NOERR  . . . . . . . . . . . . .	L Near	 142E	  CODESEG	
NOEXT_RET  . . . . . . . . . . .	L Near	 173F	  CODESEG	
NOEXT  . . . . . . . . . . . . .	L Near	 172C	  CODESEG	
NOFILE . . . . . . . . . . . . .	Byte	 0C69	  DATASEG	
NOFIL  . . . . . . . . . . . . .	L Near	 1466	  CODESEG	
NOFLG  . . . . . . . . . . . . .	L Near	 076C	  CODESEG	
NOIND  . . . . . . . . . . . . .	L Near	 0495	  CODESEG	
NOMEM  . . . . . . . . . . . . .	Byte	 0C51	  DATASEG	
NOMOD  . . . . . . . . . . . . .	L Near	 02AF	  CODESEG	
NOMORE . . . . . . . . . . . . .	L Near	 073D	  CODESEG	
NONE . . . . . . . . . . . . . .	Byte	 0000	  DATASEG	
NOOPCHK  . . . . . . . . . . . .	L Near	 0BDD	  CODESEG	
NOOPS  . . . . . . . . . . . . .	L Near	 0BE5	  CODESEG	
NOREV  . . . . . . . . . . . . .	L Near	 0BFA	  CODESEG	
NOSPAC . . . . . . . . . . . . .	Byte	 0C39	  DATASEG	
NOT1 . . . . . . . . . . . . . .	L Near	 09CF	  CODESEG	
NOTAC  . . . . . . . . . . . . .	L Near	 0391	  CODESEG	
NOTLON . . . . . . . . . . . . .	L Near	 111B	  CODESEG	
NOTRG  . . . . . . . . . . . . .	L Near	 1075	  CODESEG	
NOUNDEF  . . . . . . . . . . . .	L Near	 0D9E	  CODESEG	
NOWAIT . . . . . . . . . . . . .	DWord	 1109	  DATASEG	
NO_DOT . . . . . . . . . . . . .	L Near	 0058	  CODESEG	
NREG . . . . . . . . . . . . . .	L Near	 03EE	  CODESEG	
NWAIT  . . . . . . . . . . . . .	L Near	 0B6D	  CODESEG	
O2 . . . . . . . . . . . . . . .	L Near	 030B	  DATASEG	
O3 . . . . . . . . . . . . . . .	L Near	 0312	  DATASEG	
O4 . . . . . . . . . . . . . . .	L Near	 0321	  DATASEG	
OBJBT  . . . . . . . . . . . . .	L Near	 13B8	  CODESEG	
OBJECT . . . . . . . . . . . . .	Number	 0100h	 
OK_FILE  . . . . . . . . . . . .	L Near	 0090	  CODESEG	
OLDPC  . . . . . . . . . . . . .	DWord	 1090	  DATASEG	
ONEJ . . . . . . . . . . . . . .	L Near	 0FEC	  CODESEG	
ONEOP  . . . . . . . . . . . . .	L Near	 0F77	  CODESEG	
ONEREG . . . . . . . . . . . . .	Number	 0040h	 
ONE  . . . . . . . . . . . . . .	L Near	 0F7C	  CODESEG	
OPEN_FLAG  . . . . . . . . . . .	Byte	 0D00	  DATASEG	
OPERATE  . . . . . . . . . . . .	L Near	 04C8	  CODESEG	
OPERRJ . . . . . . . . . . . . .	L Near	 0B2C	  CODESEG	
OPERR  . . . . . . . . . . . . .	L Near	 0AB5	  CODESEG	
OPTAB  . . . . . . . . . . . . .	L Near	 05EC	  DATASEG	
OUT10  . . . . . . . . . . . . .	L Near	 1503	  CODESEG	
OUTA . . . . . . . . . . . . . .	L Near	 1789	  CODESEG	
OUTLIN . . . . . . . . . . . . .	L Near	 14B7	  CODESEG	
OUTLN  . . . . . . . . . . . . .	L Near	 14D7	  CODESEG	
P3 . . . . . . . . . . . . . . .	L Near	 0332	  DATASEG	
P4 . . . . . . . . . . . . . . .	L Near	 0341	  DATASEG	
P5 . . . . . . . . . . . . . . .	L Near	 0352	  DATASEG	
PACKREG  . . . . . . . . . . . .	L Near	 1265	  CODESEG	
PAREN  . . . . . . . . . . . . .	L Near	 05A4	  CODESEG	
PC . . . . . . . . . . . . . . .	DWord	 108C	  DATASEG	
PHEXB  . . . . . . . . . . . . .	L Near	 1556	  CODESEG	
PHEX . . . . . . . . . . . . . .	L Near	 1595	  CODESEG	
PLSMNS . . . . . . . . . . . . .	L Near	 04BC	  CODESEG	
PMEM . . . . . . . . . . . . . .	L Near	 0E07	  CODESEG	
PREG . . . . . . . . . . . . . .	L Near	 082A	  CODESEG	
PRERR  . . . . . . . . . . . . .	L Near	 01F4	  CODESEG	
PRET . . . . . . . . . . . . . .	L Near	 0D97	  CODESEG	
PREV . . . . . . . . . . . . . .	DWord	 10EF	  DATASEG	
PRINT  . . . . . . . . . . . . .	L Near	 177B	  CODESEG	
PRNERR . . . . . . . . . . . . .	L Near	 1775	  CODESEG	
PRNT10 . . . . . . . . . . . . .	L Near	 14EE	  CODESEG	
PRTCNT . . . . . . . . . . . . .	L Near	 14E4	  CODESEG	
PUTADDJ  . . . . . . . . . . . .	L Near	 1095	  CODESEG	
PUTADD . . . . . . . . . . . . .	L Near	 0DB9	  CODESEG	
PUTBJ  . . . . . . . . . . . . .	L Near	 0C92	  CODESEG	
PUTBW  . . . . . . . . . . . . .	L Near	 0D67	  CODESEG	
PUTBYT . . . . . . . . . . . . .	L Near	 0D42	  CODESEG	
PUTCD  . . . . . . . . . . . . .	L Near	 0D2C	  CODESEG	
PUTCHK . . . . . . . . . . . . .	L Near	 0D71	  CODESEG	
PUTCHR . . . . . . . . . . . . .	L Near	 1860	  CODESEG	
PUTINC . . . . . . . . . . . . .	L Near	 0D27	  CODESEG	
PUTMEM . . . . . . . . . . . . .	L Near	 0C45	  CODESEG	
PUTOP  . . . . . . . . . . . . .	L Near	 0EDA	  CODESEG	
PUTREG . . . . . . . . . . . . .	L Near	 0BCC	  CODESEG	
PUTWOR . . . . . . . . . . . . .	L Near	 0D38	  CODESEG	
PUT  . . . . . . . . . . . . . .	L Near	 0CD4	  CODESEG	
PXREG  . . . . . . . . . . . . .	L Near	 0E12	  CODESEG	
QUIT . . . . . . . . . . . . . .	L Near	 01FB	  CODESEG	
R3 . . . . . . . . . . . . . . .	L Near	 035C	  DATASEG	
R4 . . . . . . . . . . . . . . .	L Near	 0387	  DATASEG	
R5 . . . . . . . . . . . . . . .	L Near	 0398	  DATASEG	
READID . . . . . . . . . . . . .	L Near	 0719	  CODESEG	
REAL . . . . . . . . . . . . . .	Number	 0028h	 
REGCHK . . . . . . . . . . . . .	L Near	 07D3	  CODESEG	
REGTAB . . . . . . . . . . . . .	Byte	 0D06	  DATASEG	
REG  . . . . . . . . . . . . . .	Number	 0002h	 
RELOC  . . . . . . . . . . . . .	DWord	 10C3	  DATASEG	
REPERR . . . . . . . . . . . . .	L Near	 1740	  CODESEG	
RETPT  . . . . . . . . . . . . .	DWord	 10FD	  DATASEG	
RETSTR . . . . . . . . . . . . .	Byte	 0CFD	  DATASEG	
RIGHTSON . . . . . . . . . . . .	L Near	 16ED	  CODESEG	
RNGERR . . . . . . . . . . . . .	L Near	 1406	  CODESEG	
ROP  . . . . . . . . . . . . . .	L Near	 0FB3	  CODESEG	
RR1  . . . . . . . . . . . . . .	L Near	 030F	  CODESEG	
RR . . . . . . . . . . . . . . .	L Near	 0309	  CODESEG	
S3 . . . . . . . . . . . . . . .	L Near	 03AB	  DATASEG	
S4 . . . . . . . . . . . . . . .	L Near	 03F9	  DATASEG	
S5 . . . . . . . . . . . . . . .	L Near	 0422	  DATASEG	
SAVCD  . . . . . . . . . . . . .	L Near	 16FB	  CODESEG	
SAVDAT_SKIP  . . . . . . . . . .	L Near	 12CA	  CODESEG	
SAVDAT . . . . . . . . . . . . .	L Near	 12C3	  CODESEG	
SAVFLG . . . . . . . . . . . . .	L Near	 0782	  CODESEG	
SAVNFLG  . . . . . . . . . . . .	L Near	 0AD6	  CODESEG	
SAVPT  . . . . . . . . . . . . .	L Near	 158D	  CODESEG	
SCANB_RET  . . . . . . . . . . .	L Near	 0641	  CODESEG	
SCANB  . . . . . . . . . . . . .	L Near	 0631	  CODESEG	
SCANREG_RET  . . . . . . . . . .	L Near	 0852	  CODESEG	
SCANREG  . . . . . . . . . . . .	L Near	 0837	  CODESEG	
SCANT  . . . . . . . . . . . . .	L Near	 0634	  CODESEG	
SEEK_CUR . . . . . . . . . . . .	Number	 0001h	 
SEEK_END . . . . . . . . . . . .	Number	 0002h	 
SEEK_SET . . . . . . . . . . . .	Number	 0000h	 
SEGCHK . . . . . . . . . . . . .	L Near	 0327	  CODESEG	
SEGTAB . . . . . . . . . . . . .	Byte	 0D0A	  DATASEG	
SHOLIN . . . . . . . . . . . . .	L Near	 1449	  CODESEG	
SIJ  . . . . . . . . . . . . . .	L Near	 058F	  CODESEG	
SKIPCD . . . . . . . . . . . . .	L Near	 12D7	  CODESEG	
SKIPLP . . . . . . . . . . . . .	L Near	 12DB	  CODESEG	
SKIP_ABORT . . . . . . . . . . .	L Near	 0972	  CODESEG	
SKIP_FOUND_END . . . . . . . . .	L Near	 0296	  CODESEG	
SKIP_LINE_END  . . . . . . . . .	L Near	 02A0	  CODESEG	
SKIP_NOMOD . . . . . . . . . . .	L Near	 02C6	  CODESEG	
SMALL  . . . . . . . . . . . . .	L Near	 0887	  CODESEG	
SMPUT  . . . . . . . . . . . . .	L Near	 0D91	  CODESEG	
SPCFUN . . . . . . . . . . . . .	L Near	 148D	  CODESEG	
SPC  . . . . . . . . . . . . . .	DWord	 1105	  DATASEG	
SPECIALOP  . . . . . . . . . . .	L Near	 0B3A	  CODESEG	
SPEND  . . . . . . . . . . . . .	L Near	 1482	  CODESEG	
SRCBUF_COUNT . . . . . . . . . .	DWord	 1131	  DATASEG	
SRCBUF . . . . . . . . . . . . .	Byte	 1580	  DATASEG	
SRCFILE  . . . . . . . . . . . .	DWord	 0E1C	  DATASEG	
SRCLENGTH  . . . . . . . . . . .	DWord	 0E18	  DATASEG	
SRCNAME_LENGTH . . . . . . . . .	DWord	 0E14	  DATASEG	
SRCNAME  . . . . . . . . . . . .	Byte	 0D0E	  DATASEG	
SREG . . . . . . . . . . . . . .	Number	 0004h	 
ST0DEST  . . . . . . . . . . . .	L Near	 0BC8	  CODESEG	
STACKOP  . . . . . . . . . . . .	Number	 0010h	 
STACK_ . . . . . . . . . . . . .	DWord	 111D	  DATASEG	
STERR  . . . . . . . . . . . . .	L Near	 03AB	  CODESEG	
STIMM  . . . . . . . . . . . . .	L Near	 0CB9	  CODESEG	
STRGDAT  . . . . . . . . . . . .	L Near	 05EA	  CODESEG	
STRING . . . . . . . . . . . . .	L Near	 05C7	  CODESEG	
STRTLIN  . . . . . . . . . . . .	L Near	 1545	  CODESEG	
SUPZ . . . . . . . . . . . . . .	L Near	 1541	  CODESEG	
SYMLIN . . . . . . . . . . . . .	DWord	 10BA	  DATASEG	
SYMMES . . . . . . . . . . . . .	Byte	 0CDC	  DATASEG	
SYMSAV . . . . . . . . . . . . .	L Near	 077E	  CODESEG	
SYMSIZE  . . . . . . . . . . . .	Byte	 0CB2	  DATASEG	
SYMWID . . . . . . . . . . . . .	Number	 0005h	 
SYM  . . . . . . . . . . . . . .	Byte	 10B1	  DATASEG	
SYSTEM_RET . . . . . . . . . . .	L Near	 1790	  CODESEG	
SYSTEM . . . . . . . . . . . . .	L Near	 1790	  CODESEG	
T4 . . . . . . . . . . . . . . .	L Near	 0447	  DATASEG	
TABVAL . . . . . . . . . . . . .	L Near	 16BC	  CODESEG	
TAB  . . . . . . . . . . . . . .	L Near	 1725	  CODESEG	
TERM . . . . . . . . . . . . . .	L Near	 04FB	  CODESEG	
TESTTYP  . . . . . . . . . . . .	L Near	 13B1	  CODESEG	
TOTAL_READ_CHAR_COUNT  . . . . .	DWord	 112D	  DATASEG	
TRY2XM1  . . . . . . . . . . . .	L Near	 0B2E	  CODESEG	
TWOBT  . . . . . . . . . . . . .	L Near	 0DDA	  CODESEG	
U2 . . . . . . . . . . . . . . .	L Near	 0450	  DATASEG	
UHALF  . . . . . . . . . . . . .	L Near	 189C	  CODESEG	
UNDEFID  . . . . . . . . . . . .	Number	 0000h	 
UNDEF  . . . . . . . . . . . . .	DWord	 10AC	  DATASEG	
UVAL . . . . . . . . . . . . . .	L Near	 05B4	  CODESEG	
VAL1 . . . . . . . . . . . . . .	L Near	 03D4	  CODESEG	
VAL  . . . . . . . . . . . . . .	L Near	 03D2	  CODESEG	
W4 . . . . . . . . . . . . . . .	L Near	 0457	  DATASEG	
WREND  . . . . . . . . . . . . .	L Near	 1337	  CODESEG	
WRITE_FLAG . . . . . . . . . . .	Byte	 0D03	  DATASEG	
WRTBUF . . . . . . . . . . . . .	L Near	 156D	  CODESEG	
WRTERR . . . . . . . . . . . . .	Byte	 0C7C	  DATASEG	
WRTHEX_RET . . . . . . . . . . .	L Near	 185F	  CODESEG	
WRTHEX . . . . . . . . . . . . .	L Near	 1838	  CODESEG	
WRTSYM . . . . . . . . . . . . .	L Near	 16AE	  CODESEG	
X3 . . . . . . . . . . . . . . .	L Near	 0460	  DATASEG	
X4 . . . . . . . . . . . . . . .	L Near	 0468	  DATASEG	
XM1  . . . . . . . . . . . . . .	L Near	 0479	  DATASEG	
XREG . . . . . . . . . . . . . .	Number	 0003h	 
XRG  . . . . . . . . . . . . . .	L Near	 036F	  CODESEG	
ZERLEN . . . . . . . . . . . . .	L Near	 060B	  CODESEG	
_ADDR  . . . . . . . . . . . . .	DWord	 1098	  DATASEG	
_ADD . . . . . . . . . . . . . .	L Near	 04E0	  CODESEG	
_ALIGN . . . . . . . . . . . . .	L Near	 0EDE	  CODESEG	
_ASM32_ENTRY@8 . . . . . . . . .	L Near	 0000	  CODESEG	Public
_DATA  . . . . . . . . . . . . .	DWord	 10A0	  DATASEG	
_DEC_SKIP  . . . . . . . . . . .	L Near	 06AD	  CODESEG	
_DEC . . . . . . . . . . . . . .	L Near	 0699	  CODESEG	
_ENDIF . . . . . . . . . . . . .	L Near	 1325	  CODESEG	
_END . . . . . . . . . . . . . .	L Near	 1335	  CODESEG	
_ENTER . . . . . . . . . . . . .	L Near	 0938	  CODESEG	
_EQU_RET . . . . . . . . . . . .	L Near	 0F1A	  CODESEG	
_EQU . . . . . . . . . . . . . .	L Near	 0F02	  CODESEG	
_ERRMES  . . . . . . . . . . . .	Byte	 0C2B	  DATASEG	
_ERR . . . . . . . . . . . . . .	DWord	 10CF	  DATASEG	
_FWAIT . . . . . . . . . . . . .	L Near	 0B56	  CODESEG	
_HEAP  . . . . . . . . . . . . .	DWord	 10B6	  DATASEG	
_IF  . . . . . . . . . . . . . .	L Near	 12CD	  CODESEG	
_LABEL_SKIP  . . . . . . . . . .	L Near	 09EE	  CODESEG	
_LABEL . . . . . . . . . . . . .	L Near	 09E4	  CODESEG	
_LOAD  . . . . . . . . . . . . .	L Near	 035C	  CODESEG	
_LOOP  . . . . . . . . . . . . .	L Near	 01A1	  CODESEG	
_ORG . . . . . . . . . . . . . .	L Near	 0F1B	  CODESEG	
_OUT . . . . . . . . . . . . . .	L Near	 178B	  CODESEG	
_STORE . . . . . . . . . . . . .	L Near	 0351	  CODESEG	
_cprintf . . . . . . . . . . . .	L Near	 0000	  CODESEG	External
_fclose  . . . . . . . . . . . .	L Near	 0000	  CODESEG	External
_feof  . . . . . . . . . . . . .	L Near	 0000	  CODESEG	External
_fopen . . . . . . . . . . . . .	L Near	 0000	  CODESEG	External
_fread . . . . . . . . . . . . .	L Near	 0000	  CODESEG	External
_fseek . . . . . . . . . . . . .	L Near	 0000	  CODESEG	External
_ftell . . . . . . . . . . . . .	L Near	 0000	  CODESEG	External
_fwrite  . . . . . . . . . . . .	L Near	 0000	  CODESEG	External

	   0 Warnings
	   0 Errors
